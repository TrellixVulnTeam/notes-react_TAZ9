{"ast":null,"code":"var __read = this && this.__read || function (o, n) {\n  var m = typeof Symbol === \"function\" && o[Symbol.iterator];\n  if (!m) return o;\n  var i = m.call(o),\n      r,\n      ar = [],\n      e;\n\n  try {\n    while ((n === void 0 || n-- > 0) && !(r = i.next()).done) ar.push(r.value);\n  } catch (error) {\n    e = {\n      error: error\n    };\n  } finally {\n    try {\n      if (r && !r.done && (m = i[\"return\"])) m.call(i);\n    } finally {\n      if (e) throw e.error;\n    }\n  }\n\n  return ar;\n};\n\nimport { useCallback, useState } from \"react\";\nimport { getViewportSize } from \"@react-md/utils\";\nimport { DEFAULT_TOOLTIP_THRESHOLD } from \"./constants\";\n/** @internal */\n\nvar noop = function () {// do nothing\n};\n/**\n * A hook that's used to determine the \"best\" position to render the tooltip\n * within the viewport.\n *\n * @internal\n * @remarks \\@since 2.8.0\n */\n\n\nexport function useTooltipPosition(_a) {\n  var determinedPosition = _a.position,\n      _b = _a.defaultPosition,\n      defaultPosition = _b === void 0 ? \"below\" : _b,\n      _c = _a.threshold,\n      threshold = _c === void 0 ? DEFAULT_TOOLTIP_THRESHOLD : _c;\n\n  var _d = __read(useState(defaultPosition), 2),\n      position = _d[0],\n      setPosition = _d[1];\n\n  var updatePosition = useCallback(function (container) {\n    var _a = container.getBoundingClientRect(),\n        top = _a.top,\n        left = _a.left;\n\n    var vh = getViewportSize(\"height\");\n    var vw = getViewportSize(\"width\");\n    var nextPosition = defaultPosition;\n\n    if (defaultPosition === \"above\" && top < vh * threshold) {\n      nextPosition = \"below\";\n    } else if (defaultPosition === \"below\" && top > vh * threshold) {\n      nextPosition = \"above\";\n    } else if (defaultPosition === \"left\" && left < vw * threshold) {\n      nextPosition = \"right\";\n    } else if (defaultPosition === \"right\" && left > vw * threshold) {\n      nextPosition = \"left\";\n    }\n\n    setPosition(nextPosition);\n  }, [defaultPosition, threshold]);\n\n  if (typeof determinedPosition !== \"undefined\") {\n    return [determinedPosition, noop];\n  }\n\n  return [position, updatePosition];\n}","map":{"version":3,"mappings":";;;;;;;;;;;;;;;;;;;;;;;;;AAAA,SAASA,WAAT,EAAsBC,QAAtB,QAAsC,OAAtC;AAEA,SAASC,eAAT,QAAgC,iBAAhC;AAEA,SAASC,yBAAT,QAA0C,aAA1C;AAEA;;AACA,IAAMC,IAAI,GAAG,aACX;AACD,CAFD;AAmDA;;;;;;;;;AAOA,OAAM,SAAUC,kBAAV,CAA6BC,EAA7B,EAIuB;MAHjBC,kBAAkB;MAC5BC;MAAAC,eAAe,mBAAG,OAAH,GAAUD;MACzBE;MAAAC,SAAS,mBAAGR,yBAAH,GAA4BO;;EAE/B,gBAA0BT,QAAQ,CAACQ,eAAD,CAAlC,EAAmD,CAAnD;EAAA,IAACG,QAAQ,QAAT;EAAA,IAAWC,WAAW,QAAtB;;EACN,IAAMC,cAAc,GAAGd,WAAW,CAChC,UAACe,SAAD,EAAU;IACF,SAAgBA,SAAS,CAACC,qBAAV,EAAhB;IAAA,IAAEC,GAAG,SAAL;IAAA,IAAOC,IAAI,UAAX;;IACN,IAAMC,EAAE,GAAGjB,eAAe,CAAC,QAAD,CAA1B;IACA,IAAMkB,EAAE,GAAGlB,eAAe,CAAC,OAAD,CAA1B;IACA,IAAImB,YAAY,GAAGZ,eAAnB;;IACA,IAAIA,eAAe,KAAK,OAApB,IAA+BQ,GAAG,GAAGE,EAAE,GAAGR,SAA9C,EAAyD;MACvDU,YAAY,GAAG,OAAf;IACD,CAFD,MAEO,IAAIZ,eAAe,KAAK,OAApB,IAA+BQ,GAAG,GAAGE,EAAE,GAAGR,SAA9C,EAAyD;MAC9DU,YAAY,GAAG,OAAf;IACD,CAFM,MAEA,IAAIZ,eAAe,KAAK,MAApB,IAA8BS,IAAI,GAAGE,EAAE,GAAGT,SAA9C,EAAyD;MAC9DU,YAAY,GAAG,OAAf;IACD,CAFM,MAEA,IAAIZ,eAAe,KAAK,OAApB,IAA+BS,IAAI,GAAGE,EAAE,GAAGT,SAA/C,EAA0D;MAC/DU,YAAY,GAAG,MAAf;IACD;;IAEDR,WAAW,CAACQ,YAAD,CAAX;EACD,CAjB+B,EAkBhC,CAACZ,eAAD,EAAkBE,SAAlB,CAlBgC,CAAlC;;EAqBA,IAAI,OAAOJ,kBAAP,KAA8B,WAAlC,EAA+C;IAC7C,OAAO,CAACA,kBAAD,EAAqBH,IAArB,CAAP;EACD;;EAED,OAAO,CAACQ,QAAD,EAAWE,cAAX,CAAP;AACD","names":["useCallback","useState","getViewportSize","DEFAULT_TOOLTIP_THRESHOLD","noop","useTooltipPosition","_a","determinedPosition","_b","defaultPosition","_c","threshold","position","setPosition","updatePosition","container","getBoundingClientRect","top","left","vh","vw","nextPosition"],"sources":["C:\\Users\\hungr\\Documents\\VS-CODE\\notes-react\\node_modules\\@react-md\\tooltip\\src\\useTooltipPosition.ts"],"sourcesContent":["import { useCallback, useState } from \"react\";\nimport type { SimplePosition } from \"@react-md/utils\";\nimport { getViewportSize } from \"@react-md/utils\";\n\nimport { DEFAULT_TOOLTIP_THRESHOLD } from \"./constants\";\n\n/** @internal */\nconst noop = (): void => {\n  // do nothing\n};\n\n/**\n * @remarks \\@since 2.8.0\n */\nexport interface TooltipPositionHookOptions {\n  /**\n   * An optional controlled position to use that will disable the functionality\n   * to determine the \"best\" position to render the tooltip within the viewport.\n   */\n  position?: SimplePosition;\n\n  /**\n   * An optional position to use before the positioning calculation has\n   * occurred. This is also used to determine if the position should be\n   * horizontal vs vertical.\n   *\n   * Vertical - `\"below\"` or `\"above\"`\n   * Horizontal - `\"left\"` or `\"right\"`\n   *\n   * @defaultValue `\"below\"`\n   */\n  defaultPosition?: SimplePosition;\n\n  /**\n   * This value should be between 0 and 1 and will be multiplied by either the\n   * viewport height or viewport width to determine the best position to render\n   * the tooltip based on available space within the viewport.\n   *\n   * You _probably_ won't ever really need to update this value.\n   */\n  threshold?: number;\n}\n\n/**\n * @internal\n * @remarks \\@since 2.8.0\n */\nexport type UpdateTooltipPosition = (container: HTMLElement) => void;\n\n/**\n * @internal\n * @remarks \\@since 2.8.0\n */\nexport type TooltipPositionHookReturnValue = [\n  SimplePosition,\n  UpdateTooltipPosition\n];\n\n/**\n * A hook that's used to determine the \"best\" position to render the tooltip\n * within the viewport.\n *\n * @internal\n * @remarks \\@since 2.8.0\n */\nexport function useTooltipPosition({\n  position: determinedPosition,\n  defaultPosition = \"below\",\n  threshold = DEFAULT_TOOLTIP_THRESHOLD,\n}: TooltipPositionHookOptions): TooltipPositionHookReturnValue {\n  const [position, setPosition] = useState(defaultPosition);\n  const updatePosition = useCallback<UpdateTooltipPosition>(\n    (container) => {\n      const { top, left } = container.getBoundingClientRect();\n      const vh = getViewportSize(\"height\");\n      const vw = getViewportSize(\"width\");\n      let nextPosition = defaultPosition;\n      if (defaultPosition === \"above\" && top < vh * threshold) {\n        nextPosition = \"below\";\n      } else if (defaultPosition === \"below\" && top > vh * threshold) {\n        nextPosition = \"above\";\n      } else if (defaultPosition === \"left\" && left < vw * threshold) {\n        nextPosition = \"right\";\n      } else if (defaultPosition === \"right\" && left > vw * threshold) {\n        nextPosition = \"left\";\n      }\n\n      setPosition(nextPosition);\n    },\n    [defaultPosition, threshold]\n  );\n\n  if (typeof determinedPosition !== \"undefined\") {\n    return [determinedPosition, noop];\n  }\n\n  return [position, updatePosition];\n}\n"]},"metadata":{},"sourceType":"module"}