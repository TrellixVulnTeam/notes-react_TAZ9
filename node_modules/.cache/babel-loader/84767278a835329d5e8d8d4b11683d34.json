{"ast":null,"code":"var __assign = this && this.__assign || function () {\n  __assign = Object.assign || function (t) {\n    for (var s, i = 1, n = arguments.length; i < n; i++) {\n      s = arguments[i];\n\n      for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p)) t[p] = s[p];\n    }\n\n    return t;\n  };\n\n  return __assign.apply(this, arguments);\n};\n\nvar __rest = this && this.__rest || function (s, e) {\n  var t = {};\n\n  for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0) t[p] = s[p];\n\n  if (s != null && typeof Object.getOwnPropertySymbols === \"function\") for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {\n    if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i])) t[p[i]] = s[p[i]];\n  }\n  return t;\n};\n\nimport { useEffect, useRef } from \"react\";\nimport { useFixedPositioning } from \"@react-md/transition\";\nimport { containsElement, useIsUserInteractionMode, useScrollLock } from \"@react-md/utils\";\nimport { useMenuBarContext } from \"./MenuBarProvider\";\nimport { getDefaultAnchor, noop } from \"./utils\";\n/**\n * This hook provides all the functionality for a menu to:\n * - toggle the `Menu`'s visibility when the `MenuButton` or `MenuItemButton`\n *   has been clicked\n * - hide the `Menu` when an element outside of the `Menu` has been clicked\n * - hide the `Menu` when the `Escape` or `Tab` key has been pressed\n * - focus the `Menu` element when it gains visibility\n * - refocus the `MenuButton` or `MenuItemButton` when the menu loses visibility\n * - position the menu within the viewport with {@link useFixedPositioning}\n * - show the `Menu` when the `ArrowRight` key is pressed for a vertical\n *   `MenuItemButton`\n * - show the `Menu` when the `ArrowDown` key is pressed for a horizontal\n *   `MenuItemButton`\n * - hide the `Menu` when the `ArrowRight` key is pressed in a vertical submenu\n * - hide the `Menu` when the `ArrowDown` key is pressed in a horizontal\n *   submenu\n * - conditionally hide the `Menu` if the page is scrolled while the `Menu` is\n *   visible\n * - conditionally hide the `Menu` if the page is resized while the `Menu` is\n *   visible\n * - conditionally move focus to the next `DropdownMenu` with keyboard movement\n *   when inside of a `MenuBar`\n * - conditionally enable the visibility for a `DropdownMenu` when the mouse\n *   hovers over a `MenuItemButton` with a parent `MenuBar` that has been\n *   activated\n * - conditionally show/hide the `Menu` based on a parent `MenuBar`'s `activeId`\n *\n * This hook will probably never need to be used externally since it has been\n * integrated into the `DropdownMenu` component and `useContextMenu` hook.\n *\n * @example\n * Simple Example\n * ```tsx\n * import { ReactElement, useState } from \"react\";\n * import { useMenu, Menu, MenuButton, MenuItem } from \"@react-md/menu\";\n *\n * function Example(): ReactElement {\n *   const [visible, setVisible] = useState(false);\n *   const { menuRef, menuProps, toggleRef, toggleProps } = useMenu<\n *     HTMLButtonElement\n *   >({\n *     baseId: \"custom-menu-button\",\n *     visible,\n *     setVisible,\n *   });\n *\n *   return (\n *     <>\n *       <MenuButton ref={toggleRef} {...toggleProps}>\n *         Button\n *       </MenuButton>\n *       <Menu ref={menuRef} {...menuProps}>\n *         <MenuItem>Item 1</MenuItem>\n *         <MenuItem>Item 2</MenuItem>\n *         <MenuItem>Item 3</MenuItem>\n *       </Menu>\n *     </>\n *   );\n * }\n * ```\n *\n * @remarks \\@since 5.0.0\n */\n\nexport function useMenu(options) {\n  var baseId = options.baseId,\n      _a = options.disabled,\n      disabled = _a === void 0 ? false : _a,\n      propStyle = options.style,\n      menuLabel = options.menuLabel,\n      visible = options.visible,\n      setVisible = options.setVisible,\n      _b = options.floating,\n      floating = _b === void 0 ? null : _b,\n      _c = options.onMenuClick,\n      onMenuClick = _c === void 0 ? noop : _c,\n      _d = options.onMenuKeyDown,\n      onMenuKeyDown = _d === void 0 ? noop : _d,\n      _e = options.onToggleClick,\n      onToggleClick = _e === void 0 ? noop : _e,\n      _f = options.onToggleKeyDown,\n      onToggleKeyDown = _f === void 0 ? noop : _f,\n      _g = options.onToggleMouseEnter,\n      onToggleMouseEnter = _g === void 0 ? noop : _g,\n      _h = options.onToggleMouseLeave,\n      onToggleMouseLeave = _h === void 0 ? noop : _h,\n      _j = options.menuitem,\n      menuitem = _j === void 0 ? false : _j,\n      _k = options.horizontal,\n      horizontal = _k === void 0 ? false : _k,\n      propAnchor = options.anchor,\n      fixedPositionOptions = options.fixedPositionOptions,\n      getFixedPositionOptions = options.getFixedPositionOptions,\n      _l = options.closeOnResize,\n      closeOnResize = _l === void 0 ? false : _l,\n      _m = options.closeOnScroll,\n      closeOnScroll = _m === void 0 ? false : _m,\n      onEnter = options.onEnter,\n      onEntering = options.onEntering,\n      _o = options.onEntered,\n      onEntered = _o === void 0 ? noop : _o,\n      _p = options.onExited,\n      onExited = _p === void 0 ? noop : _p,\n      _q = options.onFixedPositionScroll,\n      onFixedPositionScroll = _q === void 0 ? noop : _q,\n      _r = options.onFixedPositionResize,\n      onFixedPositionResize = _r === void 0 ? noop : _r,\n      _s = options.preventScroll,\n      preventScroll = _s === void 0 ? false : _s,\n      _t = options.disableFocusOnMount,\n      disableFocusOnMount = _t === void 0 ? false : _t,\n      _u = options.disableFocusOnUnmount,\n      disableFocusOnUnmount = _u === void 0 ? false : _u;\n\n  var _v = useMenuBarContext(),\n      root = _v.root,\n      menubar = _v.menubar,\n      activeId = _v.activeId,\n      setActiveId = _v.setActiveId,\n      hoverTimeout = _v.hoverTimeout,\n      setAnimatedOnce = _v.setAnimatedOnce;\n\n  var touch = useIsUserInteractionMode(\"touch\");\n  var timeout = useRef();\n  useEffect(function () {\n    return function () {\n      window.clearTimeout(timeout.current);\n    };\n  }, []); // if the menu hides because the user scrolls the page or the page is resized,\n  // the focus toggle behavior should be disabled since the user is no longer\n  // interacting with the menu\n\n  var cancelExitFocus = useRef(false);\n  var anchor = propAnchor !== null && propAnchor !== void 0 ? propAnchor : getDefaultAnchor({\n    menubar: menubar,\n    menuitem: menuitem,\n    floating: floating,\n    horizontal: horizontal\n  });\n  var menuNodeRef = useRef(null);\n  var toggleRef = useRef(null);\n\n  var _w = useFixedPositioning(__assign(__assign({\n    nodeRef: menuNodeRef,\n    style: propStyle,\n    fixedTo: toggleRef,\n    onEnter: onEnter,\n    onEntering: onEntering,\n    onEntered: function (appearing) {\n      var _a;\n\n      cancelExitFocus.current = false;\n      onEntered(appearing);\n      setAnimatedOnce(true);\n\n      if (!disableFocusOnMount) {\n        (_a = menuNodeRef.current) === null || _a === void 0 ? void 0 : _a.focus();\n      }\n    },\n    onExited: function () {\n      var _a;\n\n      onExited(); // this has to be done onExited or else the toggle component will be\n      // clicked if the user pressed the \"Enter\" key which makes it look like\n      // the menu never closes.\n\n      if (!disableFocusOnUnmount && !cancelExitFocus.current) {\n        (_a = toggleRef.current) === null || _a === void 0 ? void 0 : _a.focus();\n      }\n    },\n    anchor: anchor,\n    transformOrigin: true\n  }, fixedPositionOptions), {\n    getFixedPositionOptions: getFixedPositionOptions,\n    onScroll: function (event, data) {\n      onFixedPositionScroll(event, data);\n\n      if (!data.visible || closeOnScroll) {\n        cancelExitFocus.current = true;\n        setVisible(false);\n      }\n    },\n    onResize: function (event) {\n      onFixedPositionResize(event);\n\n      if (closeOnResize) {\n        cancelExitFocus.current = true;\n        setVisible(false);\n      }\n    }\n  })),\n      style = _w.style,\n      _x = _w.transitionOptions,\n      nodeRef = _x.nodeRef,\n      transitionOptions = __rest(_x, [\"nodeRef\"]);\n\n  useScrollLock(preventScroll && visible);\n  useEffect(function () {\n    if (!visible) {\n      return;\n    }\n\n    var handler = function (_a) {\n      var _b, _c;\n\n      var target = _a.target;\n\n      if (!(target instanceof Element) || !((_b = menuNodeRef.current) === null || _b === void 0 ? void 0 : _b.contains(target)) && !((_c = toggleRef.current) === null || _c === void 0 ? void 0 : _c.contains(target))) {\n        setVisible(false);\n      }\n    };\n\n    window.addEventListener(\"click\", handler);\n    return function () {\n      window.removeEventListener(\"click\", handler);\n    };\n  }, [menuNodeRef, setVisible, toggleRef, visible]);\n  useEffect(function () {\n    var _a;\n\n    if (visible) {\n      return;\n    } // this is to fix keyboard movement behavior when navigating between\n    // different root-level menuitems with the `ArrowLeft` and `ArrowRight` keys\n    // while menus are visible. If the exit focus behavior is not cancelled, the\n    // next menu's menu will be visible, but the current menu's menuitem would\n    // be the current focus which breaks everything\n\n\n    cancelExitFocus.current = cancelExitFocus.current || !((_a = menuNodeRef.current) === null || _a === void 0 ? void 0 : _a.contains(document.activeElement));\n    setActiveId(function (prevActiveId) {\n      return baseId === prevActiveId ? \"\" : prevActiveId;\n    });\n  }, [baseId, root, setActiveId, visible]);\n  useEffect(function () {\n    setVisible(baseId === activeId);\n  }, [activeId, baseId, root, setVisible]);\n  return {\n    menuRef: nodeRef,\n    menuProps: __assign(__assign({\n      // typecast to string so that it passes the RequireAtLeastOne<LabelA11y>\n      // TS won't pass otherwise\n      \"aria-label\": menuLabel,\n      \"aria-labelledby\": menuLabel ? undefined : baseId,\n      id: \"\".concat(baseId, \"-menu\"),\n      style: style\n    }, transitionOptions), {\n      visible: visible,\n      onClick: function (event) {\n        onMenuClick(event);\n\n        if (event.isPropagationStopped()) {\n          return;\n        } // this makes it so you can click on the menu/list without closing the\n        // menu\n\n\n        if (event.currentTarget === event.target) {\n          return;\n        } // This might be a test only workaround since clicking links move focus\n        // somewhere else\n\n\n        if (event.target instanceof HTMLElement) {\n          cancelExitFocus.current = containsElement(event.currentTarget, event.target.closest(\"a\"));\n        }\n\n        setVisible(false);\n      },\n      onKeyDown: function (event) {\n        onMenuKeyDown(event);\n\n        if (event.isPropagationStopped()) {\n          return;\n        }\n\n        switch (event.key) {\n          case \"Escape\":\n            // prevent parent components that have an \"Escape\" keypress event\n            // from being triggered as well\n            event.stopPropagation();\n            setVisible(false);\n            break;\n\n          case \"Tab\":\n            // since menus are portalled, tab index is kinda broke so just close\n            // the menu instead of doing default tab behavior\n            event.preventDefault();\n\n            if (!menuitem) {\n              // pressing the tab key should still cascade close all menus\n              event.stopPropagation();\n            }\n\n            setVisible(false);\n            break;\n\n          case \"ArrowUp\":\n            if (menuitem && horizontal) {\n              event.stopPropagation();\n              event.preventDefault();\n              setVisible(false);\n            }\n\n            break;\n\n          case \"ArrowLeft\":\n            if (menuitem && !horizontal) {\n              event.stopPropagation();\n              event.preventDefault();\n              setVisible(false);\n            }\n\n            break;\n        }\n      }\n    }),\n    menuNodeRef: menuNodeRef,\n    toggleRef: toggleRef,\n    toggleProps: {\n      \"aria-haspopup\": \"menu\",\n      \"aria-expanded\": visible || undefined,\n      id: baseId,\n      onClick: function (event) {\n        onToggleClick(event);\n\n        if (event.isPropagationStopped()) {\n          return;\n        }\n\n        if (menuitem || menubar) {\n          // do not allow the default menu close behavior from\n          // triggering for parent menus\n          event.stopPropagation();\n        }\n\n        setVisible(function (prevVisible) {\n          return !prevVisible;\n        });\n        setActiveId(function (prevActiveId) {\n          return baseId === prevActiveId ? \"\" : baseId;\n        });\n      },\n      onKeyDown: function (event) {\n        onToggleKeyDown(event);\n\n        if (event.isPropagationStopped() || disabled) {\n          return;\n        }\n\n        if (menubar && !menuitem && event.key === \"ArrowDown\") {\n          event.preventDefault();\n          event.stopPropagation();\n          setActiveId(baseId);\n          return;\n        }\n\n        if (!menuitem) {\n          return;\n        }\n\n        switch (event.key) {\n          case \"ArrowDown\":\n            if (horizontal) {\n              event.stopPropagation();\n              event.preventDefault();\n              setVisible(true);\n            }\n\n            break;\n\n          case \"ArrowRight\":\n            if (!horizontal) {\n              event.stopPropagation();\n              event.preventDefault();\n              setVisible(true);\n            }\n\n            break;\n        }\n      },\n      onMouseEnter: function (event) {\n        onToggleMouseEnter(event);\n\n        if (event.isPropagationStopped() || disabled || !menubar || !activeId || touch) {\n          if (typeof hoverTimeout === \"number\") {\n            timeout.current = window.setTimeout(function () {\n              setActiveId(baseId);\n            }, hoverTimeout);\n          }\n\n          return;\n        }\n\n        setActiveId(baseId);\n      },\n      onMouseLeave: function (event) {\n        onToggleMouseLeave(event);\n        window.clearTimeout(timeout.current);\n      }\n    }\n  };\n}","map":{"version":3,"mappings":"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","names":["useEffect","useRef","useFixedPositioning","containsElement","useIsUserInteractionMode","useScrollLock","useMenuBarContext","getDefaultAnchor","noop","useMenu","options","_a","disabled","propStyle","menuLabel","visible","setVisible","_b","floating","_c","onMenuClick","_d","onMenuKeyDown","_e","onToggleClick","_f","onToggleKeyDown","_g","onToggleMouseEnter","_h","onToggleMouseLeave","_j","menuitem","_k","horizontal","propAnchor","fixedPositionOptions","getFixedPositionOptions","_l","closeOnResize","_m","closeOnScroll","onEnter","onEntering","_o","onEntered","_p","onExited","_q","onFixedPositionScroll","_r","onFixedPositionResize","_s","preventScroll","_t","disableFocusOnMount","_u","disableFocusOnUnmount","root","menubar","activeId","setActiveId","hoverTimeout","setAnimatedOnce","touch","timeout","window","clearTimeout","current","cancelExitFocus","anchor","menuNodeRef","toggleRef","_w","nodeRef","style","fixedTo","appearing","focus","transformOrigin","onScroll","event","data","onResize","_x","transitionOptions","handler","target","Element","contains","addEventListener","removeEventListener","document","activeElement","prevActiveId","baseId","menuRef","menuProps","undefined","id","onClick","isPropagationStopped","currentTarget","HTMLElement","closest","onKeyDown","key","stopPropagation","preventDefault","toggleProps","prevVisible","onMouseEnter","setTimeout","onMouseLeave"],"sources":["C:\\Users\\hungr\\Documents\\VS-CODE\\notes-react\\node_modules\\@react-md\\menu\\src\\useMenu.ts"],"sourcesContent":["import type {\n  KeyboardEventHandler,\n  MouseEventHandler,\n  MutableRefObject,\n} from \"react\";\nimport { useEffect, useRef } from \"react\";\nimport type { FABPosition } from \"@react-md/button\";\nimport { useFixedPositioning } from \"@react-md/transition\";\nimport {\n  containsElement,\n  useIsUserInteractionMode,\n  useScrollLock,\n} from \"@react-md/utils\";\n\nimport { useMenuBarContext } from \"./MenuBarProvider\";\nimport type {\n  BaseMenuHookOptions,\n  BaseMenuHookReturnValue,\n  ProvidedMenuToggleProps,\n} from \"./types\";\nimport { getDefaultAnchor, noop } from \"./utils\";\n\n/** @remarks \\@since 5.0.0 */\nexport interface MenuHookOptions<ToggleEl extends HTMLElement>\n  extends BaseMenuHookOptions {\n  /**\n   * Boolean if the toggle component is currently disabled which will prevent\n   * the arrow keys from opening a menuitem's menu.\n   *\n   * @defaultValue `false`\n   */\n  disabled?: boolean;\n\n  /**\n   * This is just used to update the default anchor behavior.\n   *\n   * @see {@link FABPosition}\n   * @defaultValue `null`\n   */\n  floating?: FABPosition;\n\n  /**\n   * An optional click handler to merge with the\n   * {@link MenuHookReturnValue.onClick} behavior.\n   */\n  onMenuClick?: MouseEventHandler<HTMLDivElement>;\n\n  /**\n   * An optional keydown handler to merge with the\n   * {@link MenuHookReturnValue.menuProps} behavior. Calling\n   * `event.stopPropagation()` will prevent the default behavior of closing the\n   * menu when the `\"Escape\"` key is pressed.\n   */\n  onMenuKeyDown?: KeyboardEventHandler<HTMLDivElement>;\n\n  /**\n   * An optional click handler to merge with the toggle visibility behavior.\n   * Calling `event.stopPropagation()` will prevent the default behavior from\n   * occurring.\n   */\n  onToggleClick?: MouseEventHandler<ToggleEl>;\n\n  /**\n   * An optional keydown handler to merge with the\n   * {@link ProvidedMenuToggleProps.onKeyDown} behavior.\n   */\n  onToggleKeyDown?: KeyboardEventHandler<ToggleEl>;\n\n  /**\n   * An optional keydown handler to merge with the\n   * {@link ProvidedMenuToggleProps.onMouseEnter} behavior.\n   */\n  onToggleMouseEnter?: MouseEventHandler<ToggleEl>;\n\n  /**\n   * An optional keydown handler to merge with the\n   * {@link ProvidedMenuToggleProps.onMouseLeave} behavior.\n   */\n  onToggleMouseLeave?: MouseEventHandler<ToggleEl>;\n}\n\n/**\n * @remarks \\@since 5.0.0\n */\nexport interface MenuHookReturnValue<ToggleEl extends HTMLElement>\n  extends BaseMenuHookReturnValue {\n  /**\n   * A ref that **must** be passed to the toggle element if the toggle should be\n   * refocused when the menu is closed via a keyboard press. This can also be\n   * used if you need access to the toggle element's DOM node for some reason.\n   */\n  toggleRef: MutableRefObject<ToggleEl | null>;\n\n  /**\n   * An object of props that must be provided to the toggle element for the\n   * visibility functionality of menus to work.\n   *\n   * @see {@link ProvidedMenuToggleProps}\n   */\n  toggleProps: ProvidedMenuToggleProps<ToggleEl>;\n}\n\n/**\n * This hook provides all the functionality for a menu to:\n * - toggle the `Menu`'s visibility when the `MenuButton` or `MenuItemButton`\n *   has been clicked\n * - hide the `Menu` when an element outside of the `Menu` has been clicked\n * - hide the `Menu` when the `Escape` or `Tab` key has been pressed\n * - focus the `Menu` element when it gains visibility\n * - refocus the `MenuButton` or `MenuItemButton` when the menu loses visibility\n * - position the menu within the viewport with {@link useFixedPositioning}\n * - show the `Menu` when the `ArrowRight` key is pressed for a vertical\n *   `MenuItemButton`\n * - show the `Menu` when the `ArrowDown` key is pressed for a horizontal\n *   `MenuItemButton`\n * - hide the `Menu` when the `ArrowRight` key is pressed in a vertical submenu\n * - hide the `Menu` when the `ArrowDown` key is pressed in a horizontal\n *   submenu\n * - conditionally hide the `Menu` if the page is scrolled while the `Menu` is\n *   visible\n * - conditionally hide the `Menu` if the page is resized while the `Menu` is\n *   visible\n * - conditionally move focus to the next `DropdownMenu` with keyboard movement\n *   when inside of a `MenuBar`\n * - conditionally enable the visibility for a `DropdownMenu` when the mouse\n *   hovers over a `MenuItemButton` with a parent `MenuBar` that has been\n *   activated\n * - conditionally show/hide the `Menu` based on a parent `MenuBar`'s `activeId`\n *\n * This hook will probably never need to be used externally since it has been\n * integrated into the `DropdownMenu` component and `useContextMenu` hook.\n *\n * @example\n * Simple Example\n * ```tsx\n * import { ReactElement, useState } from \"react\";\n * import { useMenu, Menu, MenuButton, MenuItem } from \"@react-md/menu\";\n *\n * function Example(): ReactElement {\n *   const [visible, setVisible] = useState(false);\n *   const { menuRef, menuProps, toggleRef, toggleProps } = useMenu<\n *     HTMLButtonElement\n *   >({\n *     baseId: \"custom-menu-button\",\n *     visible,\n *     setVisible,\n *   });\n *\n *   return (\n *     <>\n *       <MenuButton ref={toggleRef} {...toggleProps}>\n *         Button\n *       </MenuButton>\n *       <Menu ref={menuRef} {...menuProps}>\n *         <MenuItem>Item 1</MenuItem>\n *         <MenuItem>Item 2</MenuItem>\n *         <MenuItem>Item 3</MenuItem>\n *       </Menu>\n *     </>\n *   );\n * }\n * ```\n *\n * @remarks \\@since 5.0.0\n */\nexport function useMenu<ToggleEl extends HTMLElement>(\n  options: MenuHookOptions<ToggleEl>\n): MenuHookReturnValue<ToggleEl> {\n  const {\n    baseId,\n    disabled = false,\n    style: propStyle,\n    menuLabel,\n    visible,\n    setVisible,\n    floating = null,\n    onMenuClick = noop,\n    onMenuKeyDown = noop,\n    onToggleClick = noop,\n    onToggleKeyDown = noop,\n    onToggleMouseEnter = noop,\n    onToggleMouseLeave = noop,\n    menuitem = false,\n    horizontal = false,\n    anchor: propAnchor,\n    fixedPositionOptions,\n    getFixedPositionOptions,\n    closeOnResize = false,\n    closeOnScroll = false,\n    onEnter,\n    onEntering,\n    onEntered = noop,\n    onExited = noop,\n    onFixedPositionScroll = noop,\n    onFixedPositionResize = noop,\n    preventScroll = false,\n    disableFocusOnMount = false,\n    disableFocusOnUnmount = false,\n  } = options;\n  const {\n    root,\n    menubar,\n    activeId,\n    setActiveId,\n    hoverTimeout,\n    setAnimatedOnce,\n  } = useMenuBarContext();\n  const touch = useIsUserInteractionMode(\"touch\");\n\n  const timeout = useRef<number | undefined>();\n  useEffect(() => {\n    return () => {\n      window.clearTimeout(timeout.current);\n    };\n  }, []);\n\n  // if the menu hides because the user scrolls the page or the page is resized,\n  // the focus toggle behavior should be disabled since the user is no longer\n  // interacting with the menu\n  const cancelExitFocus = useRef(false);\n  const anchor =\n    propAnchor ?? getDefaultAnchor({ menubar, menuitem, floating, horizontal });\n  const menuNodeRef = useRef<HTMLDivElement>(null);\n  const toggleRef = useRef<ToggleEl | null>(null);\n  const {\n    style,\n    transitionOptions: { nodeRef, ...transitionOptions },\n  } = useFixedPositioning({\n    nodeRef: menuNodeRef,\n    style: propStyle,\n    fixedTo: toggleRef,\n    onEnter,\n    onEntering,\n    onEntered(appearing) {\n      cancelExitFocus.current = false;\n      onEntered(appearing);\n      setAnimatedOnce(true);\n      if (!disableFocusOnMount) {\n        menuNodeRef.current?.focus();\n      }\n    },\n    onExited() {\n      onExited();\n\n      // this has to be done onExited or else the toggle component will be\n      // clicked if the user pressed the \"Enter\" key which makes it look like\n      // the menu never closes.\n      if (!disableFocusOnUnmount && !cancelExitFocus.current) {\n        toggleRef.current?.focus();\n      }\n    },\n    anchor,\n    transformOrigin: true,\n    ...fixedPositionOptions,\n    getFixedPositionOptions,\n    onScroll(event, data) {\n      onFixedPositionScroll(event, data);\n      if (!data.visible || closeOnScroll) {\n        cancelExitFocus.current = true;\n        setVisible(false);\n      }\n    },\n    onResize(event) {\n      onFixedPositionResize(event);\n      if (closeOnResize) {\n        cancelExitFocus.current = true;\n        setVisible(false);\n      }\n    },\n  });\n  useScrollLock(preventScroll && visible);\n\n  useEffect(() => {\n    if (!visible) {\n      return;\n    }\n\n    const handler = ({ target }: MouseEvent): void => {\n      if (\n        !(target instanceof Element) ||\n        (!menuNodeRef.current?.contains(target) &&\n          !toggleRef.current?.contains(target))\n      ) {\n        setVisible(false);\n      }\n    };\n\n    window.addEventListener(\"click\", handler);\n    return () => {\n      window.removeEventListener(\"click\", handler);\n    };\n  }, [menuNodeRef, setVisible, toggleRef, visible]);\n  useEffect(() => {\n    if (visible) {\n      return;\n    }\n\n    // this is to fix keyboard movement behavior when navigating between\n    // different root-level menuitems with the `ArrowLeft` and `ArrowRight` keys\n    // while menus are visible. If the exit focus behavior is not cancelled, the\n    // next menu's menu will be visible, but the current menu's menuitem would\n    // be the current focus which breaks everything\n    cancelExitFocus.current =\n      cancelExitFocus.current ||\n      !menuNodeRef.current?.contains(document.activeElement);\n\n    setActiveId((prevActiveId) =>\n      baseId === prevActiveId ? \"\" : prevActiveId\n    );\n  }, [baseId, root, setActiveId, visible]);\n  useEffect(() => {\n    setVisible(baseId === activeId);\n  }, [activeId, baseId, root, setVisible]);\n\n  return {\n    menuRef: nodeRef,\n    menuProps: {\n      // typecast to string so that it passes the RequireAtLeastOne<LabelA11y>\n      // TS won't pass otherwise\n      \"aria-label\": menuLabel as string,\n      \"aria-labelledby\": menuLabel ? undefined : baseId,\n      id: `${baseId}-menu`,\n      style,\n      ...transitionOptions,\n      visible,\n      onClick(event) {\n        onMenuClick(event);\n        if (event.isPropagationStopped()) {\n          return;\n        }\n\n        // this makes it so you can click on the menu/list without closing the\n        // menu\n        if (event.currentTarget === event.target) {\n          return;\n        }\n\n        // This might be a test only workaround since clicking links move focus\n        // somewhere else\n        if (event.target instanceof HTMLElement) {\n          cancelExitFocus.current = containsElement(\n            event.currentTarget,\n            event.target.closest(\"a\")\n          );\n        }\n        setVisible(false);\n      },\n      onKeyDown(event) {\n        onMenuKeyDown(event);\n        if (event.isPropagationStopped()) {\n          return;\n        }\n\n        switch (event.key) {\n          case \"Escape\":\n            // prevent parent components that have an \"Escape\" keypress event\n            // from being triggered as well\n            event.stopPropagation();\n            setVisible(false);\n            break;\n          case \"Tab\":\n            // since menus are portalled, tab index is kinda broke so just close\n            // the menu instead of doing default tab behavior\n            event.preventDefault();\n            if (!menuitem) {\n              // pressing the tab key should still cascade close all menus\n              event.stopPropagation();\n            }\n            setVisible(false);\n            break;\n          case \"ArrowUp\":\n            if (menuitem && horizontal) {\n              event.stopPropagation();\n              event.preventDefault();\n              setVisible(false);\n            }\n            break;\n          case \"ArrowLeft\":\n            if (menuitem && !horizontal) {\n              event.stopPropagation();\n              event.preventDefault();\n              setVisible(false);\n            }\n            break;\n        }\n      },\n    },\n    menuNodeRef,\n    toggleRef,\n    toggleProps: {\n      \"aria-haspopup\": \"menu\",\n      \"aria-expanded\": visible || undefined,\n      id: baseId,\n      onClick(event) {\n        onToggleClick(event);\n        if (event.isPropagationStopped()) {\n          return;\n        }\n\n        if (menuitem || menubar) {\n          // do not allow the default menu close behavior from\n          // triggering for parent menus\n          event.stopPropagation();\n        }\n\n        setVisible((prevVisible) => !prevVisible);\n        setActiveId((prevActiveId) => (baseId === prevActiveId ? \"\" : baseId));\n      },\n      onKeyDown(event) {\n        onToggleKeyDown(event);\n        if (event.isPropagationStopped() || disabled) {\n          return;\n        }\n\n        if (menubar && !menuitem && event.key === \"ArrowDown\") {\n          event.preventDefault();\n          event.stopPropagation();\n          setActiveId(baseId);\n          return;\n        }\n\n        if (!menuitem) {\n          return;\n        }\n\n        switch (event.key) {\n          case \"ArrowDown\":\n            if (horizontal) {\n              event.stopPropagation();\n              event.preventDefault();\n              setVisible(true);\n            }\n            break;\n          case \"ArrowRight\":\n            if (!horizontal) {\n              event.stopPropagation();\n              event.preventDefault();\n              setVisible(true);\n            }\n            break;\n        }\n      },\n      onMouseEnter(event) {\n        onToggleMouseEnter(event);\n        if (\n          event.isPropagationStopped() ||\n          disabled ||\n          !menubar ||\n          !activeId ||\n          touch\n        ) {\n          if (typeof hoverTimeout === \"number\") {\n            timeout.current = window.setTimeout(() => {\n              setActiveId(baseId);\n            }, hoverTimeout);\n          }\n          return;\n        }\n\n        setActiveId(baseId);\n      },\n      onMouseLeave(event) {\n        onToggleMouseLeave(event);\n        window.clearTimeout(timeout.current);\n      },\n    },\n  };\n}\n"]},"metadata":{},"sourceType":"module"}