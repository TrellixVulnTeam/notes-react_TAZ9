{"ast":null,"code":"var __read = this && this.__read || function (o, n) {\n  var m = typeof Symbol === \"function\" && o[Symbol.iterator];\n  if (!m) return o;\n  var i = m.call(o),\n      r,\n      ar = [],\n      e;\n\n  try {\n    while ((n === void 0 || n-- > 0) && !(r = i.next()).done) ar.push(r.value);\n  } catch (error) {\n    e = {\n      error: error\n    };\n  } finally {\n    try {\n      if (r && !r.done && (m = i[\"return\"])) m.call(i);\n    } finally {\n      if (e) throw e.error;\n    }\n  }\n\n  return ar;\n};\n\nimport { useCallback, useMemo } from \"react\";\nimport { useTempValue } from \"../useTempValue\";\nimport { findMatchIndex as DEFAULT_FIND_MATCH_INDEX } from \"./findMatchIndex\";\nimport { DEFAULT_GET_ITEM_VALUE, DEFAULT_SEARCH_RESET_TIME, DEFAULT_VALUE_KEY } from \"./utils\";\n/**\n * Adds the accessibility functionality to search a list of items as the user\n * types to trigger `aria-activedescendant` focus or manual DOM focus events.\n */\n\nexport function useKeyboardSearch(_a) {\n  var items = _a.items,\n      onChange = _a.onChange,\n      onKeyDown = _a.onKeyDown,\n      _b = _a.resetTime,\n      resetTime = _b === void 0 ? DEFAULT_SEARCH_RESET_TIME : _b,\n      searchIndex = _a.searchIndex,\n      _c = _a.valueKey,\n      valueKey = _c === void 0 ? DEFAULT_VALUE_KEY : _c,\n      _d = _a.getItemValue,\n      getItemValue = _d === void 0 ? DEFAULT_GET_ITEM_VALUE : _d,\n      _e = _a.findMatchIndex,\n      findMatchIndex = _e === void 0 ? DEFAULT_FIND_MATCH_INDEX : _e;\n\n  var _f = __read(useTempValue(\"\", resetTime), 2),\n      value = _f[0],\n      setValue = _f[1];\n\n  var values = useMemo(function () {\n    return items.map(function (item) {\n      return getItemValue(item, valueKey);\n    });\n  }, [items, getItemValue, valueKey]);\n  var handleKeyDown = useCallback(function (event) {\n    if (onKeyDown) {\n      onKeyDown(event);\n    }\n\n    var key = event.key,\n        altKey = event.altKey,\n        ctrlKey = event.ctrlKey,\n        metaKey = event.metaKey;\n\n    if (altKey || ctrlKey || metaKey || key.length > 1 || !value.current && key === \" \") {\n      // might need to change this later if other languages have non-meta keys\n      // that are more than 1 letter\n      return;\n    }\n\n    var nextValue = key;\n\n    if (value.current !== key) {\n      nextValue = \"\".concat(value.current).concat(key);\n    }\n\n    setValue(nextValue);\n    var index = findMatchIndex(nextValue, values, searchIndex, true); // don't want to trigger change events if the search didn't match anything\n    // since you normally don't really care about failed matches\n\n    if (index === searchIndex || index === -1) {\n      return;\n    }\n\n    var data = {\n      index: index,\n      item: items[index],\n      items: items,\n      query: nextValue,\n      target: event.currentTarget\n    };\n    onChange(data);\n  }, [searchIndex, findMatchIndex, items, onChange, onKeyDown, setValue, value, values]);\n  return handleKeyDown;\n}","map":{"version":3,"mappings":";;;;;;;;;;;;;;;;;;;;;;;;;AAAA,SAASA,WAAT,EAAsBC,OAAtB,QAAqC,OAArC;AAEA,SAASC,YAAT,QAA6B,iBAA7B;AAEA,SAASC,cAAc,IAAIC,wBAA3B,QAA2D,kBAA3D;AAEA,SACEC,sBADF,EAEEC,yBAFF,EAGEC,iBAHF,QAIO,SAJP;AAoGA;;;;;AAIA,OAAM,SAAUC,iBAAV,CAGJC,EAHI,EAYwB;MAR5BC,KAAK;MACLC,QAAQ;MACRC,SAAS;MACTC;MAAAC,SAAS,mBAAGR,yBAAH,GAA4BO;MACrCE,WAAW;MACXC;MAAAC,QAAQ,mBAAGV,iBAAH,GAAoBS;MAC5BE;MAAAC,YAAY,mBAAGd,sBAAH,GAAyBa;MACrCE;MAAAjB,cAAc,mBAAGC,wBAAH,GAA2BgB;;EAEnC,gBAAoBlB,YAAY,CAAC,EAAD,EAAKY,SAAL,CAAhC,EAA+C,CAA/C;EAAA,IAACO,KAAK,QAAN;EAAA,IAAQC,QAAQ,QAAhB;;EACN,IAAMC,MAAM,GAAGtB,OAAO,CACpB;IAAM,YAAK,CAACuB,GAAN,CAAU,UAACC,IAAD,EAAK;MAAK,mBAAY,CAACA,IAAD,EAAOR,QAAP,CAAZ;IAA4B,CAAhD;EAAiD,CADnC,EAEpB,CAACP,KAAD,EAAQS,YAAR,EAAsBF,QAAtB,CAFoB,CAAtB;EAKA,IAAMS,aAAa,GAAG1B,WAAW,CAC/B,UAAC2B,KAAD,EAAM;IACJ,IAAIf,SAAJ,EAAe;MACbA,SAAS,CAACe,KAAD,CAAT;IACD;;IAEO,OAAG,GAA+BA,KAAK,IAAvC;IAAA,IAAKC,MAAM,GAAuBD,KAAK,OAAvC;IAAA,IAAaE,OAAO,GAAcF,KAAK,QAAvC;IAAA,IAAsBG,OAAO,GAAKH,KAAK,QAAvC;;IACR,IACEC,MAAM,IACNC,OADA,IAEAC,OAFA,IAGAC,GAAG,CAACC,MAAJ,GAAa,CAHb,IAIC,CAACX,KAAK,CAACY,OAAP,IAAkBF,GAAG,KAAK,GAL7B,EAME;MACA;MACA;MACA;IACD;;IAED,IAAIG,SAAS,GAAGH,GAAhB;;IACA,IAAIV,KAAK,CAACY,OAAN,KAAkBF,GAAtB,EAA2B;MACzBG,SAAS,GAAG,UAAGb,KAAK,CAACY,OAAT,EAAgBE,MAAhB,CAAmBJ,GAAnB,CAAZ;IACD;;IACDT,QAAQ,CAACY,SAAD,CAAR;IAEA,IAAME,KAAK,GAAGjC,cAAc,CAAC+B,SAAD,EAAYX,MAAZ,EAAoBR,WAApB,EAAiC,IAAjC,CAA5B,CAxBI,CAyBJ;IACA;;IACA,IAAIqB,KAAK,KAAKrB,WAAV,IAAyBqB,KAAK,KAAK,CAAC,CAAxC,EAA2C;MACzC;IACD;;IAED,IAAMC,IAAI,GAAqB;MAC7BD,KAAK,OADwB;MAE7BX,IAAI,EAAEf,KAAK,CAAC0B,KAAD,CAFkB;MAG7B1B,KAAK,OAHwB;MAI7B4B,KAAK,EAAEJ,SAJsB;MAK7BK,MAAM,EAAEZ,KAAK,CAACa;IALe,CAA/B;IAQA7B,QAAQ,CAAC0B,IAAD,CAAR;EACD,CAzC8B,EA0C/B,CACEtB,WADF,EAEEZ,cAFF,EAGEO,KAHF,EAIEC,QAJF,EAKEC,SALF,EAMEU,QANF,EAOED,KAPF,EAQEE,MARF,CA1C+B,CAAjC;EAsDA,OAAOG,aAAP;AACD","names":["useCallback","useMemo","useTempValue","findMatchIndex","DEFAULT_FIND_MATCH_INDEX","DEFAULT_GET_ITEM_VALUE","DEFAULT_SEARCH_RESET_TIME","DEFAULT_VALUE_KEY","useKeyboardSearch","_a","items","onChange","onKeyDown","_b","resetTime","searchIndex","_c","valueKey","_d","getItemValue","_e","value","setValue","values","map","item","handleKeyDown","event","altKey","ctrlKey","metaKey","key","length","current","nextValue","concat","index","data","query","target","currentTarget"],"sources":["C:\\Users\\hungr\\Documents\\VS-CODE\\notes-react\\node_modules\\@react-md\\utils\\src\\search\\useKeyboardSearch.ts"],"sourcesContent":["import { useCallback, useMemo } from \"react\";\n\nimport { useTempValue } from \"../useTempValue\";\nimport type { FindMatchIndex } from \"./findMatchIndex\";\nimport { findMatchIndex as DEFAULT_FIND_MATCH_INDEX } from \"./findMatchIndex\";\nimport type { BaseSearchOptions } from \"./utils\";\nimport {\n  DEFAULT_GET_ITEM_VALUE,\n  DEFAULT_SEARCH_RESET_TIME,\n  DEFAULT_VALUE_KEY,\n} from \"./utils\";\n\n/**\n * The data that is provided to the `onChange` handler when searching. This will\n * be triggered whenever the user types a letter that causes the current search\n * result to change.\n */\nexport interface SearchData<D = unknown, E extends HTMLElement = HTMLElement> {\n  /**\n   * The item that was matched from the latest search.\n   */\n  readonly item: D;\n\n  /**\n   * The current list of items that were provided to be searched.\n   */\n  readonly items: readonly D[];\n\n  /**\n   * The index in the `items` array that the found item appears at. This is\n   * super useful when extending this hook to be used with\n   * `aria-activedescendant` focus movement or manual focus behavior since the\n   * `items` array should normally be the same indexes as the DOM nodes.\n   */\n  readonly index: number;\n\n  /**\n   * The search value that was used to find this item and trigger the change\n   * event.\n   */\n  readonly query: string;\n\n  /**\n   * The current target for the search keydown event.\n   */\n  readonly target: E;\n}\n\nexport type SearchChangeEvent<\n  D = unknown,\n  E extends HTMLElement = HTMLElement\n> = (data: SearchData<D, E>) => void;\n\nexport interface BaseKeyboardSearchOptions<\n  D = unknown,\n  E extends HTMLElement = HTMLElement\n> extends BaseSearchOptions<D> {\n  /**\n   * The list of items that should be searched whenever the user types a letter.\n   */\n  items: readonly D[];\n\n  /**\n   * A required change event handler that will be called whenever a user types a\n   * letter and it causes a new item to be \"found\". This should normally be\n   * something that either updates the `aria-activedescendant` id to the new\n   * found item's id or manually focus the item's DOM node.\n   */\n  onChange: SearchChangeEvent<D, E>;\n\n  /**\n   * An optional `onKeyDown` event handler that should be merged with the search\n   * functionality.\n   *\n   * Note: This will be called **before** the search functionality is triggered.\n   */\n  onKeyDown?: React.KeyboardEventHandler<E>;\n\n  /**\n   * The amount of time that a \"search\" value should be kept before resetting.\n   * The default value works for most cases, but it might be nice to configure\n   * it based on your use case.\n   */\n  resetTime?: number;\n\n  /**\n   * The function used to find a match index within the `items` list. You most\n   * likely won't want to change this.\n   */\n  findMatchIndex?: FindMatchIndex;\n}\n\nexport interface KeyboardSearchOptions<\n  D = unknown,\n  E extends HTMLElement = HTMLElement\n> extends BaseKeyboardSearchOptions<D, E> {\n  /**\n   * The current index that should be \"focused\" due to a keyboard search. This\n   * should be updated whenever the `onChange` callback is fired.\n   */\n  searchIndex: number;\n}\n\ntype ReturnValue<E extends HTMLElement = HTMLElement> =\n  React.KeyboardEventHandler<E>;\n\n/**\n * Adds the accessibility functionality to search a list of items as the user\n * types to trigger `aria-activedescendant` focus or manual DOM focus events.\n */\nexport function useKeyboardSearch<\n  D = unknown,\n  E extends HTMLElement = HTMLElement\n>({\n  items,\n  onChange,\n  onKeyDown,\n  resetTime = DEFAULT_SEARCH_RESET_TIME,\n  searchIndex,\n  valueKey = DEFAULT_VALUE_KEY,\n  getItemValue = DEFAULT_GET_ITEM_VALUE,\n  findMatchIndex = DEFAULT_FIND_MATCH_INDEX,\n}: KeyboardSearchOptions<D, E>): ReturnValue<E> {\n  const [value, setValue] = useTempValue(\"\", resetTime);\n  const values = useMemo(\n    () => items.map((item) => getItemValue(item, valueKey)),\n    [items, getItemValue, valueKey]\n  );\n\n  const handleKeyDown = useCallback<React.KeyboardEventHandler<E>>(\n    (event) => {\n      if (onKeyDown) {\n        onKeyDown(event);\n      }\n\n      const { key, altKey, ctrlKey, metaKey } = event;\n      if (\n        altKey ||\n        ctrlKey ||\n        metaKey ||\n        key.length > 1 ||\n        (!value.current && key === \" \")\n      ) {\n        // might need to change this later if other languages have non-meta keys\n        // that are more than 1 letter\n        return;\n      }\n\n      let nextValue = key;\n      if (value.current !== key) {\n        nextValue = `${value.current}${key}`;\n      }\n      setValue(nextValue);\n\n      const index = findMatchIndex(nextValue, values, searchIndex, true);\n      // don't want to trigger change events if the search didn't match anything\n      // since you normally don't really care about failed matches\n      if (index === searchIndex || index === -1) {\n        return;\n      }\n\n      const data: SearchData<D, E> = {\n        index,\n        item: items[index],\n        items,\n        query: nextValue,\n        target: event.currentTarget,\n      };\n\n      onChange(data);\n    },\n    [\n      searchIndex,\n      findMatchIndex,\n      items,\n      onChange,\n      onKeyDown,\n      setValue,\n      value,\n      values,\n    ]\n  );\n\n  return handleKeyDown;\n}\n"]},"metadata":{},"sourceType":"module"}