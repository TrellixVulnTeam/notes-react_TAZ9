{"ast":null,"code":"var __assign = this && this.__assign || function () {\n  __assign = Object.assign || function (t) {\n    for (var s, i = 1, n = arguments.length; i < n; i++) {\n      s = arguments[i];\n\n      for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p)) t[p] = s[p];\n    }\n\n    return t;\n  };\n\n  return __assign.apply(this, arguments);\n};\n\nvar __rest = this && this.__rest || function (s, e) {\n  var t = {};\n\n  for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0) t[p] = s[p];\n\n  if (s != null && typeof Object.getOwnPropertySymbols === \"function\") for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {\n    if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i])) t[p[i]] = s[p[i]];\n  }\n  return t;\n};\n\nvar __read = this && this.__read || function (o, n) {\n  var m = typeof Symbol === \"function\" && o[Symbol.iterator];\n  if (!m) return o;\n  var i = m.call(o),\n      r,\n      ar = [],\n      e;\n\n  try {\n    while ((n === void 0 || n-- > 0) && !(r = i.next()).done) ar.push(r.value);\n  } catch (error) {\n    e = {\n      error: error\n    };\n  } finally {\n    try {\n      if (r && !r.done && (m = i[\"return\"])) m.call(i);\n    } finally {\n      if (e) throw e.error;\n    }\n  }\n\n  return ar;\n};\n\nimport { jsx as _jsx } from \"react/jsx-runtime\";\nimport { forwardRef, isValidElement } from \"react\";\nimport { Button } from \"@react-md/button\";\nimport { useMessageQueueActions, useMessageVisibility } from \"./MessageQueueContext\";\nimport { Snackbar } from \"./Snackbar\";\nimport { Toast } from \"./Toast\";\n\nfunction getId(snackbarId, toastId, actionId) {\n  if (actionId) {\n    return actionId;\n  }\n\n  if (toastId) {\n    return \"\".concat(toastId, \"-action\");\n  }\n\n  return \"\".concat(snackbarId, \"-action\");\n}\n/**\n * Because the toast renderer is a callback function instead of a React\n * component, it's actually required to create a separate component instance so\n * that the context API can be\n *\n * @internal\n */\n\n\nfunction SnackbarQueueT(_a, ref) {\n  var queue = _a.queue,\n      onActionClick = _a.onActionClick,\n      props = __rest(_a, [\"queue\", \"onActionClick\"]);\n\n  var _b = __read(queue, 1),\n      toast = _b[0];\n\n  var visible = useMessageVisibility();\n\n  var _c = useMessageQueueActions(),\n      popMessage = _c.popMessage,\n      hideMessage = _c.hideMessage,\n      startTimer = _c.startTimer;\n\n  var content = null;\n\n  if (toast) {\n    var snackbarId = props.id;\n    var toastId = toast.id;\n\n    var _messageId = toast.messageId,\n        _messagePriority = toast.messagePriority,\n        _d = toast.disableAutohide,\n        disableAutohide = _d === void 0 ? false : _d,\n        _e = toast.disableActionHide,\n        disableActionHide_1 = _e === void 0 ? false : _e,\n        providedAction = toast.action,\n        toastProps = __rest(toast, [\"messageId\", \"messagePriority\", \"disableAutohide\", \"disableActionHide\", \"action\"]);\n\n    var action = null;\n\n    if (providedAction) {\n      var actionProps_1 = providedAction;\n\n      var onClick = function (event) {\n        if (onActionClick) {\n          onActionClick(toast, event);\n        }\n\n        if (actionProps_1.onClick) {\n          actionProps_1.onClick(event);\n        }\n\n        if (!disableActionHide_1) {\n          hideMessage();\n        }\n      };\n\n      var t = typeof providedAction;\n\n      if (isValidElement(providedAction) || t !== \"object\") {\n        action = _jsx(Button, __assign({\n          id: getId(snackbarId, toastId, undefined),\n          onClick: onClick,\n          theme: \"secondary\"\n        }, {\n          children: providedAction\n        }));\n      } else {\n        action = _jsx(Button, __assign({\n          id: getId(snackbarId, toastId, actionProps_1.id),\n          theme: \"secondary\"\n        }, actionProps_1, {\n          onClick: onClick\n        }));\n      }\n    }\n\n    content = _jsx(Toast, __assign({}, toastProps, {\n      action: action,\n      visible: visible,\n      onEntered: disableAutohide ? undefined : startTimer,\n      onExited: popMessage\n    }));\n  }\n\n  return _jsx(Snackbar, __assign({}, props, {\n    ref: ref\n  }, {\n    children: content\n  }));\n}\n\nexport var SnackbarQueue = forwardRef(SnackbarQueueT);","map":{"version":3,"mappings":"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","names":["forwardRef","isValidElement","Button","useMessageQueueActions","useMessageVisibility","Snackbar","Toast","getId","snackbarId","toastId","actionId","SnackbarQueueT","_a","ref","onActionClick","props","queue","toast","visible","popMessage","hideMessage","startTimer","content","id","_messageId","_messagePriority","_d","disableAutohide","_e","disableActionHide_1","providedAction","toastProps","action","actionProps_1","onClick","event","t","_jsx","__assign","undefined","theme","children","onEntered","onExited","SnackbarQueue"],"sources":["C:\\Users\\hungr\\Documents\\VS-CODE\\notes-react\\node_modules\\@react-md\\alert\\src\\SnackbarQueue.tsx"],"sourcesContent":["import type { ReactElement, ReactNode, Ref } from \"react\";\nimport { forwardRef, isValidElement } from \"react\";\nimport type { ButtonProps } from \"@react-md/button\";\nimport { Button } from \"@react-md/button\";\n\nimport type { ToastMessage } from \"./MessageQueueContext\";\nimport {\n  useMessageQueueActions,\n  useMessageVisibility,\n} from \"./MessageQueueContext\";\nimport type { SnackbarProps } from \"./Snackbar\";\nimport { Snackbar } from \"./Snackbar\";\nimport { Toast } from \"./Toast\";\n\nexport type ActionEventHandler<M extends ToastMessage> = (\n  message: M,\n  event: React.MouseEvent<HTMLButtonElement>\n) => void;\n\nexport interface SnackbarQueueProps<M extends ToastMessage>\n  extends SnackbarProps {\n  queue: readonly M[];\n  onActionClick?: ActionEventHandler<M>;\n}\n\nfunction getId(\n  snackbarId: string,\n  toastId: string | undefined,\n  actionId: string | undefined\n): string | undefined {\n  if (actionId) {\n    return actionId;\n  }\n\n  if (toastId) {\n    return `${toastId}-action`;\n  }\n\n  return `${snackbarId}-action`;\n}\n\n/**\n * Because the toast renderer is a callback function instead of a React\n * component, it's actually required to create a separate component instance so\n * that the context API can be\n *\n * @internal\n */\nfunction SnackbarQueueT<M extends ToastMessage = ToastMessage>(\n  { queue, onActionClick, ...props }: SnackbarQueueProps<M>,\n  ref?: Ref<HTMLDivElement>\n): ReactElement {\n  const [toast] = queue;\n  const visible = useMessageVisibility();\n  const { popMessage, hideMessage, startTimer } = useMessageQueueActions();\n\n  let content = null;\n  if (toast) {\n    const snackbarId = props.id;\n    const toastId = toast.id;\n    const {\n      messageId: _messageId,\n      messagePriority: _messagePriority,\n      disableAutohide = false,\n      disableActionHide = false,\n      action: providedAction,\n      ...toastProps\n    } = toast;\n\n    let action: ReactNode = null;\n    if (providedAction) {\n      const actionProps = providedAction as ButtonProps;\n      const onClick: React.MouseEventHandler<HTMLButtonElement> = (event) => {\n        if (onActionClick) {\n          onActionClick(toast, event);\n        }\n\n        if (actionProps.onClick) {\n          actionProps.onClick(event);\n        }\n\n        if (!disableActionHide) {\n          hideMessage();\n        }\n      };\n\n      const t = typeof providedAction;\n      if (isValidElement(providedAction) || t !== \"object\") {\n        action = (\n          <Button\n            id={getId(snackbarId, toastId, undefined)}\n            onClick={onClick}\n            theme=\"secondary\"\n          >\n            {providedAction}\n          </Button>\n        );\n      } else {\n        action = (\n          <Button\n            id={getId(snackbarId, toastId, actionProps.id)}\n            theme=\"secondary\"\n            {...actionProps}\n            onClick={onClick}\n          />\n        );\n      }\n    }\n\n    content = (\n      <Toast\n        {...toastProps}\n        action={action}\n        visible={visible}\n        onEntered={disableAutohide ? undefined : startTimer}\n        onExited={popMessage}\n      />\n    );\n  }\n\n  return (\n    <Snackbar {...props} ref={ref}>\n      {content}\n    </Snackbar>\n  );\n}\n\nexport const SnackbarQueue = forwardRef<\n  HTMLDivElement,\n  // eslint-disable-next-line @typescript-eslint/no-explicit-any\n  SnackbarQueueProps<any>\n>(SnackbarQueueT);\n"]},"metadata":{},"sourceType":"module"}