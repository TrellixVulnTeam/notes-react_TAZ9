{"ast":null,"code":"var __assign = this && this.__assign || function () {\n  __assign = Object.assign || function (t) {\n    for (var s, i = 1, n = arguments.length; i < n; i++) {\n      s = arguments[i];\n\n      for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p)) t[p] = s[p];\n    }\n\n    return t;\n  };\n\n  return __assign.apply(this, arguments);\n};\n\nimport cn from \"classnames\";\nimport { useRipples } from \"./ripples/useRipples\";\nimport { useStatesConfigContext } from \"./StatesConfig\";\nimport { useKeyboardClickPolyfill } from \"./useKeyboardClickPolyfill\";\nimport { usePressedStates } from \"./usePressedStates\";\n/**\n * This is probably one of the most useful hook in react-md. Any functional\n * component component that uses this will gain all the different interaction\n * states based on the states context or any custom overrides.\n *\n * The main interaction state is the \"ripple\" effect when an element has been\n * clicked either via keyboard, mouse, or touch.\n *\n * If the ripple effect is disabled, it will fallback to \"polyfilling\"/fixing\n * the `:pressed` pseudo-selector state for items so that a different\n * background-color opacity is applied instead of the entire ripple effect. This\n * is polyfilled since the `:pressed` state does not work on anything other than\n * buttons and links by default and it is not triggered on \"valid\" keyboard\n * clicks with a spacebar.\n *\n * Finally, the element that uses this hook will gain a focused className\n * whenever it gains keyboard focus only.\n *\n * To get all these interaction states to work correctly, this hook returns an\n * object containing:\n *\n * - `handlers`- an object of event handlers that must be passed down to your\n *   component to get the different interaction states. All the event handlers\n *   are automatically merged with any `handlers` that are provided to this hook\n *   so they can all be called if needed.\n * - `className` - the current class name for the element\n * - `ripples` - a renderable element that displays the ripple effects. This\n *   will be `null` when ripples are disabled.\n *\n * @typeParam E - The element type for the component being wrapped. This is\n * really just used to \"better type\" the event handlers.\n */\n\nexport function useInteractionStates(options) {\n  if (options === void 0) {\n    options = {};\n  }\n\n  var disabled = options.disabled,\n      rippleClassName = options.rippleClassName,\n      rippleContainerClassName = options.rippleContainerClassName,\n      _a = options.disableSpacebarClick,\n      disableSpacebarClick = _a === void 0 ? false : _a,\n      _b = options.disablePressedFallback,\n      disablePressedFallback = _b === void 0 ? false : _b,\n      _c = options.enablePressedAndRipple,\n      enablePressedAndRipple = _c === void 0 ? false : _c,\n      _d = options.disableEnterClick,\n      disableEnterClick = _d === void 0 ? false : _d;\n  var className = options.className,\n      disableRipple = options.disableRipple,\n      disableProgrammaticRipple = options.disableProgrammaticRipple,\n      rippleTimeout = options.rippleTimeout,\n      rippleClassNames = options.rippleClassNames; // populate undefined props from their context values\n\n  var context = useStatesConfigContext();\n\n  if (typeof disableRipple === \"undefined\") {\n    disableRipple = context.disableRipple;\n  }\n\n  if (typeof disableProgrammaticRipple === \"undefined\") {\n    disableProgrammaticRipple = context.disableProgrammaticRipple;\n  }\n\n  if (typeof rippleTimeout === \"undefined\") {\n    rippleTimeout = context.rippleTimeout;\n  }\n\n  if (typeof rippleClassNames === \"undefined\") {\n    rippleClassNames = context.rippleClassNames;\n  }\n\n  var handlers = null;\n  var ripples = null;\n  var ripplesResult = useRipples(__assign(__assign({}, options), {\n    disableSpacebarClick: disableSpacebarClick,\n    disableRipple: disableRipple,\n    disableProgrammaticRipple: disableProgrammaticRipple,\n    rippleTimeout: rippleTimeout,\n    rippleClassName: rippleClassName,\n    rippleContainerClassName: rippleContainerClassName\n  }));\n\n  if (!disableRipple) {\n    ripples = ripplesResult.ripples, handlers = ripplesResult.handlers;\n  }\n\n  var pressedResult = usePressedStates(__assign(__assign({}, options), {\n    handlers: handlers || options.handlers,\n    disableSpacebarClick: disableSpacebarClick\n  }));\n\n  if (enablePressedAndRipple || disableRipple && !disablePressedFallback) {\n    handlers = pressedResult.handlers;\n    className = cn(className, {\n      \"rmd-states--pressed\": pressedResult.pressed\n    });\n  }\n\n  handlers = handlers || options.handlers || {};\n  handlers.onKeyDown = useKeyboardClickPolyfill({\n    disabled: disabled,\n    disableEnterClick: disableEnterClick,\n    disableSpacebarClick: disableSpacebarClick,\n    onKeyDown: handlers.onKeyDown\n  });\n  return {\n    ripples: ripples,\n    className: className,\n    handlers: handlers\n  };\n}","map":{"version":3,"mappings":"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","names":["cn","useRipples","useStatesConfigContext","useKeyboardClickPolyfill","usePressedStates","useInteractionStates","options","rippleClassName","rippleContainerClassName","_a","disableSpacebarClick","_b","disablePressedFallback","_c","enablePressedAndRipple","_d","disableEnterClick","disableRipple","disableProgrammaticRipple","rippleTimeout","rippleClassNames","context","handlers","ripples","ripplesResult","pressedResult","className","pressed","onKeyDown","disabled"],"sources":["C:\\Users\\hungr\\Documents\\VS-CODE\\notes-react\\node_modules\\@react-md\\states\\src\\useInteractionStates.ts"],"sourcesContent":["import type { ReactNode } from \"react\";\nimport cn from \"classnames\";\nimport type { Maybe } from \"@react-md/utils\";\n\nimport type { MergableRippleHandlers, RipplesOptions } from \"./ripples/types\";\nimport { useRipples } from \"./ripples/useRipples\";\nimport type { StatesConfigContextType } from \"./StatesConfig\";\nimport { useStatesConfigContext } from \"./StatesConfig\";\nimport { useKeyboardClickPolyfill } from \"./useKeyboardClickPolyfill\";\nimport { usePressedStates } from \"./usePressedStates\";\n\nexport interface InteractionStatesOptions<E extends HTMLElement = HTMLElement>\n  extends Partial<StatesConfigContextType>,\n    RipplesOptions<E> {\n  /**\n   * An optional className to merge with the different interaction states.\n   */\n  className?: string;\n\n  /**\n   * Boolean if the enter keyboard click polyfill should be completely disabled.\n   * This is generally used if the keyboard functionality is already built-in to\n   * the element like buttons or labels.\n   */\n  disableEnterClick?: boolean;\n\n  /**\n   * Boolean if the spacebar should not trigger a click event when using the\n   * user pressed spacebar on a focusable element. You _normally_ want the\n   * spacebar to also trigger a click event , but there are a few cases where it\n   * should not (like custom links).\n   *\n   * When this is disabled, it will also make sure that the ripple and pressed\n   * effects are not triggered from a spacebar click.\n   *\n   * @defaultValue `false`\n   */\n  disableSpacebarClick?: boolean;\n\n  /**\n   * Boolean if the component should fallback to using the custom pressed class\n   * names when ripples are disabled.\n   *\n   * @defaultValue `false`\n   */\n  disablePressedFallback?: boolean;\n\n  /**\n   * Boolean if the element should be able to gain both the ripple effect and\n   * the pressed states changes. This will only be enabled if both the\n   * `disableRipple` and `disabledPressedFallback` are still `false`\n   */\n  enablePressedAndRipple?: boolean;\n}\n\ninterface ReturnValue<E extends HTMLElement> {\n  ripples: ReactNode;\n  className: string | undefined;\n  handlers: MergableRippleHandlers<E>;\n}\n\n/**\n * This is probably one of the most useful hook in react-md. Any functional\n * component component that uses this will gain all the different interaction\n * states based on the states context or any custom overrides.\n *\n * The main interaction state is the \"ripple\" effect when an element has been\n * clicked either via keyboard, mouse, or touch.\n *\n * If the ripple effect is disabled, it will fallback to \"polyfilling\"/fixing\n * the `:pressed` pseudo-selector state for items so that a different\n * background-color opacity is applied instead of the entire ripple effect. This\n * is polyfilled since the `:pressed` state does not work on anything other than\n * buttons and links by default and it is not triggered on \"valid\" keyboard\n * clicks with a spacebar.\n *\n * Finally, the element that uses this hook will gain a focused className\n * whenever it gains keyboard focus only.\n *\n * To get all these interaction states to work correctly, this hook returns an\n * object containing:\n *\n * - `handlers`- an object of event handlers that must be passed down to your\n *   component to get the different interaction states. All the event handlers\n *   are automatically merged with any `handlers` that are provided to this hook\n *   so they can all be called if needed.\n * - `className` - the current class name for the element\n * - `ripples` - a renderable element that displays the ripple effects. This\n *   will be `null` when ripples are disabled.\n *\n * @typeParam E - The element type for the component being wrapped. This is\n * really just used to \"better type\" the event handlers.\n */\nexport function useInteractionStates<E extends HTMLElement = HTMLElement>(\n  options: InteractionStatesOptions<E> = {}\n): ReturnValue<E> {\n  const {\n    disabled,\n    rippleClassName,\n    rippleContainerClassName,\n    disableSpacebarClick = false,\n    disablePressedFallback = false,\n    enablePressedAndRipple = false,\n    disableEnterClick = false,\n  } = options;\n\n  let {\n    className,\n    disableRipple,\n    disableProgrammaticRipple,\n    rippleTimeout,\n    rippleClassNames,\n  } = options;\n\n  // populate undefined props from their context values\n  const context = useStatesConfigContext();\n  if (typeof disableRipple === \"undefined\") {\n    ({ disableRipple } = context);\n  }\n\n  if (typeof disableProgrammaticRipple === \"undefined\") {\n    ({ disableProgrammaticRipple } = context);\n  }\n\n  if (typeof rippleTimeout === \"undefined\") {\n    ({ rippleTimeout } = context);\n  }\n\n  if (typeof rippleClassNames === \"undefined\") {\n    ({ rippleClassNames } = context);\n  }\n\n  let handlers: Maybe<MergableRippleHandlers<E>> = null;\n  let ripples: ReactNode = null;\n  const ripplesResult = useRipples({\n    ...options,\n    disableSpacebarClick,\n    disableRipple,\n    disableProgrammaticRipple,\n    rippleTimeout,\n    rippleClassName,\n    rippleContainerClassName,\n  });\n\n  if (!disableRipple) {\n    ({ ripples, handlers } = ripplesResult);\n  }\n\n  const pressedResult = usePressedStates({\n    ...options,\n    handlers: handlers || options.handlers,\n    disableSpacebarClick,\n  });\n\n  if (enablePressedAndRipple || (disableRipple && !disablePressedFallback)) {\n    ({ handlers } = pressedResult);\n    className = cn(className, { \"rmd-states--pressed\": pressedResult.pressed });\n  }\n\n  handlers = handlers || options.handlers || ({} as MergableRippleHandlers<E>);\n\n  handlers.onKeyDown = useKeyboardClickPolyfill({\n    disabled,\n    disableEnterClick,\n    disableSpacebarClick,\n    onKeyDown: handlers.onKeyDown,\n  });\n\n  return {\n    ripples,\n    className,\n    handlers,\n  };\n}\n"]},"metadata":{},"sourceType":"module"}