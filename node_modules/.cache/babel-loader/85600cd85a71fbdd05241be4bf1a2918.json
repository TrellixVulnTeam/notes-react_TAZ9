{"ast":null,"code":"var __assign = this && this.__assign || function () {\n  __assign = Object.assign || function (t) {\n    for (var s, i = 1, n = arguments.length; i < n; i++) {\n      s = arguments[i];\n\n      for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p)) t[p] = s[p];\n    }\n\n    return t;\n  };\n\n  return __assign.apply(this, arguments);\n};\n\nvar __rest = this && this.__rest || function (s, e) {\n  var t = {};\n\n  for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0) t[p] = s[p];\n\n  if (s != null && typeof Object.getOwnPropertySymbols === \"function\") for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {\n    if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i])) t[p[i]] = s[p[i]];\n  }\n  return t;\n};\n\nvar __read = this && this.__read || function (o, n) {\n  var m = typeof Symbol === \"function\" && o[Symbol.iterator];\n  if (!m) return o;\n  var i = m.call(o),\n      r,\n      ar = [],\n      e;\n\n  try {\n    while ((n === void 0 || n-- > 0) && !(r = i.next()).done) ar.push(r.value);\n  } catch (error) {\n    e = {\n      error: error\n    };\n  } finally {\n    try {\n      if (r && !r.done && (m = i[\"return\"])) m.call(i);\n    } finally {\n      if (e) throw e.error;\n    }\n  }\n\n  return ar;\n};\n\nvar __spreadArray = this && this.__spreadArray || function (to, from, pack) {\n  if (pack || arguments.length === 2) for (var i = 0, l = from.length, ar; i < l; i++) {\n    if (ar || !(i in from)) {\n      if (!ar) ar = Array.prototype.slice.call(from, 0, i);\n      ar[i] = from[i];\n    }\n  }\n  return to.concat(ar || Array.prototype.slice.call(from));\n};\n\nimport { useCallback, useEffect, useReducer } from \"react\";\nimport { nanoid } from \"nanoid\";\nimport { omit } from \"@react-md/utils\";\nimport { getFileParser as defaultGetFileParser, FileAccessError, isValidFileName as defaultIsValidFileName, validateFiles as defaultValidateFiles } from \"./utils\";\n/** @internal */\n\nvar EMPTY_LIST = [];\n/** @internal */\n\nvar EMPTY_OBJECT = {};\n/**\n * This hook is generally used to upload files **to the browser** in different\n * formats to be previewed `<img>`, `<video>`, `<embed>`, etc tags. However, it\n * can also be used to upload the files as an `ArrayBuffer` and then uploaded to\n * a server.\n *\n * Note: If using the `aws-sdk` to upload files directly to S3, **do not use\n * this hook** since it uses its own upload process.\n *\n * @typeParam E - An optional HTMLElement type that is used for the\n * {@link FileUploadHandlers}.\n * @typeParam CustomError - An optional error type that gets returned from the\n * {@link FilesValidator}.\n * @param options - All the {@link FileUploadOptions}\n * @returns the {@link FileUploadHookReturnValue}\n * @remarks \\@since 2.9.0\n */\n\nexport function useFileUpload(_a) {\n  var _b = _a === void 0 ? {} : _a,\n      _c = _b.maxFiles,\n      maxFiles = _c === void 0 ? -1 : _c,\n      _d = _b.extensions,\n      extensions = _d === void 0 ? EMPTY_LIST : _d,\n      _e = _b.minFileSize,\n      minFileSize = _e === void 0 ? -1 : _e,\n      _f = _b.maxFileSize,\n      maxFileSize = _f === void 0 ? -1 : _f,\n      _g = _b.totalFileSize,\n      totalFileSize = _g === void 0 ? -1 : _g,\n      _h = _b.concurrency,\n      concurrency = _h === void 0 ? -1 : _h,\n      propOnDrop = _b.onDrop,\n      propOnChange = _b.onChange,\n      _j = _b.validateFiles,\n      validateFiles = _j === void 0 ? defaultValidateFiles : _j,\n      _k = _b.getFileParser,\n      getFileParser = _k === void 0 ? defaultGetFileParser : _k,\n      _l = _b.isValidFileName,\n      isValidFileName = _l === void 0 ? defaultIsValidFileName : _l;\n\n  var _m = __read(useReducer(function reducer(state, action) {\n    var _a, _b, _c, _d;\n\n    switch (action.type) {\n      case \"reset\":\n        // need to reuse constants so that calling reset doesn't cause an\n        // infinite loop in an effect\n        return {\n          stats: EMPTY_OBJECT,\n          errors: EMPTY_LIST,\n          readers: EMPTY_OBJECT\n        };\n\n      case \"remove\":\n        return __assign(__assign({}, state), {\n          stats: omit(state.stats, action.files)\n        });\n\n      case \"queue\":\n        return __assign(__assign({}, state), {\n          stats: __assign(__assign({}, state.stats), action.files.reduce(function (files, file) {\n            var key = nanoid();\n            files[key] = {\n              key: key,\n              file: file,\n              progress: 0,\n              status: \"pending\"\n            };\n            return files;\n          }, {})),\n          errors: __spreadArray(__spreadArray([], __read(state.errors), false), __read(action.errors), false)\n        });\n\n      case \"start\":\n        {\n          var key = action.key,\n              reader = action.reader;\n          /* istanbul ignore next */\n\n          if (!state.stats[key]) {\n            throw new Error(\"Missing file with key \\\"\".concat(key, \"\\\"\"));\n          }\n\n          var fileStats = {\n            key: key,\n            file: state.stats[key].file,\n            progress: 0,\n            status: \"uploading\"\n          };\n          return __assign(__assign({}, state), {\n            readers: __assign(__assign({}, state.readers), (_a = {}, _a[key] = reader, _a)),\n            stats: __assign(__assign({}, state.stats), (_b = {}, _b[key] = fileStats, _b))\n          });\n        }\n\n      case \"progress\":\n        {\n          var key = action.key,\n              progress = action.progress;\n          /* istanbul ignore next */\n\n          if (!state.stats[key]) {\n            throw new Error(\"Missing file with key \\\"\".concat(key, \"\\\"\"));\n          }\n\n          return __assign(__assign({}, state), {\n            stats: __assign(__assign({}, state.stats), (_c = {}, _c[key] = __assign(__assign({}, state.stats[key]), {\n              progress: progress\n            }), _c))\n          });\n        }\n\n      case \"complete\":\n        {\n          var key = action.key,\n              result = action.result;\n          /* istanbul ignore next */\n\n          if (!state.stats[key]) {\n            throw new Error(\"Missing file with key \\\"\".concat(key, \"\\\"\"));\n          }\n\n          var file = {\n            key: key,\n            file: state.stats[key].file,\n            status: \"complete\",\n            result: result,\n            progress: 100\n          };\n\n          var _e = state.readers,\n              _f = key,\n              _reader = _e[_f],\n              readers_1 = __rest(_e, [typeof _f === \"symbol\" ? _f : _f + \"\"]);\n\n          return __assign(__assign({}, state), {\n            readers: readers_1,\n            stats: __assign(__assign({}, state.stats), (_d = {}, _d[key] = file, _d))\n          });\n        }\n\n      case \"clearErrors\":\n        return __assign(__assign({}, state), {\n          errors: []\n        });\n\n      default:\n        /* istanbul ignore next */\n        return state;\n    }\n  }, {\n    stats: EMPTY_OBJECT,\n    errors: EMPTY_LIST,\n    readers: EMPTY_OBJECT\n  }), 2),\n      state = _m[0],\n      dispatch = _m[1];\n\n  var stats = state.stats,\n      errors = state.errors,\n      readers = state.readers;\n  var statsList = Object.values(stats);\n  var totalFiles = statsList.length;\n  var totalBytes = statsList.reduce(function (result, _a) {\n    var size = _a.file.size;\n    return result + size;\n  }, 0);\n  var queueFiles = useCallback(function (files) {\n    var _a = validateFiles(files, {\n      maxFiles: maxFiles,\n      extensions: extensions,\n      minFileSize: minFileSize,\n      maxFileSize: maxFileSize,\n      totalBytes: totalBytes,\n      totalFiles: totalFiles,\n      totalFileSize: totalFileSize,\n      isValidFileName: isValidFileName\n    }),\n        pending = _a.pending,\n        errors = _a.errors;\n\n    dispatch({\n      type: \"queue\",\n      errors: errors,\n      files: pending\n    });\n  }, [validateFiles, maxFiles, extensions, minFileSize, maxFileSize, totalBytes, totalFiles, totalFileSize, isValidFileName]);\n  var onDrop = useCallback(function (event) {\n    propOnDrop === null || propOnDrop === void 0 ? void 0 : propOnDrop(event);\n    event.preventDefault();\n    event.stopPropagation();\n\n    try {\n      var files = event.dataTransfer.files;\n\n      if (files) {\n        queueFiles(Array.from(files));\n      }\n    } catch (e) {\n      dispatch({\n        type: \"queue\",\n        files: [],\n        errors: [new FileAccessError(e instanceof Error ? e.message : undefined)]\n      });\n    }\n  }, [queueFiles, propOnDrop]);\n  var onChange = useCallback(function (event) {\n    propOnChange === null || propOnChange === void 0 ? void 0 : propOnChange(event);\n\n    try {\n      var files = event.currentTarget.files;\n\n      if (files) {\n        queueFiles(Array.from(files));\n      } else {\n        throw new Error();\n      }\n    } catch (e) {\n      dispatch({\n        type: \"queue\",\n        files: [],\n        errors: [new FileAccessError(e instanceof Error ? e.message : undefined)]\n      });\n    }\n  }, [queueFiles, propOnChange]);\n  var remove = useCallback(function (keyOrKeys) {\n    var files = typeof keyOrKeys === \"string\" ? [keyOrKeys] : keyOrKeys;\n    files.forEach(function (fileKey) {\n      var _a;\n\n      (_a = readers[fileKey]) === null || _a === void 0 ? void 0 : _a.abort();\n    });\n    dispatch({\n      type: \"remove\",\n      files: files\n    });\n  }, [readers]);\n  var reset = useCallback(function () {\n    Object.values(readers).forEach(function (reader) {\n      reader.abort();\n    });\n    dispatch({\n      type: \"reset\"\n    });\n  }, [readers]);\n  var clearErrors = useCallback(function () {\n    dispatch({\n      type: \"clearErrors\"\n    });\n  }, []);\n  var start = useCallback(function (key, reader) {\n    dispatch({\n      type: \"start\",\n      key: key,\n      reader: reader\n    });\n  }, []);\n  var complete = useCallback(function (key, result) {\n    if (result === void 0) {\n      result = null;\n    }\n\n    dispatch({\n      type: \"complete\",\n      key: key,\n      result: result\n    });\n  }, []);\n  var createProgressEventHandler = useCallback(function (key) {\n    return function (event) {\n      if (event.lengthComputable) {\n        var percentage = Math.round(event.loaded * 100 / event.total);\n        dispatch({\n          type: \"progress\",\n          key: key,\n          progress: percentage\n        });\n      }\n    };\n  }, []);\n  useEffect(function () {\n    var pending = [];\n    var uploading = [];\n    Object.values(stats).forEach(function (file) {\n      if (file.status === \"pending\") {\n        pending.push(file);\n      } else if (file.status === \"uploading\") {\n        uploading.push(file);\n      }\n    });\n    var lastIndex = concurrency === -1 ? pending.length : Math.max(0, concurrency - uploading.length);\n    var queue = pending.slice(0, lastIndex);\n\n    if (!queue.length) {\n      return;\n    }\n\n    queue.forEach(function (stats) {\n      var key = stats.key,\n          file = stats.file;\n      var reader = new FileReader(); // using `addEventListener` instead of directly setting to\n      // `reader.progress`/`reader.load` so it's easier to test\n\n      reader.addEventListener(\"progress\", createProgressEventHandler(key));\n      reader.addEventListener(\"load\", function () {\n        complete(key, reader.result);\n      });\n      start(key, reader);\n      var parser = getFileParser(file);\n      /* istanbul ignore next */\n\n      if (process.env.NODE_ENV !== \"production\" && ![\"readAsText\", \"readAsDataURL\", \"readAsArrayBuffer\", \"readAsBinaryString\"].includes(parser)) {\n        throw new Error(\"Invalid file reader parser\");\n      }\n\n      reader[parser](file);\n    });\n  }, [concurrency, stats, getFileParser, createProgressEventHandler, start, complete]);\n  var accept = \"\";\n\n  if (extensions.length) {\n    accept = extensions.reduce(function (s, ext) {\n      return \"\".concat(s ? \"\".concat(s, \",\") : \"\", \".\").concat(ext);\n    }, \"\");\n  }\n\n  return {\n    stats: statsList,\n    errors: errors,\n    accept: accept,\n    totalBytes: totalBytes,\n    totalFiles: totalFiles,\n    onDrop: onDrop,\n    onChange: onChange,\n    reset: reset,\n    remove: remove,\n    clearErrors: clearErrors\n  };\n}","map":{"version":3,"mappings":"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","names":["useCallback","useEffect","useReducer","nanoid","omit","getFileParser","defaultGetFileParser","FileAccessError","isValidFileName","defaultIsValidFileName","validateFiles","defaultValidateFiles","EMPTY_LIST","EMPTY_OBJECT","useFileUpload","_a","_b","_c","maxFiles","_d","extensions","_e","minFileSize","_f","maxFileSize","_g","totalFileSize","_h","concurrency","propOnDrop","propOnChange","_j","_k","_l","reducer","state","action","type","stats","errors","readers","files","reduce","file","key","progress","status","__read","reader","Error","fileStats","__assign","result","_reader","readers_1","dispatch","statsList","Object","values","totalFiles","length","totalBytes","size","queueFiles","pending","onDrop","event","preventDefault","stopPropagation","dataTransfer","Array","from","e","message","undefined","onChange","currentTarget","remove","keyOrKeys","forEach","fileKey","abort","reset","clearErrors","start","complete","createProgressEventHandler","lengthComputable","percentage","Math","round","loaded","total","uploading","push","lastIndex","max","queue","slice","FileReader","addEventListener","parser","process","env","NODE_ENV","includes","accept","s","ext","concat"],"sources":["C:\\Users\\hungr\\Documents\\VS-CODE\\notes-react\\node_modules\\@react-md\\form\\src\\file-input\\useFileUpload.ts"],"sourcesContent":["import type { ChangeEvent, DragEvent } from \"react\";\nimport { useCallback, useEffect, useReducer } from \"react\";\nimport { nanoid } from \"nanoid\";\nimport { omit } from \"@react-md/utils\";\n\nimport type {\n  CompletedFileUploadStats,\n  FileReaderResult,\n  FileUploadHandlers,\n  FileUploadStats,\n  FileValidationError,\n  FilesValidator,\n  GetFileParser,\n  ProcessingFileUploadStats,\n  FileValidationOptions,\n} from \"./utils\";\nimport {\n  getFileParser as defaultGetFileParser,\n  FileAccessError,\n  isValidFileName as defaultIsValidFileName,\n  validateFiles as defaultValidateFiles,\n} from \"./utils\";\n\n/**\n *\n * @typeParam CustomError - An optional error type that gets returned from the\n * {@link FilesValidator}.\n * @remarks \\@since 2.9.0\n */\nexport interface FileUploadState<CustomError = never> {\n  /**\n   * All the files that have been validated and are either:\n   * - pending upload\n   * - uploading\n   * - complete\n   *\n   * Each key in this object is the {@link BaseFileUploadStats.key} generated\n   * once the upload starts pending.\n   */\n  stats: Readonly<Record<string, Readonly<FileUploadStats>>>;\n\n  /**\n   * A list of validation errors that have occurred before starting the upload\n   * process.\n   *\n   * @see {@link FileAccessError}\n   * @see {@link TooManyFilesError}\n   * @see {@link FileValidationError}\n   */\n  errors: readonly FileValidationError<CustomError>[];\n}\n\n/**\n *\n * @typeParam CustomError - An optional error type that gets returned from the\n * {@link FilesValidator}.\n * @remarks \\@since 2.9.0\n * @internal\n */\nexport interface FileUploadHookState<CustomError = never>\n  extends FileUploadState<CustomError> {\n  /**\n   * All the current readers used for uploading files to the browser.\n   *\n   * Note: Once an upload has completed, the reader will be removed.\n   */\n  readers: Readonly<Record<string, FileReader>>;\n}\n\n/**\n *\n * @typeParam E - An optional HTMLElement type that is used for the\n * {@link FileUploadHandlers}.\n * @typeParam CustomError - An optional error type that gets returned from the\n * {@link FilesValidator}.\n * @remarks \\@since 2.9.0\n */\nexport interface FileUploadOptions<E extends HTMLElement, CustomError = never>\n  extends FileUploadHandlers<E>,\n    FileValidationOptions {\n  /**\n   * Setting this value to a number greater than `0` will update the browser\n   * upload process to queue the uploads in chunks instead of all at once. This\n   * can help prevent the browser from freezing if dealing with large files that\n   * are being converted to data urls.\n   *\n   * @defaultValue `-1`\n   */\n  concurrency?: number;\n\n  /** {@inheritDoc FilesValidator} */\n  validateFiles?: FilesValidator<CustomError>;\n  /** {@inheritDoc GetFileParser} */\n  getFileParser?: GetFileParser;\n}\n\n/** @internal */\ntype Action<E = never> =\n  | {\n      type: \"queue\";\n      errors: readonly FileValidationError<E>[];\n      files: readonly File[];\n    }\n  | { type: \"reset\" }\n  | { type: \"remove\"; files: readonly string[] }\n  | { type: \"start\"; key: string; reader: FileReader }\n  | { type: \"progress\"; key: string; progress: number }\n  | { type: \"complete\"; key: string; result: FileReaderResult }\n  | { type: \"clearErrors\" };\n\n/** @remarks \\@since 2.9.0 */\nexport interface FileUploadActions {\n  /**\n   * Reset everything related to uploads ensuring that all file readers have\n   * been aborted.\n   */\n  reset(): void;\n\n  /**\n   * Removes all the errors that exist in state without cancelling any of the\n   * uploads already in progress.\n   */\n  clearErrors(): void;\n\n  /**\n   * This function is used to cancel pending and uploading files or removing\n   * completed files.\n   *\n   * @param keyOrKeys - A single or list of {@link BaseFileUploadStats.key} to\n   * remove from state.\n   */\n  remove(keyOrKeys: string | readonly string[]): void;\n}\n\n/**\n *\n * @typeParam E - An optional HTMLElement type that is used for the\n * {@link FileUploadHandlers}.\n * @typeParam CustomError - An optional error type that gets returned from the\n * {@link FilesValidator}.\n * @remarks \\@since 2.9.0\n */\nexport interface FileUploadHookReturnValue<\n  E extends HTMLElement = HTMLElement,\n  CustomError = never\n> extends FileUploadActions,\n    Required<FileUploadHandlers<E>> {\n  /** {@inheritDoc FileUploadState.errors} */\n  errors: readonly FileValidationError<CustomError>[];\n\n  /**\n   * A list of all the {@link FileUploadStats}.\n   *\n   * @see {@link getSplitFileUploads} for separating by status\n   */\n  stats: readonly Readonly<FileUploadStats>[];\n\n  /**\n   * The total number of bytes for all the files that exist in the\n   * {@link stats} list.\n   */\n  totalBytes: number;\n\n  /**\n   * The total number of files in the {@link stats} list.\n   */\n  totalFiles: number;\n\n  /**\n   * An `accept` string that can be passed to the {@link FileInput} component\n   * when the {@link FileValidationOptions.extensions} list has been provided to\n   * limit which files the OS will _attempt_ to allow access to.\n   *\n   * @example\n   * Simple example\n   * ```ts\n   * const extensions = ['pdf', 'docx', 'ppt'];\n   * const { accept } = useFileUpload({ extensions, ...others });\n   *\n   * expect(accept).toBe(\"*.pdf,*.docx,*.ppt\")\n   * ```\n   *\n   * @defaultValue `\"*\"`\n   */\n  accept: string;\n}\n\n/** @internal */\nconst EMPTY_LIST = [] as const;\n/** @internal */\nconst EMPTY_OBJECT = {} as const;\n\n/**\n * This hook is generally used to upload files **to the browser** in different\n * formats to be previewed `<img>`, `<video>`, `<embed>`, etc tags. However, it\n * can also be used to upload the files as an `ArrayBuffer` and then uploaded to\n * a server.\n *\n * Note: If using the `aws-sdk` to upload files directly to S3, **do not use\n * this hook** since it uses its own upload process.\n *\n * @typeParam E - An optional HTMLElement type that is used for the\n * {@link FileUploadHandlers}.\n * @typeParam CustomError - An optional error type that gets returned from the\n * {@link FilesValidator}.\n * @param options - All the {@link FileUploadOptions}\n * @returns the {@link FileUploadHookReturnValue}\n * @remarks \\@since 2.9.0\n */\nexport function useFileUpload<E extends HTMLElement, CustomError = never>({\n  maxFiles = -1,\n  extensions = EMPTY_LIST,\n  minFileSize = -1,\n  maxFileSize = -1,\n  totalFileSize = -1,\n  concurrency = -1,\n  onDrop: propOnDrop,\n  onChange: propOnChange,\n  validateFiles = defaultValidateFiles,\n  getFileParser = defaultGetFileParser,\n  isValidFileName = defaultIsValidFileName,\n}: FileUploadOptions<E, CustomError> = {}): Readonly<\n  FileUploadHookReturnValue<E, CustomError>\n> {\n  const [state, dispatch] = useReducer(\n    function reducer(\n      state: FileUploadHookState<CustomError>,\n      action: Action<CustomError>\n    ) {\n      switch (action.type) {\n        case \"reset\":\n          // need to reuse constants so that calling reset doesn't cause an\n          // infinite loop in an effect\n          return {\n            stats: EMPTY_OBJECT,\n            errors: EMPTY_LIST,\n            readers: EMPTY_OBJECT,\n          };\n        case \"remove\":\n          return {\n            ...state,\n            stats: omit(state.stats, action.files),\n          };\n        case \"queue\":\n          return {\n            ...state,\n            stats: {\n              ...state.stats,\n              ...action.files.reduce<Record<string, ProcessingFileUploadStats>>(\n                (files, file) => {\n                  const key = nanoid();\n                  files[key] = {\n                    key,\n                    file,\n                    progress: 0,\n                    status: \"pending\",\n                  };\n\n                  return files;\n                },\n                {}\n              ),\n            },\n            errors: [...state.errors, ...action.errors],\n          };\n        case \"start\": {\n          const { key, reader } = action;\n          /* istanbul ignore next */\n          if (!state.stats[key]) {\n            throw new Error(`Missing file with key \"${key}\"`);\n          }\n\n          const fileStats: ProcessingFileUploadStats = {\n            key,\n            file: state.stats[key].file,\n            progress: 0,\n            status: \"uploading\",\n          };\n\n          return {\n            ...state,\n            readers: {\n              ...state.readers,\n              [key]: reader,\n            },\n            stats: {\n              ...state.stats,\n              [key]: fileStats,\n            },\n          };\n        }\n        case \"progress\": {\n          const { key, progress } = action;\n          /* istanbul ignore next */\n          if (!state.stats[key]) {\n            throw new Error(`Missing file with key \"${key}\"`);\n          }\n\n          return {\n            ...state,\n            stats: {\n              ...state.stats,\n              [key]: {\n                ...state.stats[key],\n                progress,\n              },\n            },\n          };\n        }\n        case \"complete\": {\n          const { key, result } = action;\n          /* istanbul ignore next */\n          if (!state.stats[key]) {\n            throw new Error(`Missing file with key \"${key}\"`);\n          }\n\n          const file: CompletedFileUploadStats = {\n            key,\n            file: state.stats[key].file,\n            status: \"complete\",\n            result,\n            progress: 100,\n          };\n          const { [key]: _reader, ...readers } = state.readers;\n\n          return {\n            ...state,\n            readers,\n            stats: {\n              ...state.stats,\n              [key]: file,\n            },\n          };\n        }\n        case \"clearErrors\":\n          return { ...state, errors: [] };\n        default:\n          /* istanbul ignore next */\n          return state;\n      }\n    },\n    {\n      stats: EMPTY_OBJECT,\n      errors: EMPTY_LIST,\n      readers: EMPTY_OBJECT,\n    }\n  );\n  const { stats, errors, readers } = state;\n\n  const statsList = Object.values(stats);\n  const totalFiles = statsList.length;\n  const totalBytes = statsList.reduce(\n    (result, { file: { size } }) => result + size,\n    0\n  );\n  const queueFiles = useCallback(\n    (files: readonly File[]) => {\n      const { pending, errors } = validateFiles(files, {\n        maxFiles,\n        extensions,\n        minFileSize,\n        maxFileSize,\n        totalBytes,\n        totalFiles,\n        totalFileSize,\n        isValidFileName,\n      });\n\n      dispatch({ type: \"queue\", errors, files: pending });\n    },\n    [\n      validateFiles,\n      maxFiles,\n      extensions,\n      minFileSize,\n      maxFileSize,\n      totalBytes,\n      totalFiles,\n      totalFileSize,\n      isValidFileName,\n    ]\n  );\n  const onDrop = useCallback(\n    (event: DragEvent<E>) => {\n      propOnDrop?.(event);\n      event.preventDefault();\n      event.stopPropagation();\n\n      try {\n        const files = event.dataTransfer.files;\n        if (files) {\n          queueFiles(Array.from(files));\n        }\n      } catch (e) {\n        dispatch({\n          type: \"queue\",\n          files: [],\n          errors: [\n            new FileAccessError(e instanceof Error ? e.message : undefined),\n          ],\n        });\n      }\n    },\n    [queueFiles, propOnDrop]\n  );\n  const onChange = useCallback(\n    (event: ChangeEvent<HTMLInputElement>) => {\n      propOnChange?.(event);\n      try {\n        const files = event.currentTarget.files;\n        if (files) {\n          queueFiles(Array.from(files));\n        } else {\n          throw new Error();\n        }\n      } catch (e) {\n        dispatch({\n          type: \"queue\",\n          files: [],\n          errors: [\n            new FileAccessError(e instanceof Error ? e.message : undefined),\n          ],\n        });\n      }\n    },\n    [queueFiles, propOnChange]\n  );\n\n  const remove = useCallback(\n    (keyOrKeys: string | readonly string[]) => {\n      const files = typeof keyOrKeys === \"string\" ? [keyOrKeys] : keyOrKeys;\n      files.forEach((fileKey) => {\n        readers[fileKey]?.abort();\n      });\n\n      dispatch({ type: \"remove\", files });\n    },\n    [readers]\n  );\n  const reset = useCallback(() => {\n    Object.values(readers).forEach((reader) => {\n      reader.abort();\n    });\n\n    dispatch({ type: \"reset\" });\n  }, [readers]);\n  const clearErrors = useCallback(() => {\n    dispatch({ type: \"clearErrors\" });\n  }, []);\n  const start = useCallback((key: string, reader: FileReader) => {\n    dispatch({ type: \"start\", key, reader });\n  }, []);\n  const complete = useCallback(\n    (key: string, result: FileReaderResult = null) => {\n      dispatch({ type: \"complete\", key, result });\n    },\n    []\n  );\n  const createProgressEventHandler = useCallback(\n    (key: string) => (event: ProgressEvent) => {\n      if (event.lengthComputable) {\n        const percentage = Math.round((event.loaded * 100) / event.total);\n        dispatch({ type: \"progress\", key, progress: percentage });\n      }\n    },\n    []\n  );\n\n  useEffect(() => {\n    const pending: ProcessingFileUploadStats[] = [];\n    const uploading: ProcessingFileUploadStats[] = [];\n    Object.values(stats).forEach((file) => {\n      if (file.status === \"pending\") {\n        pending.push(file);\n      } else if (file.status === \"uploading\") {\n        uploading.push(file);\n      }\n    });\n\n    const lastIndex =\n      concurrency === -1\n        ? pending.length\n        : Math.max(0, concurrency - uploading.length);\n    const queue = pending.slice(0, lastIndex);\n    if (!queue.length) {\n      return;\n    }\n\n    queue.forEach((stats) => {\n      const { key, file } = stats;\n      const reader = new FileReader();\n\n      // using `addEventListener` instead of directly setting to\n      // `reader.progress`/`reader.load` so it's easier to test\n      reader.addEventListener(\"progress\", createProgressEventHandler(key));\n      reader.addEventListener(\"load\", () => {\n        complete(key, reader.result);\n      });\n\n      start(key, reader);\n      const parser = getFileParser(file);\n      /* istanbul ignore next */\n      if (\n        process.env.NODE_ENV !== \"production\" &&\n        ![\n          \"readAsText\",\n          \"readAsDataURL\",\n          \"readAsArrayBuffer\",\n          \"readAsBinaryString\",\n        ].includes(parser)\n      ) {\n        throw new Error(\"Invalid file reader parser\");\n      }\n\n      reader[parser](file);\n    });\n  }, [\n    concurrency,\n    stats,\n    getFileParser,\n    createProgressEventHandler,\n    start,\n    complete,\n  ]);\n\n  let accept = \"\";\n  if (extensions.length) {\n    accept = extensions.reduce((s, ext) => `${s ? `${s},` : \"\"}.${ext}`, \"\");\n  }\n\n  return {\n    stats: statsList,\n    errors,\n    accept,\n    totalBytes,\n    totalFiles,\n    onDrop,\n    onChange,\n    reset,\n    remove,\n    clearErrors,\n  };\n}\n"]},"metadata":{},"sourceType":"module"}