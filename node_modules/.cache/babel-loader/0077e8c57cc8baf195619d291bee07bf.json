{"ast":null,"code":"var __assign = this && this.__assign || function () {\n  __assign = Object.assign || function (t) {\n    for (var s, i = 1, n = arguments.length; i < n; i++) {\n      s = arguments[i];\n\n      for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p)) t[p] = s[p];\n    }\n\n    return t;\n  };\n\n  return __assign.apply(this, arguments);\n};\n\nvar __rest = this && this.__rest || function (s, e) {\n  var t = {};\n\n  for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0) t[p] = s[p];\n\n  if (s != null && typeof Object.getOwnPropertySymbols === \"function\") for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {\n    if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i])) t[p[i]] = s[p[i]];\n  }\n  return t;\n};\n\nvar __read = this && this.__read || function (o, n) {\n  var m = typeof Symbol === \"function\" && o[Symbol.iterator];\n  if (!m) return o;\n  var i = m.call(o),\n      r,\n      ar = [],\n      e;\n\n  try {\n    while ((n === void 0 || n-- > 0) && !(r = i.next()).done) ar.push(r.value);\n  } catch (error) {\n    e = {\n      error: error\n    };\n  } finally {\n    try {\n      if (r && !r.done && (m = i[\"return\"])) m.call(i);\n    } finally {\n      if (e) throw e.error;\n    }\n  }\n\n  return ar;\n};\n\nimport { useCallback, useEffect, useRef, useState } from \"react\";\nimport { applyRef, useDir, useIsomorphicLayoutEffect } from \"@react-md/utils\";\nimport { DEFAULT_SLIDER_ANIMATION_TIME } from \"./constants\";\nimport { getDragPercentage, getDragValue, isMouseEvent, isRangeSlider, isTouchEvent } from \"./utils\";\nvar VALID_KEYS = [\"ArrowDown\", \"ArrowUp\", \"ArrowLeft\", \"ArrowRight\", \"Home\", \"End\", \"PageUp\", \"PageDown\"];\n/**\n * This hook provides all the logic for updating the slider's when the user\n * interacts with the slider.\n *\n * @internal\n * @remarks \\@since 2.5.0\n */\n\nexport function useSliderControls(_a) {\n  var _b, _c;\n\n  var ref = _a.ref,\n      propThumb1Ref = _a.thumb1Ref,\n      propThumb2Ref = _a.thumb2Ref,\n      min = _a.min,\n      max = _a.max,\n      step = _a.step,\n      _d = _a.disabled,\n      disabled = _d === void 0 ? false : _d,\n      _e = _a.vertical,\n      vertical = _e === void 0 ? false : _e,\n      onBlur = _a.onBlur,\n      onKeyDown = _a.onKeyDown,\n      onMouseDown = _a.onMouseDown,\n      onTouchStart = _a.onTouchStart,\n      _f = _a.animationDuration,\n      animationDuration = _f === void 0 ? DEFAULT_SLIDER_ANIMATION_TIME : _f,\n      controls = __rest(_a, [\"ref\", \"thumb1Ref\", \"thumb2Ref\", \"min\", \"max\", \"step\", \"disabled\", \"vertical\", \"onBlur\", \"onKeyDown\", \"onMouseDown\", \"onTouchStart\", \"animationDuration\"]);\n\n  var trackRef = useRef(null);\n  var thumb1Ref = useRef(null);\n  var thumb2Ref = useRef(null);\n\n  var _g = __read(useState(false), 2),\n      dragging = _g[0],\n      setDragging = _g[1];\n\n  var _h = __read(useState(min), 2),\n      dragValue = _h[0],\n      setDragValue = _h[1];\n\n  var _j = __read(useState(null), 2),\n      draggingBy = _j[0],\n      setDraggingBy = _j[1];\n\n  var _k = __read(useState(null), 2),\n      draggingIndex = _k[0],\n      setDraggingIndex = _k[1];\n\n  var controlsRef = useRef(controls);\n  useIsomorphicLayoutEffect(function () {\n    controlsRef.current = controls;\n  });\n  var dir = useDir().dir;\n  var isRtl = dir === \"rtl\";\n  var thumb1Value;\n  var thumb1Percentage;\n  var thumb2Value;\n  var thumb2Percentage;\n\n  if (isRangeSlider(controls)) {\n    _b = __read(controls.value, 2), thumb1Value = _b[0], thumb2Value = _b[1];\n    _c = getDragPercentage({\n      min: min,\n      max: max,\n      thumb1Value: thumb1Value,\n      thumb2Value: thumb2Value,\n      dragging: dragging,\n      dragValue: dragValue,\n      draggingIndex: draggingIndex\n    }), thumb1Percentage = _c.thumb1Percentage, thumb2Percentage = _c.thumb2Percentage;\n  } else {\n    thumb1Value = controls.value;\n    thumb1Percentage = getDragPercentage({\n      min: min,\n      max: max,\n      thumb1Value: thumb1Value,\n      dragging: dragging,\n      dragValue: dragValue,\n      draggingIndex: draggingIndex\n    }).thumb1Percentage;\n  }\n  /**\n   * The main handler for updating the value of the slider. To help keep the\n   * drag experience smooth, some values are stored in refs to prevent the\n   * `useEffect` from being run during renders which adds and removes the move\n   * event handlers\n   */\n\n\n  var drag = useCallback(function (event) {\n    var track = trackRef.current;\n    var slider1 = thumb1Ref.current;\n    var slider2 = thumb2Ref.current;\n    var altKey = event.altKey,\n        ctrlKey = event.ctrlKey,\n        metaKey = event.metaKey,\n        shiftKey = event.shiftKey;\n\n    if (altKey || ctrlKey || metaKey || shiftKey || disabled || !track || !slider1 || isMouseEvent(event) && event.button !== 0 || isTouchEvent(event) && event.changedTouches.length !== 1 || !isMouseEvent(event) && !isTouchEvent(event)) {\n      return;\n    } // prevent text from being highlighted on desktop or the page from\n    // scrolling on mobile while dragging\n\n\n    if (!isTouchEvent(event) || event.type === \"touchmove\") {\n      event.preventDefault();\n    }\n\n    event.stopPropagation(); // get the current mouse/touch position to help determine hwo far the\n    // slider is being dragged\n\n    var clientX;\n    var clientY;\n\n    if (isMouseEvent(event)) {\n      clientX = event.clientX, clientY = event.clientY;\n    } else {\n      var touch = event.changedTouches[0];\n      clientX = touch.clientX, clientY = touch.clientY;\n    }\n\n    var index = 0;\n    var slider = slider1;\n\n    if (slider2) {\n      // if we aren't dragging yet, try to find the slider closest to the\n      // mouse/touch position and use that one\n      if (draggingIndex === null) {\n        var x1 = slider1.getBoundingClientRect().x;\n        var x2 = slider2.getBoundingClientRect().x;\n        var y1 = slider1.getBoundingClientRect().y;\n        var y2 = slider2.getBoundingClientRect().y;\n\n        if (vertical) {\n          index = Math.abs(clientY - y1) < Math.abs(clientY - y2) ? 0 : 1;\n        } else {\n          index = Math.abs(clientX - x1) < Math.abs(clientX - x2) ? 0 : 1;\n        }\n      } else {\n        index = draggingIndex;\n      }\n\n      slider = index === 0 ? slider1 : slider2;\n    } // if we aren't dragging yet, want to focus the slider element to make it\n    // easier to switch between mouse dragging and keyboard \"dragging\"\n\n\n    if (draggingIndex !== index) {\n      slider.focus();\n      setDraggingIndex(index);\n    }\n\n    setDraggingBy(isMouseEvent(event) ? \"mouse\" : \"touch\");\n\n    var _a = track.getBoundingClientRect(),\n        left = _a.left,\n        top = _a.top,\n        height = _a.height,\n        width = _a.width;\n\n    var options = {\n      min: min,\n      max: max,\n      step: step,\n      vertical: vertical,\n      clientX: clientX,\n      clientY: clientY,\n      left: left,\n      top: top,\n      height: height,\n      width: width,\n      isRtl: isRtl,\n      minValue: min,\n      maxValue: max\n    };\n    var controls = controlsRef.current;\n\n    if (isRangeSlider(controls)) {\n      var _b = __read(controls.value, 2),\n          thumb1Value_1 = _b[0],\n          thumb2Value_1 = _b[1];\n\n      var _c = getDragValue(__assign(__assign({}, options), {\n        minValue: index === 0 ? min : thumb1Value_1 + step,\n        maxValue: index === 1 ? max : thumb2Value_1 - step\n      })),\n          value = _c.value,\n          current = _c.current;\n\n      setDragValue(current);\n      controls.setValue(index === 0 ? [value, thumb2Value_1] : [thumb1Value_1, value]);\n    } else {\n      var _d = getDragValue(options),\n          value = _d.value,\n          current = _d.current;\n\n      setDragValue(current);\n      controls.setValue(value);\n    }\n  }, [disabled, isRtl, draggingIndex, max, min, step, vertical]);\n  var stop = useCallback(function () {\n    controlsRef.current.persist();\n    setDragging(false);\n    setDraggingIndex(null);\n    setDraggingBy(null);\n  }, []);\n  useEffect(function () {\n    if (draggingBy === null) {\n      return;\n    }\n\n    if (draggingBy === \"mouse\") {\n      window.addEventListener(\"mousemove\", drag);\n      window.addEventListener(\"mouseup\", stop);\n    } else {\n      window.addEventListener(\"touchmove\", drag, {\n        passive: false\n      });\n      window.addEventListener(\"touchend\", stop);\n    }\n\n    return function () {\n      if (draggingBy === \"mouse\") {\n        window.removeEventListener(\"mousemove\", drag);\n        window.removeEventListener(\"mouseup\", stop);\n      } else {\n        window.removeEventListener(\"touchmove\", drag);\n        window.removeEventListener(\"touchend\", stop);\n      }\n    };\n  }, [draggingBy, drag, stop]);\n  useEffect(function () {\n    if (draggingIndex === null && draggingBy === null) {\n      return;\n    } // I don't know how to reach this flow.. so maybe can be removed?\n\n    /* istanbul ignore if */\n\n\n    if (draggingIndex === null) {\n      setDragging(false);\n      return;\n    }\n\n    var timeout = window.setTimeout(function () {\n      setDragging(true);\n    }, animationDuration);\n    return function () {\n      window.clearTimeout(timeout);\n    };\n  }, [draggingIndex, draggingBy, animationDuration]);\n  var handleBlur = useCallback(function (event) {\n    if (onBlur) {\n      onBlur(event);\n    }\n\n    controlsRef.current.persist();\n  }, [onBlur]);\n  /**\n   * Note: this should be attached to the `SliderTrack` component.\n   */\n\n  var handleMouseDown = useCallback(function (event) {\n    if (onMouseDown) {\n      onMouseDown(event);\n    } // only call drag again when the dragging by isn't null since it can cause\n    // the \"drag\" events to be re-started if the mouse appears over the slider\n    // thumb again\n\n\n    if (draggingBy === null) {\n      drag(event);\n    }\n  }, [drag, draggingBy, onMouseDown]);\n  /**\n   * Note: this should be attached to the `SliderTrack` component.\n   */\n\n  var handleTouchStart = useCallback(function (event) {\n    if (onTouchStart) {\n      onTouchStart(event);\n    } // only call drag again when the dragging by isn't null since it can cause\n    // the \"drag\" events to be re-started if the user's finger appears over\n    // the slider thumb again\n\n\n    if (draggingBy === null) {\n      drag(event);\n    }\n  }, [drag, draggingBy, onTouchStart]);\n  /**\n   * Note: this should be attached to each `SliderThumb` component.\n   */\n\n  var handleKeyDown = useCallback(function (event) {\n    if (onKeyDown) {\n      onKeyDown(event);\n    }\n\n    var key = event.key,\n        altKey = event.altKey,\n        ctrlKey = event.ctrlKey,\n        metaKey = event.metaKey,\n        shiftKey = event.shiftKey;\n\n    if (altKey || ctrlKey || metaKey || shiftKey || disabled || !VALID_KEYS.includes(key)) {\n      return;\n    }\n\n    var controls;\n\n    if (isRangeSlider(controlsRef.current)) {\n      var _a = controlsRef.current,\n          increment_1 = _a.increment,\n          incrementJump_1 = _a.incrementJump,\n          decrement_1 = _a.decrement,\n          decrementJump_1 = _a.decrementJump,\n          minimum_1 = _a.minimum,\n          maximum_1 = _a.maximum;\n      var index = event.currentTarget === thumb2Ref.current ? 1 : 0;\n      controls = {\n        increment: increment_1.bind(null, index),\n        incrementJump: incrementJump_1.bind(null, index),\n        decrement: decrement_1.bind(null, index),\n        decrementJump: decrementJump_1.bind(null, index),\n        minimum: minimum_1.bind(null, index),\n        maximum: maximum_1.bind(null, index)\n      };\n    } else {\n      controls = controlsRef.current;\n    }\n\n    var increment = controls.increment,\n        incrementJump = controls.incrementJump,\n        decrement = controls.decrement,\n        decrementJump = controls.decrementJump,\n        minimum = controls.minimum,\n        maximum = controls.maximum;\n    event.preventDefault();\n    event.stopPropagation();\n\n    switch (key) {\n      case \"ArrowUp\":\n      case \"ArrowRight\":\n        increment();\n        break;\n\n      case \"ArrowDown\":\n      case \"ArrowLeft\":\n        decrement();\n        break;\n\n      case \"Home\":\n        minimum();\n        break;\n\n      case \"End\":\n        maximum();\n        break;\n\n      case \"PageUp\":\n        incrementJump();\n        break;\n\n      case \"PageDown\":\n        decrementJump();\n        break;\n    }\n  }, [onKeyDown, disabled]);\n  var trackRefHandler = useCallback(function (instance) {\n    applyRef(instance, ref);\n    trackRef.current = instance;\n  }, [ref]);\n  var thumb1RefHandler = useCallback(function (instance) {\n    applyRef(instance, propThumb1Ref);\n    thumb1Ref.current = instance;\n  }, [propThumb1Ref]);\n  var thumb2RefHandler = useCallback(function (instance) {\n    applyRef(instance, propThumb2Ref);\n    thumb2Ref.current = instance;\n  }, [propThumb2Ref]);\n  return {\n    thumb1Ref: thumb1RefHandler,\n    thumb1Value: thumb1Value,\n    thumb1Percentage: thumb1Percentage,\n    thumb2Ref: thumb2RefHandler,\n    thumb2Value: thumb2Value,\n    thumb2Percentage: thumb2Percentage,\n    dragging: dragging,\n    draggingIndex: draggingIndex,\n    ref: trackRefHandler,\n    onBlur: handleBlur,\n    onKeyDown: handleKeyDown,\n    onMouseDown: handleMouseDown,\n    onTouchStart: handleTouchStart\n  };\n}","map":{"version":3,"mappings":"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","names":["useCallback","useEffect","useRef","useState","applyRef","useDir","useIsomorphicLayoutEffect","DEFAULT_SLIDER_ANIMATION_TIME","getDragPercentage","getDragValue","isMouseEvent","isRangeSlider","isTouchEvent","VALID_KEYS","useSliderControls","_a","propThumb1Ref","propThumb2Ref","min","max","step","_d","disabled","_e","vertical","onBlur","onKeyDown","onMouseDown","onTouchStart","_f","animationDuration","controls","trackRef","thumb1Ref","thumb2Ref","dragging","setDragging","dragValue","setDragValue","draggingBy","setDraggingBy","draggingIndex","setDraggingIndex","controlsRef","current","dir","isRtl","thumb1Value","thumb1Percentage","thumb2Value","thumb2Percentage","_b","value","_c","drag","event","track","slider1","slider2","ctrlKey","metaKey","shiftKey","altKey","button","changedTouches","length","type","preventDefault","stopPropagation","clientX","clientY","touch","index","slider","x1","getBoundingClientRect","x","x2","y1","y","y2","Math","abs","focus","left","top","height","width","options","minValue","maxValue","thumb1Value_1","thumb2Value_1","setValue","stop","persist","window","addEventListener","passive","removeEventListener","timeout","setTimeout","clearTimeout","handleBlur","handleMouseDown","handleTouchStart","handleKeyDown","includes","key","increment_1","incrementJump_1","decrement_1","decrementJump_1","minimum_1","maximum_1","currentTarget","increment","bind","incrementJump","decrement","decrementJump","minimum","maximum","trackRefHandler","instance","ref","thumb1RefHandler","thumb2RefHandler"],"sources":["C:\\Users\\hungr\\Documents\\VS-CODE\\notes-react\\node_modules\\@react-md\\form\\src\\slider\\useSliderControls.ts"],"sourcesContent":["import type {\n  KeyboardEventHandler,\n  MouseEventHandler,\n  FocusEventHandler,\n  Ref,\n  RefCallback,\n  TouchEventHandler,\n} from \"react\";\nimport { useCallback, useEffect, useRef, useState } from \"react\";\nimport { applyRef, useDir, useIsomorphicLayoutEffect } from \"@react-md/utils\";\n\nimport { DEFAULT_SLIDER_ANIMATION_TIME } from \"./constants\";\nimport type {\n  DefinedSliderValueOptions,\n  SliderControls,\n  SliderDragEvent,\n  SliderDraggingBy,\n  SliderEventHandlers,\n  SliderPresentation,\n  SliderThumbIndex,\n  ThumbIndex,\n} from \"./types\";\nimport type { CombinedSliderControls, SliderDragValues } from \"./utils\";\nimport {\n  getDragPercentage,\n  getDragValue,\n  isMouseEvent,\n  isRangeSlider,\n  isTouchEvent,\n} from \"./utils\";\n\n/**\n * @internal\n * @remarks \\@since 2.5.0\n */\nexport type SliderControlsOptions = CombinedSliderControls &\n  SliderPresentation &\n  SliderEventHandlers &\n  DefinedSliderValueOptions & {\n    ref?: Ref<HTMLSpanElement | null>;\n    thumb1Ref?: Ref<HTMLSpanElement | null>;\n    thumb2Ref?: Ref<HTMLSpanElement | null>;\n    animationDuration?: number;\n  };\n\nconst VALID_KEYS = [\n  \"ArrowDown\",\n  \"ArrowUp\",\n  \"ArrowLeft\",\n  \"ArrowRight\",\n  \"Home\",\n  \"End\",\n  \"PageUp\",\n  \"PageDown\",\n];\n\n/**\n * @internal\n * @remarks \\@since 2.5.0\n */\nexport interface SliderAndRangeSliderControls {\n  thumb1Ref: RefCallback<HTMLSpanElement | null>;\n  thumb1Value: number;\n  thumb1Percentage: string;\n  thumb2Ref: RefCallback<HTMLSpanElement | null>;\n  thumb2Value?: number;\n  thumb2Percentage?: string;\n  dragging: boolean;\n  draggingIndex: SliderThumbIndex;\n  ref: RefCallback<HTMLSpanElement | null>;\n  onBlur: FocusEventHandler<HTMLSpanElement>;\n  onKeyDown: KeyboardEventHandler<HTMLSpanElement>;\n  onMouseDown: MouseEventHandler<HTMLSpanElement>;\n  onTouchStart: TouchEventHandler<HTMLSpanElement>;\n}\n\n/**\n * This hook provides all the logic for updating the slider's when the user\n * interacts with the slider.\n *\n * @internal\n * @remarks \\@since 2.5.0\n */\nexport function useSliderControls({\n  ref,\n  thumb1Ref: propThumb1Ref,\n  thumb2Ref: propThumb2Ref,\n  min,\n  max,\n  step,\n  disabled = false,\n  vertical = false,\n  onBlur,\n  onKeyDown,\n  onMouseDown,\n  onTouchStart,\n  animationDuration = DEFAULT_SLIDER_ANIMATION_TIME,\n  ...controls\n}: SliderControlsOptions): SliderAndRangeSliderControls {\n  const trackRef = useRef<HTMLSpanElement | null>(null);\n  const thumb1Ref = useRef<HTMLSpanElement | null>(null);\n  const thumb2Ref = useRef<HTMLSpanElement | null>(null);\n  const [dragging, setDragging] = useState(false);\n  const [dragValue, setDragValue] = useState<number>(min);\n  const [draggingBy, setDraggingBy] = useState<SliderDraggingBy>(null);\n  const [draggingIndex, setDraggingIndex] = useState<SliderThumbIndex>(null);\n  const controlsRef = useRef(controls);\n  useIsomorphicLayoutEffect(() => {\n    controlsRef.current = controls;\n  });\n\n  const { dir } = useDir();\n  const isRtl = dir === \"rtl\";\n\n  let thumb1Value: number;\n  let thumb1Percentage: string;\n  let thumb2Value: number | undefined;\n  let thumb2Percentage: string | undefined;\n  if (isRangeSlider(controls)) {\n    [thumb1Value, thumb2Value] = controls.value;\n    ({ thumb1Percentage, thumb2Percentage } = getDragPercentage({\n      min,\n      max,\n      thumb1Value,\n      thumb2Value,\n      dragging,\n      dragValue,\n      draggingIndex,\n    }));\n  } else {\n    thumb1Value = controls.value;\n    ({ thumb1Percentage } = getDragPercentage({\n      min,\n      max,\n      thumb1Value,\n      dragging,\n      dragValue,\n      draggingIndex,\n    }));\n  }\n\n  /**\n   * The main handler for updating the value of the slider. To help keep the\n   * drag experience smooth, some values are stored in refs to prevent the\n   * `useEffect` from being run during renders which adds and removes the move\n   * event handlers\n   */\n  const drag = useCallback(\n    (event: SliderDragEvent) => {\n      const track = trackRef.current;\n      const slider1 = thumb1Ref.current;\n      const slider2 = thumb2Ref.current;\n      const { altKey, ctrlKey, metaKey, shiftKey } = event;\n      if (\n        altKey ||\n        ctrlKey ||\n        metaKey ||\n        shiftKey ||\n        disabled ||\n        !track ||\n        !slider1 ||\n        (isMouseEvent(event) && event.button !== 0) ||\n        (isTouchEvent(event) && event.changedTouches.length !== 1) ||\n        (!isMouseEvent(event) && !isTouchEvent(event))\n      ) {\n        return;\n      }\n\n      // prevent text from being highlighted on desktop or the page from\n      // scrolling on mobile while dragging\n      if (!isTouchEvent(event) || event.type === \"touchmove\") {\n        event.preventDefault();\n      }\n      event.stopPropagation();\n\n      // get the current mouse/touch position to help determine hwo far the\n      // slider is being dragged\n      let clientX: number;\n      let clientY: number;\n      if (isMouseEvent(event)) {\n        ({ clientX, clientY } = event);\n      } else {\n        const touch = event.changedTouches[0];\n        ({ clientX, clientY } = touch);\n      }\n\n      let index: ThumbIndex = 0;\n      let slider: HTMLSpanElement = slider1;\n      if (slider2) {\n        // if we aren't dragging yet, try to find the slider closest to the\n        // mouse/touch position and use that one\n        if (draggingIndex === null) {\n          const x1 = slider1.getBoundingClientRect().x;\n          const x2 = slider2.getBoundingClientRect().x;\n          const y1 = slider1.getBoundingClientRect().y;\n          const y2 = slider2.getBoundingClientRect().y;\n          if (vertical) {\n            index = Math.abs(clientY - y1) < Math.abs(clientY - y2) ? 0 : 1;\n          } else {\n            index = Math.abs(clientX - x1) < Math.abs(clientX - x2) ? 0 : 1;\n          }\n        } else {\n          index = draggingIndex;\n        }\n\n        slider = index === 0 ? slider1 : slider2;\n      }\n\n      // if we aren't dragging yet, want to focus the slider element to make it\n      // easier to switch between mouse dragging and keyboard \"dragging\"\n      if (draggingIndex !== index) {\n        slider.focus();\n        setDraggingIndex(index);\n      }\n\n      setDraggingBy(isMouseEvent(event) ? \"mouse\" : \"touch\");\n\n      const { left, top, height, width } = track.getBoundingClientRect();\n      const options: SliderDragValues = {\n        min,\n        max,\n        step,\n        vertical,\n        clientX,\n        clientY,\n        left,\n        top,\n        height,\n        width,\n        isRtl,\n        minValue: min,\n        maxValue: max,\n      };\n\n      const controls = controlsRef.current;\n      if (isRangeSlider(controls)) {\n        const [thumb1Value, thumb2Value] = controls.value;\n        const { value, current } = getDragValue({\n          ...options,\n          minValue: index === 0 ? min : thumb1Value + step,\n          maxValue: index === 1 ? max : thumb2Value - step,\n        });\n        setDragValue(current);\n        controls.setValue(\n          index === 0 ? [value, thumb2Value] : [thumb1Value, value]\n        );\n      } else {\n        const { value, current } = getDragValue(options);\n        setDragValue(current);\n        controls.setValue(value);\n      }\n    },\n    [disabled, isRtl, draggingIndex, max, min, step, vertical]\n  );\n  const stop = useCallback(() => {\n    controlsRef.current.persist();\n    setDragging(false);\n    setDraggingIndex(null);\n    setDraggingBy(null);\n  }, []);\n\n  useEffect(() => {\n    if (draggingBy === null) {\n      return;\n    }\n\n    if (draggingBy === \"mouse\") {\n      window.addEventListener(\"mousemove\", drag);\n      window.addEventListener(\"mouseup\", stop);\n    } else {\n      window.addEventListener(\"touchmove\", drag, { passive: false });\n      window.addEventListener(\"touchend\", stop);\n    }\n\n    return () => {\n      if (draggingBy === \"mouse\") {\n        window.removeEventListener(\"mousemove\", drag);\n        window.removeEventListener(\"mouseup\", stop);\n      } else {\n        window.removeEventListener(\"touchmove\", drag);\n        window.removeEventListener(\"touchend\", stop);\n      }\n    };\n  }, [draggingBy, drag, stop]);\n\n  useEffect(() => {\n    if (draggingIndex === null && draggingBy === null) {\n      return;\n    }\n\n    // I don't know how to reach this flow.. so maybe can be removed?\n    /* istanbul ignore if */\n    if (draggingIndex === null) {\n      setDragging(false);\n      return;\n    }\n\n    const timeout = window.setTimeout(() => {\n      setDragging(true);\n    }, animationDuration);\n\n    return () => {\n      window.clearTimeout(timeout);\n    };\n  }, [draggingIndex, draggingBy, animationDuration]);\n\n  const handleBlur = useCallback<FocusEventHandler<HTMLSpanElement>>(\n    (event) => {\n      if (onBlur) {\n        onBlur(event);\n      }\n\n      controlsRef.current.persist();\n    },\n    [onBlur]\n  );\n\n  /**\n   * Note: this should be attached to the `SliderTrack` component.\n   */\n  const handleMouseDown = useCallback<MouseEventHandler<HTMLSpanElement>>(\n    (event) => {\n      if (onMouseDown) {\n        onMouseDown(event);\n      }\n\n      // only call drag again when the dragging by isn't null since it can cause\n      // the \"drag\" events to be re-started if the mouse appears over the slider\n      // thumb again\n      if (draggingBy === null) {\n        drag(event);\n      }\n    },\n    [drag, draggingBy, onMouseDown]\n  );\n\n  /**\n   * Note: this should be attached to the `SliderTrack` component.\n   */\n  const handleTouchStart = useCallback<TouchEventHandler<HTMLSpanElement>>(\n    (event) => {\n      if (onTouchStart) {\n        onTouchStart(event);\n      }\n\n      // only call drag again when the dragging by isn't null since it can cause\n      // the \"drag\" events to be re-started if the user's finger appears over\n      // the slider thumb again\n      if (draggingBy === null) {\n        drag(event);\n      }\n    },\n    [drag, draggingBy, onTouchStart]\n  );\n\n  /**\n   * Note: this should be attached to each `SliderThumb` component.\n   */\n  const handleKeyDown = useCallback<KeyboardEventHandler<HTMLSpanElement>>(\n    (event) => {\n      if (onKeyDown) {\n        onKeyDown(event);\n      }\n\n      const { key, altKey, ctrlKey, metaKey, shiftKey } = event;\n      if (\n        altKey ||\n        ctrlKey ||\n        metaKey ||\n        shiftKey ||\n        disabled ||\n        !VALID_KEYS.includes(key)\n      ) {\n        return;\n      }\n\n      let controls: Omit<SliderControls, \"setValue\" | \"value\" | \"persist\">;\n      if (isRangeSlider(controlsRef.current)) {\n        const {\n          increment,\n          incrementJump,\n          decrement,\n          decrementJump,\n          minimum,\n          maximum,\n        } = controlsRef.current;\n        const index = event.currentTarget === thumb2Ref.current ? 1 : 0;\n        controls = {\n          increment: increment.bind(null, index),\n          incrementJump: incrementJump.bind(null, index),\n          decrement: decrement.bind(null, index),\n          decrementJump: decrementJump.bind(null, index),\n          minimum: minimum.bind(null, index),\n          maximum: maximum.bind(null, index),\n        };\n      } else {\n        controls = controlsRef.current;\n      }\n\n      const {\n        increment,\n        incrementJump,\n        decrement,\n        decrementJump,\n        minimum,\n        maximum,\n      } = controls;\n      event.preventDefault();\n      event.stopPropagation();\n      switch (key) {\n        case \"ArrowUp\":\n        case \"ArrowRight\":\n          increment();\n          break;\n        case \"ArrowDown\":\n        case \"ArrowLeft\":\n          decrement();\n          break;\n        case \"Home\":\n          minimum();\n          break;\n        case \"End\":\n          maximum();\n          break;\n        case \"PageUp\":\n          incrementJump();\n          break;\n        case \"PageDown\":\n          decrementJump();\n          break;\n      }\n    },\n    [onKeyDown, disabled]\n  );\n\n  const trackRefHandler = useCallback(\n    (instance: HTMLSpanElement | null) => {\n      applyRef(instance, ref);\n      trackRef.current = instance;\n    },\n    [ref]\n  );\n\n  const thumb1RefHandler = useCallback(\n    (instance: HTMLSpanElement | null) => {\n      applyRef(instance, propThumb1Ref);\n      thumb1Ref.current = instance;\n    },\n    [propThumb1Ref]\n  );\n\n  const thumb2RefHandler = useCallback(\n    (instance: HTMLSpanElement | null) => {\n      applyRef(instance, propThumb2Ref);\n      thumb2Ref.current = instance;\n    },\n    [propThumb2Ref]\n  );\n\n  return {\n    thumb1Ref: thumb1RefHandler,\n    thumb1Value,\n    thumb1Percentage,\n    thumb2Ref: thumb2RefHandler,\n    thumb2Value,\n    thumb2Percentage,\n    dragging,\n    draggingIndex,\n    ref: trackRefHandler,\n    onBlur: handleBlur,\n    onKeyDown: handleKeyDown,\n    onMouseDown: handleMouseDown,\n    onTouchStart: handleTouchStart,\n  };\n}\n"]},"metadata":{},"sourceType":"module"}