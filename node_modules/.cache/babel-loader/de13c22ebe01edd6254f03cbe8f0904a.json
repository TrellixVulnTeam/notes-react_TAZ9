{"ast":null,"code":"var __read = this && this.__read || function (o, n) {\n  var m = typeof Symbol === \"function\" && o[Symbol.iterator];\n  if (!m) return o;\n  var i = m.call(o),\n      r,\n      ar = [],\n      e;\n\n  try {\n    while ((n === void 0 || n-- > 0) && !(r = i.next()).done) ar.push(r.value);\n  } catch (error) {\n    e = {\n      error: error\n    };\n  } finally {\n    try {\n      if (r && !r.done && (m = i[\"return\"])) m.call(i);\n    } finally {\n      if (e) throw e.error;\n    }\n  }\n\n  return ar;\n};\n\nimport { useCallback, useEffect, useMemo, useRef, useState } from \"react\";\nimport { nearest } from \"@react-md/utils\";\nimport { DEFAULT_SLIDER_MAX, DEFAULT_SLIDER_MIN, DEFAULT_SLIDER_STEP } from \"./constants\";\nimport { getJumpValue, getSteps } from \"./utils\";\n\nvar noop = function () {// do nothing\n};\n/**\n * This hook is used to control the value and behavior of the `Slider`\n * component. The first argument will contain the current slider value while\n * the second argument will be all the props required to control the `Slider`\n * component.\n *\n * @param defaultValue - An optional default value to use for the slider. This\n * will default to the `min` option when undefined.\n * @param options - An object containing the `min` and `max` values allowed for\n * the slider as well as a `step` to indicate valid values between the `min` and\n * `max`.\n * @returns an ordered list containing the current value followed by the\n * `Slider` props\n * @remarks \\@since 2.5.0\n */\n\n\nexport function useSlider(defaultValue, _a) {\n  var _b = _a === void 0 ? {} : _a,\n      _c = _b.min,\n      min = _c === void 0 ? DEFAULT_SLIDER_MIN : _c,\n      _d = _b.max,\n      max = _d === void 0 ? DEFAULT_SLIDER_MAX : _d,\n      _e = _b.step,\n      step = _e === void 0 ? DEFAULT_SLIDER_STEP : _e,\n      propJump = _b.jump,\n      _f = _b.updateOn,\n      updateOn = _f === void 0 ? \"change\" : _f,\n      _g = _b.onChange,\n      onChange = _g === void 0 ? noop : _g;\n\n  var jump = useMemo(function () {\n    return getJumpValue(min, max, step, propJump);\n  }, [min, max, step, propJump]); // since the `currentValue` is a ref, this state is used to force a re-render\n  // to get the updated value from the ref.\n\n  var _h = __read(useState([]), 2),\n      hack = _h[1];\n\n  var _j = __read(useState(defaultValue !== null && defaultValue !== void 0 ? defaultValue : min), 2),\n      value = _j[0],\n      setValue = _j[1];\n\n  var currentValue = useRef(value);\n  var increment = useCallback(function () {\n    setValue(function (prevValue) {\n      return Math.max(min, Math.min(max, prevValue + step));\n    });\n  }, [min, max, step]);\n  var incrementJump = useCallback(function () {\n    setValue(function (prevValue) {\n      return Math.max(min, Math.min(max, prevValue + jump));\n    });\n  }, [min, max, jump]);\n  var decrement = useCallback(function () {\n    setValue(function (prevValue) {\n      return Math.max(min, Math.min(max, prevValue - step));\n    });\n  }, [min, max, step]);\n  var decrementJump = useCallback(function () {\n    setValue(function (prevValue) {\n      return Math.max(min, Math.min(max, prevValue - jump));\n    });\n  }, [min, max, jump]);\n  var minimum = useCallback(function () {\n    setValue(min);\n  }, [min]);\n  var maximum = useCallback(function () {\n    setValue(max);\n  }, [max]);\n  var persist = useCallback(function () {\n    if (currentValue.current === value) {\n      return;\n    }\n\n    onChange(value);\n    currentValue.current = value;\n    hack([]);\n  }, [onChange, value]);\n  var prev = useRef({\n    min: min,\n    max: max,\n    step: step\n  });\n  useEffect(function () {\n    if (prev.current.min !== min || prev.current.max !== max || prev.current.step !== step) {\n      // ensure that if the `min`, `max`, or `step` value changes that the value\n      // is updated as well. Without this, there will be a runtime error if the\n      // value is not within the new range.\n      prev.current = {\n        min: min,\n        max: max,\n        step: step\n      };\n      var nextValue = nearest(value, min, max, getSteps(min, max, step));\n      currentValue.current = nextValue;\n      setValue(nextValue);\n    }\n  }, [min, max, step, value]);\n\n  if (updateOn === \"change\" && currentValue.current !== value) {\n    currentValue.current = value;\n  }\n\n  return [currentValue.current, {\n    min: min,\n    max: max,\n    step: step,\n    value: value,\n    increment: increment,\n    incrementJump: incrementJump,\n    decrement: decrement,\n    decrementJump: decrementJump,\n    minimum: minimum,\n    maximum: maximum,\n    persist: persist,\n    setValue: setValue\n  }];\n}","map":{"version":3,"mappings":"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","names":["useCallback","useEffect","useMemo","useRef","useState","nearest","DEFAULT_SLIDER_MAX","DEFAULT_SLIDER_MIN","DEFAULT_SLIDER_STEP","getJumpValue","getSteps","noop","useSlider","defaultValue","_a","_b","_c","min","_d","max","_e","step","propJump","_f","updateOn","_g","onChange","jump","hack","value","setValue","currentValue","increment","prevValue","Math","incrementJump","decrement","decrementJump","minimum","maximum","persist","current","prev","nextValue"],"sources":["C:\\Users\\hungr\\Documents\\VS-CODE\\notes-react\\node_modules\\@react-md\\form\\src\\slider\\useSlider.ts"],"sourcesContent":["import { useCallback, useEffect, useMemo, useRef, useState } from \"react\";\nimport { nearest } from \"@react-md/utils\";\n\nimport {\n  DEFAULT_SLIDER_MAX,\n  DEFAULT_SLIDER_MIN,\n  DEFAULT_SLIDER_STEP,\n} from \"./constants\";\nimport type {\n  DefinedSliderValueOptions,\n  SliderControls,\n  SliderDefaultValue,\n  SliderValue,\n  SliderStepOptions,\n} from \"./types\";\nimport { getJumpValue, getSteps } from \"./utils\";\n\n/**\n * @remarks \\@since 2.5.0\n */\nexport interface SliderRequiredProps\n  extends SliderControls,\n    DefinedSliderValueOptions {\n  /**\n   * The current value of the slider.\n   */\n  value: SliderValue;\n}\n\nconst noop = (): void => {\n  // do nothing\n};\n\n/**\n * @remarks \\@since 2.5.0\n */\nexport type SliderValueReturnType = readonly [SliderValue, SliderRequiredProps];\n\n/**\n * @remarks \\@since 2.5.0\n */\nexport interface UseSliderOptions extends SliderStepOptions {\n  /**\n   * An optional callback that will be triggered when the value has changed when\n   * the `updateOn` behavior is set to `\"blur\"`. When the `updateOn` behavior is\n   * set to `\"change\"` (default), this will do nothing since the return value\n   * from the hook will always be the latest value.\n   */\n  onChange?(value: SliderValue): void;\n}\n\n/**\n * This hook is used to control the value and behavior of the `Slider`\n * component. The first argument will contain the current slider value while\n * the second argument will be all the props required to control the `Slider`\n * component.\n *\n * @param defaultValue - An optional default value to use for the slider. This\n * will default to the `min` option when undefined.\n * @param options - An object containing the `min` and `max` values allowed for\n * the slider as well as a `step` to indicate valid values between the `min` and\n * `max`.\n * @returns an ordered list containing the current value followed by the\n * `Slider` props\n * @remarks \\@since 2.5.0\n */\nexport function useSlider(\n  defaultValue?: SliderDefaultValue,\n  {\n    min = DEFAULT_SLIDER_MIN,\n    max = DEFAULT_SLIDER_MAX,\n    step = DEFAULT_SLIDER_STEP,\n    jump: propJump,\n    updateOn = \"change\",\n    onChange = noop,\n  }: UseSliderOptions = {}\n): SliderValueReturnType {\n  const jump = useMemo(\n    () => getJumpValue(min, max, step, propJump),\n    [min, max, step, propJump]\n  );\n\n  // since the `currentValue` is a ref, this state is used to force a re-render\n  // to get the updated value from the ref.\n  const [, hack] = useState([]);\n  const [value, setValue] = useState(defaultValue ?? min);\n  const currentValue = useRef(value);\n\n  const increment = useCallback(() => {\n    setValue((prevValue) => Math.max(min, Math.min(max, prevValue + step)));\n  }, [min, max, step]);\n  const incrementJump = useCallback(() => {\n    setValue((prevValue) => Math.max(min, Math.min(max, prevValue + jump)));\n  }, [min, max, jump]);\n  const decrement = useCallback(() => {\n    setValue((prevValue) => Math.max(min, Math.min(max, prevValue - step)));\n  }, [min, max, step]);\n  const decrementJump = useCallback(() => {\n    setValue((prevValue) => Math.max(min, Math.min(max, prevValue - jump)));\n  }, [min, max, jump]);\n  const minimum = useCallback(() => {\n    setValue(min);\n  }, [min]);\n  const maximum = useCallback(() => {\n    setValue(max);\n  }, [max]);\n\n  const persist = useCallback(() => {\n    if (currentValue.current === value) {\n      return;\n    }\n\n    onChange(value);\n    currentValue.current = value;\n    hack([]);\n  }, [onChange, value]);\n\n  const prev = useRef({ min, max, step });\n  useEffect(() => {\n    if (\n      prev.current.min !== min ||\n      prev.current.max !== max ||\n      prev.current.step !== step\n    ) {\n      // ensure that if the `min`, `max`, or `step` value changes that the value\n      // is updated as well. Without this, there will be a runtime error if the\n      // value is not within the new range.\n      prev.current = { min, max, step };\n      const nextValue = nearest(value, min, max, getSteps(min, max, step));\n      currentValue.current = nextValue;\n      setValue(nextValue);\n    }\n  }, [min, max, step, value]);\n\n  if (updateOn === \"change\" && currentValue.current !== value) {\n    currentValue.current = value;\n  }\n\n  return [\n    currentValue.current,\n    {\n      min,\n      max,\n      step,\n      value,\n      increment,\n      incrementJump,\n      decrement,\n      decrementJump,\n      minimum,\n      maximum,\n      persist,\n      setValue,\n    },\n  ];\n}\n"]},"metadata":{},"sourceType":"module"}