{"ast":null,"code":"import { BELOW_CENTER_ANCHOR } from \"./constants\";\nimport { createHorizontalPosition } from \"./createHorizontalPosition\";\nimport { createVerticalPosition } from \"./createVerticalPosition\";\nimport { findSizingContainer } from \"./findSizingContainer\";\nimport { getElementRect } from \"./getElementRect\";\nimport { getTransformOrigin } from \"./getTransformOrigin\";\nimport { getViewportSize } from \"./getViewportSize\";\n/**\n * This is used when there is no `container` element so that some styles can\n * still be created. The main use-case for this is context menus and when the\n * `initialX` and `initialY` options have been provided.\n *\n * @internal\n * @remarks \\@since 5.0.0\n */\n\nvar FALLBACK_DOM_RECT = {\n  x: 0,\n  y: 0,\n  height: 0,\n  width: 0,\n  left: 0,\n  right: 0,\n  top: 0,\n  bottom: 0,\n  toJSON: function () {// do nothing\n  }\n};\n/**\n * One of the most complicated functions in this project that will attempt to\n * position an element relative to another container element while still being\n * visible within the viewport. Below is the logical flow for attempting to fix\n * the element to the container:\n *\n * No Container: If there is no container element, return the provided x and y\n * positions and no styles since there's nothing we can use to calculate the\n * position.\n *\n * No Element: If the container was provided but the element to position does\n * not exist, return an style object containing the `left` and `top` values for\n * the container and apply as many of the positioning options as possible so\n * that the styles are \"as close as possible\" before the fixed element is added\n * to the DOM. This will also return the provided x and y positions since\n * nothing could be swapped around yet.\n *\n * Container and Element: If both the container and fixed element were provided,\n * apply all the positioning options to the `left` and `top` values of the\n * container based on the sizes of both elements.\n *\n * Now that the `left` and `top` values were applied, check to see if the\n * element is fully visible within the viewport with the provided positioning\n * options. If it is fully visible, do nothing else. If it isn't... follow the\n * next flow:\n *\n * First, check the horizontal sizes and make sure that the element is still\n * within the viewport with the provided viewwidth margin. If it isn't, first\n * try to swap only to a `right` style instead of left to see if that fixes it,\n * otherwise keep both the `left` and `right` styles.\n */\n\nexport function getFixedPosition(_a) {\n  var _b;\n\n  var container = _a.container,\n      element = _a.element,\n      _c = _a.anchor,\n      anchor = _c === void 0 ? BELOW_CENTER_ANCHOR : _c,\n      initialX = _a.initialX,\n      initialY = _a.initialY,\n      _d = _a.vwMargin,\n      vwMargin = _d === void 0 ? 16 : _d,\n      _e = _a.vhMargin,\n      vhMargin = _e === void 0 ? 16 : _e,\n      _f = _a.xMargin,\n      xMargin = _f === void 0 ? 0 : _f,\n      _g = _a.yMargin,\n      yMargin = _g === void 0 ? 0 : _g,\n      _h = _a.width,\n      widthType = _h === void 0 ? \"auto\" : _h,\n      _j = _a.preventOverlap,\n      preventOverlap = _j === void 0 ? false : _j,\n      _k = _a.transformOrigin,\n      transformOrigin = _k === void 0 ? false : _k,\n      _l = _a.disableSwapping,\n      propDisableSwapping = _l === void 0 ? false : _l,\n      _m = _a.disableVHBounds,\n      disableVHBounds = _m === void 0 ? false : _m;\n  container = findSizingContainer(container);\n\n  if (process.env.NODE_ENV !== \"production\") {\n    if (widthType !== \"auto\" && anchor.x !== \"center\") {\n      throw new Error('Unable to use a calculated width when the horizontal anchor is not `\"center\"`.');\n    }\n\n    if (preventOverlap && anchor.y !== \"above\" && anchor.y !== \"below\") {\n      throw new Error('Unable to prevent overlap when the vertical anchor is not `\"above\"` or `\"below\"`');\n    }\n  }\n\n  if (!element) {\n    return {\n      actualX: anchor.x,\n      actualY: anchor.y\n    };\n  }\n\n  var containerRect = (_b = container === null || container === void 0 ? void 0 : container.getBoundingClientRect()) !== null && _b !== void 0 ? _b : FALLBACK_DOM_RECT;\n  var vh = getViewportSize(\"height\");\n  var vw = getViewportSize(\"width\");\n\n  var _o = getElementRect(element),\n      height = _o.height,\n      elWidth = _o.width;\n\n  if (disableVHBounds) {\n    var dialog = element.closest(\"[role='dialog']\");\n\n    if (!dialog) {\n      initialY = (initialY !== null && initialY !== void 0 ? initialY : 0) + window.scrollY;\n    }\n  }\n\n  var disableSwapping = propDisableSwapping || !container;\n\n  var _p = createHorizontalPosition({\n    x: anchor.x,\n    vw: vw,\n    vwMargin: vwMargin,\n    xMargin: xMargin,\n    width: widthType,\n    elWidth: elWidth,\n    initialX: initialX,\n    containerRect: containerRect,\n    disableSwapping: disableSwapping\n  }),\n      left = _p.left,\n      right = _p.right,\n      width = _p.width,\n      minWidth = _p.minWidth,\n      actualX = _p.actualX;\n\n  var _q = createVerticalPosition({\n    y: anchor.y,\n    vh: vh,\n    vhMargin: vhMargin,\n    yMargin: yMargin,\n    initialY: initialY,\n    elHeight: height,\n    containerRect: containerRect,\n    disableSwapping: disableSwapping,\n    preventOverlap: preventOverlap,\n    disableVHBounds: disableVHBounds\n  }),\n      top = _q.top,\n      bottom = _q.bottom,\n      actualY = _q.actualY;\n\n  return {\n    actualX: actualX,\n    actualY: actualY,\n    style: {\n      left: left,\n      top: top,\n      right: right,\n      bottom: bottom,\n      width: width,\n      minWidth: minWidth,\n      position: disableVHBounds ? \"absolute\" : \"fixed\",\n      transformOrigin: transformOrigin ? getTransformOrigin({\n        x: actualX,\n        y: actualY\n      }) : undefined\n    }\n  };\n}","map":{"version":3,"mappings":"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","names":["BELOW_CENTER_ANCHOR","createHorizontalPosition","createVerticalPosition","findSizingContainer","getElementRect","getTransformOrigin","getViewportSize","FALLBACK_DOM_RECT","x","y","height","width","left","right","top","bottom","toJSON","getFixedPosition","_a","container","element","_c","anchor","initialX","initialY","_d","vwMargin","_e","vhMargin","_f","xMargin","_g","yMargin","_h","widthType","_j","preventOverlap","_k","transformOrigin","_l","propDisableSwapping","_m","disableVHBounds","process","env","NODE_ENV","Error","actualX","actualY","containerRect","getBoundingClientRect","_b","vh","vw","elWidth","dialog","closest","window","scrollY","disableSwapping","minWidth","elHeight","style","position","undefined"],"sources":["C:\\Users\\hungr\\Documents\\VS-CODE\\notes-react\\node_modules\\@react-md\\utils\\src\\positioning\\getFixedPosition.ts"],"sourcesContent":["import { BELOW_CENTER_ANCHOR } from \"./constants\";\nimport { createHorizontalPosition } from \"./createHorizontalPosition\";\nimport { createVerticalPosition } from \"./createVerticalPosition\";\nimport { findSizingContainer } from \"./findSizingContainer\";\nimport { getElementRect } from \"./getElementRect\";\nimport { getTransformOrigin } from \"./getTransformOrigin\";\nimport { getViewportSize } from \"./getViewportSize\";\nimport type { FixedPosition, FixedPositionOptions } from \"./types\";\n\n/**\n * This is used when there is no `container` element so that some styles can\n * still be created. The main use-case for this is context menus and when the\n * `initialX` and `initialY` options have been provided.\n *\n * @internal\n * @remarks \\@since 5.0.0\n */\nconst FALLBACK_DOM_RECT: DOMRect = {\n  x: 0,\n  y: 0,\n  height: 0,\n  width: 0,\n  left: 0,\n  right: 0,\n  top: 0,\n  bottom: 0,\n  toJSON() {\n    // do nothing\n  },\n};\n\n/**\n * One of the most complicated functions in this project that will attempt to\n * position an element relative to another container element while still being\n * visible within the viewport. Below is the logical flow for attempting to fix\n * the element to the container:\n *\n * No Container: If there is no container element, return the provided x and y\n * positions and no styles since there's nothing we can use to calculate the\n * position.\n *\n * No Element: If the container was provided but the element to position does\n * not exist, return an style object containing the `left` and `top` values for\n * the container and apply as many of the positioning options as possible so\n * that the styles are \"as close as possible\" before the fixed element is added\n * to the DOM. This will also return the provided x and y positions since\n * nothing could be swapped around yet.\n *\n * Container and Element: If both the container and fixed element were provided,\n * apply all the positioning options to the `left` and `top` values of the\n * container based on the sizes of both elements.\n *\n * Now that the `left` and `top` values were applied, check to see if the\n * element is fully visible within the viewport with the provided positioning\n * options. If it is fully visible, do nothing else. If it isn't... follow the\n * next flow:\n *\n * First, check the horizontal sizes and make sure that the element is still\n * within the viewport with the provided viewwidth margin. If it isn't, first\n * try to swap only to a `right` style instead of left to see if that fixes it,\n * otherwise keep both the `left` and `right` styles.\n */\nexport function getFixedPosition({\n  container,\n  element,\n  anchor = BELOW_CENTER_ANCHOR,\n  initialX,\n  initialY,\n  vwMargin = 16,\n  vhMargin = 16,\n  xMargin = 0,\n  yMargin = 0,\n  width: widthType = \"auto\",\n  preventOverlap = false,\n  transformOrigin = false,\n  disableSwapping: propDisableSwapping = false,\n  disableVHBounds = false,\n}: FixedPositionOptions): FixedPosition {\n  container = findSizingContainer(container);\n\n  if (process.env.NODE_ENV !== \"production\") {\n    if (widthType !== \"auto\" && anchor.x !== \"center\") {\n      throw new Error(\n        'Unable to use a calculated width when the horizontal anchor is not `\"center\"`.'\n      );\n    }\n\n    if (preventOverlap && anchor.y !== \"above\" && anchor.y !== \"below\") {\n      throw new Error(\n        'Unable to prevent overlap when the vertical anchor is not `\"above\"` or `\"below\"`'\n      );\n    }\n  }\n\n  if (!element) {\n    return {\n      actualX: anchor.x,\n      actualY: anchor.y,\n    };\n  }\n\n  const containerRect = container?.getBoundingClientRect() ?? FALLBACK_DOM_RECT;\n  const vh = getViewportSize(\"height\");\n  const vw = getViewportSize(\"width\");\n\n  const { height, width: elWidth } = getElementRect(element);\n  if (disableVHBounds) {\n    const dialog = element.closest(\"[role='dialog']\");\n    if (!dialog) {\n      initialY = (initialY ?? 0) + window.scrollY;\n    }\n  }\n\n  const disableSwapping = propDisableSwapping || !container;\n\n  const { left, right, width, minWidth, actualX } = createHorizontalPosition({\n    x: anchor.x,\n    vw,\n    vwMargin,\n    xMargin,\n    width: widthType,\n    elWidth,\n    initialX,\n    containerRect,\n    disableSwapping,\n  });\n  const { top, bottom, actualY } = createVerticalPosition({\n    y: anchor.y,\n    vh,\n    vhMargin,\n    yMargin,\n    initialY,\n    elHeight: height,\n    containerRect,\n    disableSwapping,\n    preventOverlap,\n    disableVHBounds,\n  });\n\n  return {\n    actualX,\n    actualY,\n    style: {\n      left,\n      top,\n      right,\n      bottom,\n      width,\n      minWidth,\n      position: disableVHBounds ? \"absolute\" : \"fixed\",\n      transformOrigin: transformOrigin\n        ? getTransformOrigin({ x: actualX, y: actualY })\n        : undefined,\n    },\n  };\n}\n"]},"metadata":{},"sourceType":"module"}