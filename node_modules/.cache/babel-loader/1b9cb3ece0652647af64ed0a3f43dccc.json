{"ast":null,"code":"var __read = this && this.__read || function (o, n) {\n  var m = typeof Symbol === \"function\" && o[Symbol.iterator];\n  if (!m) return o;\n  var i = m.call(o),\n      r,\n      ar = [],\n      e;\n\n  try {\n    while ((n === void 0 || n-- > 0) && !(r = i.next()).done) ar.push(r.value);\n  } catch (error) {\n    e = {\n      error: error\n    };\n  } finally {\n    try {\n      if (r && !r.done && (m = i[\"return\"])) m.call(i);\n    } finally {\n      if (e) throw e.error;\n    }\n  }\n\n  return ar;\n};\n\nimport { useRef, useState } from \"react\";\nimport { useIsomorphicLayoutEffect } from \"../useIsomorphicLayoutEffect\";\n/**\n * @internal\n */\n\nvar TOUCH_TIMEOUT = 1200;\n/**\n * This hook helps determine the current interaction mode by attaching the\n * required event listeners to the window. The `mode` will always be defaulted\n * to `mouse` at first since it has the least possibilities of causing errors\n * with styles since the mouse-only styles are normally just `:hover` effects.\n *\n * ## Switching between modes:\n *\n * ### While in `mouse` mode:\n *\n * - any `keydown` event will switch to `keyboard` mode\n *   - this does have the side effect of meta keys also causing the switch over,\n *     but it feels fine since it helps show the current focus in the document\n *     as well\n * - any `touchstart` event will switch to `touch` mode\n *\n * ### While in `keyboard` mode:\n *\n * - any `mousedown` event will switch to `mouse` mode\n *   - it is perfectly okay to move the mouse while in keyboard mode, but still\n *     want to keep the keyboard styles until the user actually starts clicking\n * - any `touchstart` event will switch to `touch` mode\n *\n * ### While in `touch` mode:\n *\n * - any `mousemove` event will switch to `mouse` mode, but **only** if there\n *   hasn't been a `contextmenu` event within the last `1.2s`\n *   - you can really only switch back to `mouse` mode if you are using the\n *     devtools to emulate devices OR using a touch-desktop. I don't know how\n *     common this really is though.\n *   - touching the screen will always fire a `mousemove` event (which is why\n *     the `:hover` styles are normally with `rmd-utils-mouse-only`) and even\n *     after the `contextmenu` event. Normally want to go back to `mouse` mode\n *     when the mouse re-enters the `window`\n *\n * Note: It's currently impossible to switch from `touch` to `keyboard`\n * immediately. You'd first need to switch to `mouse` and then to `keyboard`. I\n * don't really know of any use-cases other than the weird touch-desktop stuff\n * and I have no experience using them.\n *\n * @internal\n */\n\nexport function useInteractionMode() {\n  var _a = __read(useState(\"mouse\"), 2),\n      mode = _a[0],\n      setMode = _a[1];\n\n  var lastTouchTime = useRef(0);\n  var isTouchContextMenu = useRef(false);\n  useIsomorphicLayoutEffect(function () {\n    var enableMouseMode = function () {\n      return setMode(\"mouse\");\n    };\n\n    var enableKeyboardMode = function () {\n      return setMode(\"keyboard\");\n    };\n\n    var handleTouchStart = function () {\n      lastTouchTime.current = Date.now();\n      isTouchContextMenu.current = false;\n      setMode(\"touch\");\n    };\n\n    var handleMouseMove = function () {\n      if (isTouchContextMenu.current || Date.now() - lastTouchTime.current < TOUCH_TIMEOUT) {\n        isTouchContextMenu.current = false;\n        return;\n      }\n\n      enableMouseMode();\n    };\n\n    var handleContextMenu = function () {\n      isTouchContextMenu.current = true;\n    };\n\n    var className = \"rmd-utils--\".concat(mode);\n    document.body.classList.add(className);\n    window.addEventListener(\"touchstart\", handleTouchStart, true);\n\n    if (mode === \"mouse\") {\n      window.addEventListener(\"keydown\", enableKeyboardMode, true);\n    } else if (mode === \"keyboard\") {\n      window.addEventListener(\"mousedown\", enableMouseMode, true);\n    } else {\n      window.addEventListener(\"mousemove\", handleMouseMove, true);\n      window.addEventListener(\"contextmenu\", handleContextMenu, true);\n    }\n\n    return function () {\n      document.body.classList.remove(className);\n      window.removeEventListener(\"touchstart\", handleTouchStart, true);\n\n      if (mode === \"mouse\") {\n        window.removeEventListener(\"keydown\", enableKeyboardMode, true);\n      } else if (mode === \"keyboard\") {\n        window.removeEventListener(\"mousedown\", enableMouseMode, true);\n      } else {\n        window.removeEventListener(\"mousemove\", handleMouseMove, true);\n        window.removeEventListener(\"contextmenu\", handleContextMenu, true);\n      }\n    };\n  }, [mode]);\n  return mode;\n}","map":{"version":3,"mappings":";;;;;;;;;;;;;;;;;;;;;;;;;AAAA,SAASA,MAAT,EAAiBC,QAAjB,QAAiC,OAAjC;AAGA,SAASC,yBAAT,QAA0C,8BAA1C;AAEA;;;;AAGA,IAAMC,aAAa,GAAG,IAAtB;AAEA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AA0CA,OAAM,SAAUC,kBAAV,GAA4B;EAC1B,gBAAkBH,QAAQ,CAAsB,OAAtB,CAA1B,EAAwD,CAAxD;EAAA,IAACI,IAAI,QAAL;EAAA,IAAOC,OAAO,QAAd;;EACN,IAAMC,aAAa,GAAGP,MAAM,CAAC,CAAD,CAA5B;EACA,IAAMQ,kBAAkB,GAAGR,MAAM,CAAC,KAAD,CAAjC;EAEAE,yBAAyB,CAAC;IACxB,IAAMO,eAAe,GAAG;MAAY,cAAO,CAAC,OAAD,CAAP;IAAgB,CAApD;;IACA,IAAMC,kBAAkB,GAAG;MAAY,cAAO,CAAC,UAAD,CAAP;IAAmB,CAA1D;;IAEA,IAAMC,gBAAgB,GAAG;MACvBJ,aAAa,CAACK,OAAd,GAAwBC,IAAI,CAACC,GAAL,EAAxB;MACAN,kBAAkB,CAACI,OAAnB,GAA6B,KAA7B;MACAN,OAAO,CAAC,OAAD,CAAP;IACD,CAJD;;IAMA,IAAMS,eAAe,GAAG;MACtB,IACEP,kBAAkB,CAACI,OAAnB,IACAC,IAAI,CAACC,GAAL,KAAaP,aAAa,CAACK,OAA3B,GAAqCT,aAFvC,EAGE;QACAK,kBAAkB,CAACI,OAAnB,GAA6B,KAA7B;QACA;MACD;;MAEDH,eAAe;IAChB,CAVD;;IAWA,IAAMO,iBAAiB,GAAG;MACxBR,kBAAkB,CAACI,OAAnB,GAA6B,IAA7B;IACD,CAFD;;IAIA,IAAMK,SAAS,GAAG,qBAAcZ,IAAd,CAAlB;IACAa,QAAQ,CAACC,IAAT,CAAcC,SAAd,CAAwBC,GAAxB,CAA4BJ,SAA5B;IACAK,MAAM,CAACC,gBAAP,CAAwB,YAAxB,EAAsCZ,gBAAtC,EAAwD,IAAxD;;IACA,IAAIN,IAAI,KAAK,OAAb,EAAsB;MACpBiB,MAAM,CAACC,gBAAP,CAAwB,SAAxB,EAAmCb,kBAAnC,EAAuD,IAAvD;IACD,CAFD,MAEO,IAAIL,IAAI,KAAK,UAAb,EAAyB;MAC9BiB,MAAM,CAACC,gBAAP,CAAwB,WAAxB,EAAqCd,eAArC,EAAsD,IAAtD;IACD,CAFM,MAEA;MACLa,MAAM,CAACC,gBAAP,CAAwB,WAAxB,EAAqCR,eAArC,EAAsD,IAAtD;MACAO,MAAM,CAACC,gBAAP,CAAwB,aAAxB,EAAuCP,iBAAvC,EAA0D,IAA1D;IACD;;IAED,OAAO;MACLE,QAAQ,CAACC,IAAT,CAAcC,SAAd,CAAwBI,MAAxB,CAA+BP,SAA/B;MACAK,MAAM,CAACG,mBAAP,CAA2B,YAA3B,EAAyCd,gBAAzC,EAA2D,IAA3D;;MACA,IAAIN,IAAI,KAAK,OAAb,EAAsB;QACpBiB,MAAM,CAACG,mBAAP,CAA2B,SAA3B,EAAsCf,kBAAtC,EAA0D,IAA1D;MACD,CAFD,MAEO,IAAIL,IAAI,KAAK,UAAb,EAAyB;QAC9BiB,MAAM,CAACG,mBAAP,CAA2B,WAA3B,EAAwChB,eAAxC,EAAyD,IAAzD;MACD,CAFM,MAEA;QACLa,MAAM,CAACG,mBAAP,CAA2B,WAA3B,EAAwCV,eAAxC,EAAyD,IAAzD;QACAO,MAAM,CAACG,mBAAP,CAA2B,aAA3B,EAA0CT,iBAA1C,EAA6D,IAA7D;MACD;IACF,CAXD;EAYD,CAjDwB,EAiDtB,CAACX,IAAD,CAjDsB,CAAzB;EAmDA,OAAOA,IAAP;AACD","names":["useRef","useState","useIsomorphicLayoutEffect","TOUCH_TIMEOUT","useInteractionMode","mode","setMode","lastTouchTime","isTouchContextMenu","enableMouseMode","enableKeyboardMode","handleTouchStart","current","Date","now","handleMouseMove","handleContextMenu","className","document","body","classList","add","window","addEventListener","remove","removeEventListener"],"sources":["C:\\Users\\hungr\\Documents\\VS-CODE\\notes-react\\node_modules\\@react-md\\utils\\src\\mode\\useInteractionMode.ts"],"sourcesContent":["import { useRef, useState } from \"react\";\n\nimport type { UserInteractionMode } from \"./types\";\nimport { useIsomorphicLayoutEffect } from \"../useIsomorphicLayoutEffect\";\n\n/**\n * @internal\n */\nconst TOUCH_TIMEOUT = 1200;\n\n/**\n * This hook helps determine the current interaction mode by attaching the\n * required event listeners to the window. The `mode` will always be defaulted\n * to `mouse` at first since it has the least possibilities of causing errors\n * with styles since the mouse-only styles are normally just `:hover` effects.\n *\n * ## Switching between modes:\n *\n * ### While in `mouse` mode:\n *\n * - any `keydown` event will switch to `keyboard` mode\n *   - this does have the side effect of meta keys also causing the switch over,\n *     but it feels fine since it helps show the current focus in the document\n *     as well\n * - any `touchstart` event will switch to `touch` mode\n *\n * ### While in `keyboard` mode:\n *\n * - any `mousedown` event will switch to `mouse` mode\n *   - it is perfectly okay to move the mouse while in keyboard mode, but still\n *     want to keep the keyboard styles until the user actually starts clicking\n * - any `touchstart` event will switch to `touch` mode\n *\n * ### While in `touch` mode:\n *\n * - any `mousemove` event will switch to `mouse` mode, but **only** if there\n *   hasn't been a `contextmenu` event within the last `1.2s`\n *   - you can really only switch back to `mouse` mode if you are using the\n *     devtools to emulate devices OR using a touch-desktop. I don't know how\n *     common this really is though.\n *   - touching the screen will always fire a `mousemove` event (which is why\n *     the `:hover` styles are normally with `rmd-utils-mouse-only`) and even\n *     after the `contextmenu` event. Normally want to go back to `mouse` mode\n *     when the mouse re-enters the `window`\n *\n * Note: It's currently impossible to switch from `touch` to `keyboard`\n * immediately. You'd first need to switch to `mouse` and then to `keyboard`. I\n * don't really know of any use-cases other than the weird touch-desktop stuff\n * and I have no experience using them.\n *\n * @internal\n */\nexport function useInteractionMode(): UserInteractionMode {\n  const [mode, setMode] = useState<UserInteractionMode>(\"mouse\");\n  const lastTouchTime = useRef(0);\n  const isTouchContextMenu = useRef(false);\n\n  useIsomorphicLayoutEffect(() => {\n    const enableMouseMode = (): void => setMode(\"mouse\");\n    const enableKeyboardMode = (): void => setMode(\"keyboard\");\n\n    const handleTouchStart = (): void => {\n      lastTouchTime.current = Date.now();\n      isTouchContextMenu.current = false;\n      setMode(\"touch\");\n    };\n\n    const handleMouseMove = (): void => {\n      if (\n        isTouchContextMenu.current ||\n        Date.now() - lastTouchTime.current < TOUCH_TIMEOUT\n      ) {\n        isTouchContextMenu.current = false;\n        return;\n      }\n\n      enableMouseMode();\n    };\n    const handleContextMenu = (): void => {\n      isTouchContextMenu.current = true;\n    };\n\n    const className = `rmd-utils--${mode}`;\n    document.body.classList.add(className);\n    window.addEventListener(\"touchstart\", handleTouchStart, true);\n    if (mode === \"mouse\") {\n      window.addEventListener(\"keydown\", enableKeyboardMode, true);\n    } else if (mode === \"keyboard\") {\n      window.addEventListener(\"mousedown\", enableMouseMode, true);\n    } else {\n      window.addEventListener(\"mousemove\", handleMouseMove, true);\n      window.addEventListener(\"contextmenu\", handleContextMenu, true);\n    }\n\n    return () => {\n      document.body.classList.remove(className);\n      window.removeEventListener(\"touchstart\", handleTouchStart, true);\n      if (mode === \"mouse\") {\n        window.removeEventListener(\"keydown\", enableKeyboardMode, true);\n      } else if (mode === \"keyboard\") {\n        window.removeEventListener(\"mousedown\", enableMouseMode, true);\n      } else {\n        window.removeEventListener(\"mousemove\", handleMouseMove, true);\n        window.removeEventListener(\"contextmenu\", handleContextMenu, true);\n      }\n    };\n  }, [mode]);\n\n  return mode;\n}\n"]},"metadata":{},"sourceType":"module"}