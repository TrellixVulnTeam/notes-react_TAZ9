{"ast":null,"code":"var __assign = this && this.__assign || function () {\n  __assign = Object.assign || function (t) {\n    for (var s, i = 1, n = arguments.length; i < n; i++) {\n      s = arguments[i];\n\n      for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p)) t[p] = s[p];\n    }\n\n    return t;\n  };\n\n  return __assign.apply(this, arguments);\n};\n\nvar __rest = this && this.__rest || function (s, e) {\n  var t = {};\n\n  for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0) t[p] = s[p];\n\n  if (s != null && typeof Object.getOwnPropertySymbols === \"function\") for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {\n    if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i])) t[p[i]] = s[p[i]];\n  }\n  return t;\n};\n\nvar __read = this && this.__read || function (o, n) {\n  var m = typeof Symbol === \"function\" && o[Symbol.iterator];\n  if (!m) return o;\n  var i = m.call(o),\n      r,\n      ar = [],\n      e;\n\n  try {\n    while ((n === void 0 || n-- > 0) && !(r = i.next()).done) ar.push(r.value);\n  } catch (error) {\n    e = {\n      error: error\n    };\n  } finally {\n    try {\n      if (r && !r.done && (m = i[\"return\"])) m.call(i);\n    } finally {\n      if (e) throw e.error;\n    }\n  }\n\n  return ar;\n};\n\nimport { useState } from \"react\";\nimport { scrollIntoView } from \"../../scrollIntoView\";\nimport { DEFAULT_GET_ITEM_VALUE, DEFAULT_VALUE_KEY } from \"../../search/utils\";\nimport { useKeyboardMovement } from \"./useKeyboardMovement\";\nimport { getItemId } from \"./utils\";\n/**\n * This hook allows for custom keyboard \"focus\" movement using the\n * `aria-activedescendant` movement pattern. This is generally used when the DOM\n * focus shouldn't actually change from the container element (like listboxes)\n * but you still need to indicate that another element is \"focused\" due to a key\n * press.\n *\n * To use this hook, you'll want to update the container element of all the\n * items to have an `aria-activedescendant={activeId}` attribute and\n * `onKeyDown={onKeyDown}` that are provided by this hook. The\n * `aria-activedescendant` will help screen readers known what element is\n * \"focused\" since the container element should never really lose focus during\n * these keyboard movement events.  Finally, you'll want to update each item\n * have an id that is the result of `getItem(baseId, index)` so that it matches\n * the `aria-activedescendant` value and then apply `ref={itemRefs[i]}`.\n * Unfortunately, this means that all the child items **must** either be an\n * HTMLElement or the ref is forwarded down to the HTMLElement.\n *\n * The `itemRefs` **must** be applied so that a new \"focused\" item can be\n * scrolled into view as needed.\n *\n * @typeParam D - The type of each data item within the items list.\n * @typeParam CE - The HTMLElement type of the container element that handles\n * the custom keyboard movement.\n * @typeParam IE - The HTMLElement type of each item within the container\n * element that can be focusable.\n */\n\nexport function useActiveDescendantMovement(_a) {\n  var baseId = _a.baseId,\n      _b = _a.getId,\n      getId = _b === void 0 ? getItemId : _b,\n      _c = _a.defaultFocusedIndex,\n      defaultFocusedIndex = _c === void 0 ? -1 : _c,\n      items = _a.items,\n      onChange = _a.onChange,\n      _d = _a.getItemValue,\n      getItemValue = _d === void 0 ? DEFAULT_GET_ITEM_VALUE : _d,\n      _e = _a.valueKey,\n      valueKey = _e === void 0 ? DEFAULT_VALUE_KEY : _e,\n      onKeyDown = _a.onKeyDown,\n      onEnter = _a.onEnter,\n      onSpace = _a.onSpace,\n      options = __rest(_a, [\"baseId\", \"getId\", \"defaultFocusedIndex\", \"items\", \"onChange\", \"getItemValue\", \"valueKey\", \"onKeyDown\", \"onEnter\", \"onSpace\"]);\n\n  var _f = __read(useState(defaultFocusedIndex), 2),\n      focusedIndex = _f[0],\n      setFocusedIndex = _f[1];\n\n  var activeId = focusedIndex !== -1 ? getId(baseId, focusedIndex) : \"\";\n\n  var _g = __read(useKeyboardMovement(__assign(__assign({}, options), {\n    valueKey: valueKey,\n    getItemValue: getItemValue,\n    focusedIndex: focusedIndex,\n    items: items,\n    onChange: function (data, itemRefs) {\n      if (onChange) {\n        onChange(data, itemRefs);\n      }\n\n      var index = data.index,\n          target = data.target;\n      var item = itemRefs[index] && itemRefs[index].current;\n\n      if (item && target && target.scrollHeight > target.offsetHeight) {\n        scrollIntoView(target, item);\n      }\n\n      setFocusedIndex(index);\n    },\n    onKeyDown: function (event) {\n      if (onKeyDown) {\n        onKeyDown(event);\n      }\n\n      var ref = itemRefs[focusedIndex] && itemRefs[focusedIndex].current || null;\n\n      if (onEnter && event.key === \"Enter\") {\n        onEnter(focusedIndex, ref);\n      } else if (onSpace && event.key === \" \") {\n        event.preventDefault();\n        onSpace(focusedIndex, ref);\n      }\n    }\n  })), 2),\n      itemRefs = _g[0],\n      handleKeyDown = _g[1];\n\n  return {\n    activeId: activeId,\n    itemRefs: itemRefs,\n    onKeyDown: handleKeyDown,\n    focusedIndex: focusedIndex,\n    setFocusedIndex: setFocusedIndex\n  };\n}","map":{"version":3,"mappings":";;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AACA,SAASA,QAAT,QAAyB,OAAzB;AAEA,SAASC,cAAT,QAA+B,sBAA/B;AACA,SAASC,sBAAT,EAAiCC,iBAAjC,QAA0D,oBAA1D;AAMA,SAASC,mBAAT,QAAoC,uBAApC;AACA,SAASC,SAAT,QAA0B,SAA1B;AAmEA;;;;;;;;;;;;;;;;;;;;;;;;;;;;AA2BA,OAAM,SAAUC,2BAAV,CAIJC,EAJI,EAgB+B;EAXnC,UAAM,YAAN;EAAA,IACAC,aADA;EAAA,IACAC,KAAK,mBAAGJ,SAAH,GAAYG,EADjB;EAAA,IAEAE,2BAFA;EAAA,IAEAC,mBAAmB,mBAAG,CAAC,CAAJ,GAAKD,EAFxB;EAAA,IAGAE,KAAK,WAHL;EAAA,IAIAC,QAAQ,cAJR;EAAA,IAKAC,oBALA;EAAA,IAKAC,YAAY,mBAAGb,sBAAH,GAAyBY,EALrC;EAAA,IAMAE,gBANA;EAAA,IAMAC,QAAQ,mBAAGd,iBAAH,GAAoBa,EAN5B;EAAA,IAOAE,SAAS,eAPT;EAAA,IAQAC,OAAO,aARP;EAAA,IASAC,OAAO,aATP;EAAA,IAUGC,OAAO,cAXV,8HAWU,CAVV;;EAeM,gBAAkCrB,QAAQ,CAACW,mBAAD,CAA1C,EAA+D,CAA/D;EAAA,IAACW,YAAY,QAAb;EAAA,IAAeC,eAAe,QAA9B;;EACN,IAAMC,QAAQ,GAAGF,YAAY,KAAK,CAAC,CAAlB,GAAsBb,KAAK,CAACgB,MAAD,EAASH,YAAT,CAA3B,GAAoD,EAArE;;EAEM,gBAA4BlB,mBAAmB,uBAChDiB,OADgD,GACzC;IACVJ,QAAQ,UADE;IAEVF,YAAY,cAFF;IAGVO,YAAY,cAHF;IAIVV,KAAK,OAJK;IAKVC,QAAQ,YAACa,IAAD,EAAOC,QAAP,EAAe;MACrB,IAAId,QAAJ,EAAc;QACZA,QAAQ,CAACa,IAAD,EAAOC,QAAP,CAAR;MACD;;MAEO,SAAK,GAAaD,IAAI,MAAtB;MAAA,IAAOE,MAAM,GAAKF,IAAI,OAAtB;MACR,IAAMG,IAAI,GAAGF,QAAQ,CAACG,KAAD,CAAR,IAAmBH,QAAQ,CAACG,KAAD,CAAR,CAAgBC,OAAhD;;MACA,IAAIF,IAAI,IAAID,MAAR,IAAkBA,MAAM,CAACI,YAAP,GAAsBJ,MAAM,CAACK,YAAnD,EAAiE;QAC/DhC,cAAc,CAAC2B,MAAD,EAASC,IAAT,CAAd;MACD;;MAEDN,eAAe,CAACO,KAAD,CAAf;IACD,CAjBS;IAkBVZ,SAAS,YAACgB,KAAD,EAAM;MACb,IAAIhB,SAAJ,EAAe;QACbA,SAAS,CAACgB,KAAD,CAAT;MACD;;MAED,IAAMC,GAAG,GACNR,QAAQ,CAACL,YAAD,CAAR,IAA0BK,QAAQ,CAACL,YAAD,CAAR,CAAuBS,OAAlD,IAA8D,IADhE;;MAEA,IAAIZ,OAAO,IAAIe,KAAK,CAACE,GAAN,KAAc,OAA7B,EAAsC;QACpCjB,OAAO,CAACG,YAAD,EAAea,GAAf,CAAP;MACD,CAFD,MAEO,IAAIf,OAAO,IAAIc,KAAK,CAACE,GAAN,KAAc,GAA7B,EAAkC;QACvCF,KAAK,CAACG,cAAN;QACAjB,OAAO,CAACE,YAAD,EAAea,GAAf,CAAP;MACD;IACF;EA/BS,CADyC,EAA/C,EAiCJ,CAjCI;EAAA,IAACR,QAAQ,QAAT;EAAA,IAAWW,aAAa,QAAxB;;EAmCN,OAAO;IACLd,QAAQ,UADH;IAELG,QAAQ,UAFH;IAGLT,SAAS,EAAEoB,aAHN;IAILhB,YAAY,cAJP;IAKLC,eAAe;EALV,CAAP;AAOD","names":["useState","scrollIntoView","DEFAULT_GET_ITEM_VALUE","DEFAULT_VALUE_KEY","useKeyboardMovement","getItemId","useActiveDescendantMovement","_a","_b","getId","_c","defaultFocusedIndex","items","onChange","_d","getItemValue","_e","valueKey","onKeyDown","onEnter","onSpace","options","focusedIndex","setFocusedIndex","activeId","baseId","data","itemRefs","target","item","index","current","scrollHeight","offsetHeight","event","ref","key","preventDefault","handleKeyDown"],"sources":["C:\\Users\\hungr\\Documents\\VS-CODE\\notes-react\\node_modules\\@react-md\\utils\\src\\wia-aria\\movement\\useActiveDescendantMovement.ts"],"sourcesContent":["import type { Dispatch, SetStateAction } from \"react\";\nimport { useState } from \"react\";\n\nimport { scrollIntoView } from \"../../scrollIntoView\";\nimport { DEFAULT_GET_ITEM_VALUE, DEFAULT_VALUE_KEY } from \"../../search/utils\";\nimport type {\n  BaseKeyboardMovementOptions,\n  ItemRefList,\n  MovementHandler,\n} from \"./useKeyboardMovement\";\nimport { useKeyboardMovement } from \"./useKeyboardMovement\";\nimport { getItemId } from \"./utils\";\n\nexport type ActiveDescendantId = string;\n\n/**\n *\n * @typeParam CE - The HTMLElement type of the container element that handles\n * the custom keyboard movement.\n * @typeParam IE - The HTMLElement type of each item within the container\n * element that can be focusable.\n */\nexport interface ActiveDescendantMovementProviders<\n  CE extends HTMLElement,\n  IE extends HTMLElement\n> {\n  itemRefs: ItemRefList<IE>;\n  onKeyDown: MovementHandler<CE>;\n  activeId: ActiveDescendantId;\n  focusedIndex: number;\n  setFocusedIndex: Dispatch<SetStateAction<number>>;\n}\n\ntype KeyHandler<IE extends HTMLElement = HTMLElement> = (\n  focusedIndex: number,\n  itemRef: IE | null\n) => void;\n\ninterface ActiveDescendantOptions<\n  D = unknown,\n  CE extends HTMLElement = HTMLElement,\n  IE extends HTMLElement = HTMLElement\n> extends BaseKeyboardMovementOptions<D, CE, IE> {\n  /**\n   * The base id that should be used to generate the `aria-activedescendant`\n   * value id. This will be passed into the `getId` option.\n   */\n  baseId: string;\n\n  /**\n   * The function that should generate an id based on the provided `id` and\n   * `index` of the item.\n   */\n  getId?(id: string, index: number): string;\n\n  /**\n   * The default index that should be \"focused\" when the component mounts. This\n   * is set to `-1` by default so that it only gains a new \"focused\" index when\n   * the container element is focused.\n   */\n  defaultFocusedIndex?: (() => number) | number;\n\n  /**\n   * An optional function to call when the enter key has been pressed while the\n   * container element has keyboard focus. This is normally used for triggering\n   * click events for that specific item.\n   */\n  onEnter?: KeyHandler<IE>;\n\n  /**\n   * An optional function to call when the space key has been pressed while the\n   * container element has keyboard focus. This is normally used for triggering\n   * click events for that specific item and will always call\n   * `event.preventDefault()` to prevent the page scrolling behavior.\n   */\n  onSpace?: KeyHandler<IE>;\n}\n\n/**\n * This hook allows for custom keyboard \"focus\" movement using the\n * `aria-activedescendant` movement pattern. This is generally used when the DOM\n * focus shouldn't actually change from the container element (like listboxes)\n * but you still need to indicate that another element is \"focused\" due to a key\n * press.\n *\n * To use this hook, you'll want to update the container element of all the\n * items to have an `aria-activedescendant={activeId}` attribute and\n * `onKeyDown={onKeyDown}` that are provided by this hook. The\n * `aria-activedescendant` will help screen readers known what element is\n * \"focused\" since the container element should never really lose focus during\n * these keyboard movement events.  Finally, you'll want to update each item\n * have an id that is the result of `getItem(baseId, index)` so that it matches\n * the `aria-activedescendant` value and then apply `ref={itemRefs[i]}`.\n * Unfortunately, this means that all the child items **must** either be an\n * HTMLElement or the ref is forwarded down to the HTMLElement.\n *\n * The `itemRefs` **must** be applied so that a new \"focused\" item can be\n * scrolled into view as needed.\n *\n * @typeParam D - The type of each data item within the items list.\n * @typeParam CE - The HTMLElement type of the container element that handles\n * the custom keyboard movement.\n * @typeParam IE - The HTMLElement type of each item within the container\n * element that can be focusable.\n */\nexport function useActiveDescendantMovement<\n  D = unknown,\n  CE extends HTMLElement = HTMLElement,\n  IE extends HTMLElement = HTMLElement\n>({\n  baseId,\n  getId = getItemId,\n  defaultFocusedIndex = -1,\n  items,\n  onChange,\n  getItemValue = DEFAULT_GET_ITEM_VALUE,\n  valueKey = DEFAULT_VALUE_KEY,\n  onKeyDown,\n  onEnter,\n  onSpace,\n  ...options\n}: ActiveDescendantOptions<D, CE, IE>): ActiveDescendantMovementProviders<\n  CE,\n  IE\n> {\n  const [focusedIndex, setFocusedIndex] = useState(defaultFocusedIndex);\n  const activeId = focusedIndex !== -1 ? getId(baseId, focusedIndex) : \"\";\n\n  const [itemRefs, handleKeyDown] = useKeyboardMovement<D, CE, IE>({\n    ...options,\n    valueKey,\n    getItemValue,\n    focusedIndex,\n    items,\n    onChange(data, itemRefs) {\n      if (onChange) {\n        onChange(data, itemRefs);\n      }\n\n      const { index, target } = data;\n      const item = itemRefs[index] && itemRefs[index].current;\n      if (item && target && target.scrollHeight > target.offsetHeight) {\n        scrollIntoView(target, item);\n      }\n\n      setFocusedIndex(index);\n    },\n    onKeyDown(event) {\n      if (onKeyDown) {\n        onKeyDown(event);\n      }\n\n      const ref =\n        (itemRefs[focusedIndex] && itemRefs[focusedIndex].current) || null;\n      if (onEnter && event.key === \"Enter\") {\n        onEnter(focusedIndex, ref);\n      } else if (onSpace && event.key === \" \") {\n        event.preventDefault();\n        onSpace(focusedIndex, ref);\n      }\n    },\n  });\n\n  return {\n    activeId,\n    itemRefs,\n    onKeyDown: handleKeyDown,\n    focusedIndex,\n    setFocusedIndex,\n  };\n}\n"]},"metadata":{},"sourceType":"module"}