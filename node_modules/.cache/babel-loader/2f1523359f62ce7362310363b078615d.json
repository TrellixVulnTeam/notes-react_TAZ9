{"ast":null,"code":"var __assign = this && this.__assign || function () {\n  __assign = Object.assign || function (t) {\n    for (var s, i = 1, n = arguments.length; i < n; i++) {\n      s = arguments[i];\n\n      for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p)) t[p] = s[p];\n    }\n\n    return t;\n  };\n\n  return __assign.apply(this, arguments);\n};\n\nvar __read = this && this.__read || function (o, n) {\n  var m = typeof Symbol === \"function\" && o[Symbol.iterator];\n  if (!m) return o;\n  var i = m.call(o),\n      r,\n      ar = [],\n      e;\n\n  try {\n    while ((n === void 0 || n-- > 0) && !(r = i.next()).done) ar.push(r.value);\n  } catch (error) {\n    e = {\n      error: error\n    };\n  } finally {\n    try {\n      if (r && !r.done && (m = i[\"return\"])) m.call(i);\n    } finally {\n      if (e) throw e.error;\n    }\n  }\n\n  return ar;\n};\n\nimport { jsx as _jsx } from \"react/jsx-runtime\";\nimport { createContext, useCallback, useContext, useEffect, useMemo, useState } from \"react\";\nimport { useAppSize } from \"@react-md/utils\";\nimport { DEFAULT_DESKTOP_LAYOUT, DEFAULT_LANDSCAPE_TABLET_LAYOUT, DEFAULT_PHONE_LAYOUT, DEFAULT_TABLET_LAYOUT } from \"./constants\";\nimport { getLayoutType, isMiniLayout, isPersistentLayout, isToggleableLayout } from \"./utils\";\n/**\n * @internal\n */\n\nvar notInitialized = function (name) {\n  return function () {\n    /* istanbul ignore next */\n    if (process.env.NODE_ENV !== \"production\") {\n      /* eslint-disable no-console */\n      console.warn(\"Uh oh, something went wrong. Somehow the `LayoutNavigationConfiguration` context has not been initialized. \" + \"This caused the \\\"\".concat(name, \"\\\" callback to do nothing.\"));\n    }\n  };\n};\n\nvar context = createContext({\n  baseId: \"layout\",\n  layout: \"temporary\",\n  visible: false,\n  showNav: notInitialized(\"showNav\"),\n  hideNav: notInitialized(\"hideNav\"),\n  fixedAppBar: true,\n  isMiniable: false\n});\n/**\n * Gets the current layout state and configuration.\n */\n\nexport function useLayoutConfig() {\n  return useContext(context);\n}\nvar Provider = context.Provider;\n/**\n * @remarks \\@since 2.6.0\n * @internal\n */\n\nfunction isToggleableVisible(behavior, layout) {\n  return typeof behavior === \"string\" ? behavior === layout : behavior && isToggleableLayout(layout);\n}\n/**\n * Determines the current layout based on the `LayoutConfiguration` and hooks\n * into the `AppSizeListener` to update on resize. This also initializes the\n * `LayLayoutContext` so that a custom layout implementation can be used along\n * with the `useLayoutConfig()` hook and the multiple `Layout` components.\n */\n\n\nexport function LayoutProvider(_a) {\n  var baseId = _a.baseId,\n      _b = _a.phoneLayout,\n      phoneLayout = _b === void 0 ? DEFAULT_PHONE_LAYOUT : _b,\n      _c = _a.tabletLayout,\n      tabletLayout = _c === void 0 ? DEFAULT_TABLET_LAYOUT : _c,\n      _d = _a.landscapeTabletLayout,\n      landscapeTabletLayout = _d === void 0 ? DEFAULT_LANDSCAPE_TABLET_LAYOUT : _d,\n      _e = _a.desktopLayout,\n      desktopLayout = _e === void 0 ? DEFAULT_DESKTOP_LAYOUT : _e,\n      largeDesktopLayout = _a.largeDesktopLayout,\n      _f = _a.defaultToggleableVisible,\n      defaultToggleableVisible = _f === void 0 ? false : _f,\n      _g = _a.fixedAppBar,\n      fixedAppBar = _g === void 0 ? true : _g,\n      children = _a.children;\n  var appSize = useAppSize();\n  var layout = getLayoutType({\n    appSize: appSize,\n    phoneLayout: phoneLayout,\n    tabletLayout: tabletLayout,\n    landscapeTabletLayout: landscapeTabletLayout,\n    desktopLayout: desktopLayout,\n    largeDesktopLayout: largeDesktopLayout\n  });\n  var isMiniable = [phoneLayout, tabletLayout, landscapeTabletLayout, desktopLayout, largeDesktopLayout].some(function (layout) {\n    return !!layout && isMiniLayout(layout);\n  });\n  var isDesktop = appSize.isDesktop;\n\n  var _h = __read(useState(isPersistentLayout(layout) && isDesktop || isToggleableVisible(defaultToggleableVisible, layout)), 2),\n      visible = _h[0],\n      setVisible = _h[1];\n\n  useEffect(function () {\n    setVisible(isPersistentLayout(layout) || isToggleableVisible(defaultToggleableVisible, layout));\n  }, [defaultToggleableVisible, layout]);\n  var showNav = useCallback(function () {\n    setVisible(true);\n  }, []);\n  var hideNav = useCallback(function () {\n    if (!isPersistentLayout(layout)) {\n      setVisible(false);\n    }\n  }, [layout]);\n  var value = useMemo(function () {\n    return {\n      baseId: baseId,\n      layout: layout,\n      visible: visible,\n      showNav: showNav,\n      hideNav: hideNav,\n      fixedAppBar: fixedAppBar,\n      isMiniable: isMiniable\n    };\n  }, [baseId, layout, visible, showNav, hideNav, fixedAppBar, isMiniable]);\n  return _jsx(Provider, __assign({\n    value: value\n  }, {\n    children: children\n  }));\n}","map":{"version":3,"mappings":"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","names":["createContext","useCallback","useContext","useEffect","useMemo","useState","useAppSize","DEFAULT_DESKTOP_LAYOUT","DEFAULT_LANDSCAPE_TABLET_LAYOUT","DEFAULT_PHONE_LAYOUT","DEFAULT_TABLET_LAYOUT","getLayoutType","isMiniLayout","isPersistentLayout","isToggleableLayout","notInitialized","name","process","env","NODE_ENV","console","warn","context","baseId","layout","visible","showNav","hideNav","fixedAppBar","isMiniable","useLayoutConfig","isToggleableVisible","behavior","LayoutProvider","_a","_b","phoneLayout","_c","tabletLayout","_d","landscapeTabletLayout","_e","desktopLayout","largeDesktopLayout","_f","defaultToggleableVisible","_g","children","appSize","some","isDesktop","setVisible","value","_jsx","Provider","__assign"],"sources":["C:\\Users\\hungr\\Documents\\VS-CODE\\notes-react\\node_modules\\@react-md\\layout\\src\\LayoutProvider.tsx"],"sourcesContent":["import type { ReactElement, ReactNode } from \"react\";\nimport {\n  createContext,\n  useCallback,\n  useContext,\n  useEffect,\n  useMemo,\n  useState,\n} from \"react\";\nimport { useAppSize } from \"@react-md/utils\";\n\nimport {\n  DEFAULT_DESKTOP_LAYOUT,\n  DEFAULT_LANDSCAPE_TABLET_LAYOUT,\n  DEFAULT_PHONE_LAYOUT,\n  DEFAULT_TABLET_LAYOUT,\n} from \"./constants\";\nimport type { LayoutConfiguration, SupportedWideLayout } from \"./types\";\nimport {\n  getLayoutType,\n  isMiniLayout,\n  isPersistentLayout,\n  isToggleableLayout,\n} from \"./utils\";\n\n/**\n * @internal\n */\nconst notInitialized = (name: string) => (): void => {\n  /* istanbul ignore next */\n  if (process.env.NODE_ENV !== \"production\") {\n    /* eslint-disable no-console */\n    console.warn(\n      \"Uh oh, something went wrong. Somehow the `LayoutNavigationConfiguration` context has not been initialized. \" +\n        `This caused the \"${name}\" callback to do nothing.`\n    );\n  }\n};\n\nexport interface LayoutContext {\n  /**\n   * The root `id` that was passed to the `Layout` component so that `id`s can\n   * be generated for child components.\n   */\n  baseId: string;\n\n  /**\n   * The current layout that is being used based on the app's size.\n   */\n  layout: SupportedWideLayout;\n\n  /**\n   * Boolean if the navigation panel is currently visible. This will always be\n   * `true` for persist layout types on desktop.\n   */\n  visible: boolean;\n\n  /**\n   * A function that will set the `visible` state to `true`.\n   */\n  showNav(): void;\n\n  /**\n   * A function that will set the `visible` state to `false`.\n   */\n  hideNav(): void;\n\n  /**\n   * Boolean if the layout is currently using a fixed app bar which can be\n   * useful for determining specific scroll or layout behavior.\n   *\n   * @remarks \\@since 2.8.3\n   */\n  fixedAppBar: boolean;\n\n  /**\n   * Boolean if one of the layout types are mini. This is mostly used internally\n   * to prevent the `<main>` element from unmounting (and losing state) for\n   * non-fixed app bar layouts.\n   *\n   * @remarks \\@since 2.9.1\n   */\n  isMiniable: boolean;\n}\n\nconst context = createContext<LayoutContext>({\n  baseId: \"layout\",\n  layout: \"temporary\",\n  visible: false,\n  showNav: notInitialized(\"showNav\"),\n  hideNav: notInitialized(\"hideNav\"),\n  fixedAppBar: true,\n  isMiniable: false,\n});\n\n/**\n * Gets the current layout state and configuration.\n */\nexport function useLayoutConfig(): LayoutContext {\n  return useContext(context);\n}\n\nconst { Provider } = context;\n\nexport interface LayoutProviderProps extends LayoutConfiguration {\n  /**\n   * The base id for the layout component. This is required since all the child\n   * components use this to generate their ids.\n   */\n  baseId: string;\n\n  /**\n   * The children to render that can inherit the current layout.\n   */\n  children: ReactNode;\n\n  /** {@inheritDoc LayoutContext.fixedAppBar} */\n  fixedAppBar?: boolean;\n}\n\n/**\n * @remarks \\@since 2.6.0\n * @internal\n */\nfunction isToggleableVisible(\n  behavior: boolean | \"toggleable\" | \"toggleable-mini\",\n  layout: SupportedWideLayout\n): boolean {\n  return typeof behavior === \"string\"\n    ? behavior === layout\n    : behavior && isToggleableLayout(layout);\n}\n\n/**\n * Determines the current layout based on the `LayoutConfiguration` and hooks\n * into the `AppSizeListener` to update on resize. This also initializes the\n * `LayLayoutContext` so that a custom layout implementation can be used along\n * with the `useLayoutConfig()` hook and the multiple `Layout` components.\n */\nexport function LayoutProvider({\n  baseId,\n  phoneLayout = DEFAULT_PHONE_LAYOUT,\n  tabletLayout = DEFAULT_TABLET_LAYOUT,\n  landscapeTabletLayout = DEFAULT_LANDSCAPE_TABLET_LAYOUT,\n  desktopLayout = DEFAULT_DESKTOP_LAYOUT,\n  largeDesktopLayout,\n  defaultToggleableVisible = false,\n  fixedAppBar = true,\n  children,\n}: LayoutProviderProps): ReactElement {\n  const appSize = useAppSize();\n  const layout = getLayoutType({\n    appSize,\n    phoneLayout,\n    tabletLayout,\n    landscapeTabletLayout,\n    desktopLayout,\n    largeDesktopLayout,\n  });\n  const isMiniable = [\n    phoneLayout,\n    tabletLayout,\n    landscapeTabletLayout,\n    desktopLayout,\n    largeDesktopLayout,\n  ].some((layout) => !!layout && isMiniLayout(layout));\n\n  const { isDesktop } = appSize;\n  const [visible, setVisible] = useState(\n    (isPersistentLayout(layout) && isDesktop) ||\n      isToggleableVisible(defaultToggleableVisible, layout)\n  );\n\n  useEffect(() => {\n    setVisible(\n      isPersistentLayout(layout) ||\n        isToggleableVisible(defaultToggleableVisible, layout)\n    );\n  }, [defaultToggleableVisible, layout]);\n\n  const showNav = useCallback(() => {\n    setVisible(true);\n  }, []);\n\n  const hideNav = useCallback(() => {\n    if (!isPersistentLayout(layout)) {\n      setVisible(false);\n    }\n  }, [layout]);\n\n  const value = useMemo<LayoutContext>(\n    () => ({\n      baseId,\n      layout,\n      visible,\n      showNav,\n      hideNav,\n      fixedAppBar,\n      isMiniable,\n    }),\n    [baseId, layout, visible, showNav, hideNav, fixedAppBar, isMiniable]\n  );\n\n  return <Provider value={value}>{children}</Provider>;\n}\n"]},"metadata":{},"sourceType":"module"}