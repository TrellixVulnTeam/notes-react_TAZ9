{"ast":null,"code":"function applyCoords(coord) {\n  return typeof coord === \"number\" ? \"\".concat(coord, \"px\") : \"\";\n}\n/**\n * This util is used to get the \"true\" `element.getBoundingClientRect()` that\n * ensures that transitions using transforms don't mess up the sizing so that\n * position calculations are easier to do.\n *\n * @param element - The element to get a rect for.\n * @param coords - An optional object of coordinates to apply to the positioning\n * styles. This should be used when the coords might resize the element since it\n * needs to try to fit within the viewport.\n * @returns either a DOMRect for the element\n * @internal\n */\n\n\nexport function getElementRect(element, coords) {\n  if (coords === void 0) {\n    coords = {};\n  }\n\n  var cloned = element.cloneNode(true); // remove the id so there won't be two elements with the same id on the page\n\n  cloned.removeAttribute(\"id\"); // remove the role just in case the role would alert screen readers once added\n  // to the dom\n\n  cloned.removeAttribute(\"role\"); // ensure the cloned node won't shift the page or be visible\n\n  cloned.style.position = \"fixed\";\n  cloned.style.visibility = \"hidden\"; // reset positioning to get a \"pure\" calculation. otherwise this will mess up\n  // the height and width if the element is able to line wrap.\n\n  cloned.style.left = applyCoords(coords.left);\n  cloned.style.top = applyCoords(coords.top);\n  cloned.style.right = applyCoords(coords.right);\n  cloned.style.bottom = applyCoords(coords.bottom); // reset transforms so that custom animations don't mess with the sizing\n\n  cloned.style.webkitTransform = \"none\";\n  cloned.style.transform = \"none\";\n  var parent = element.parentElement || document.body;\n  parent.appendChild(cloned);\n  var rect = cloned.getBoundingClientRect();\n  parent.removeChild(cloned);\n  return rect;\n}","map":{"version":3,"mappings":"AAEA,SAASA,WAAT,CAAqBC,KAArB,EAA8C;EAC5C,OAAO,OAAOA,KAAP,KAAiB,QAAjB,GAA4B,UAAGA,KAAH,EAAQ,IAAR,CAA5B,GAA2C,EAAlD;AACD;AAED;;;;;;;;;;;;;;AAYA,OAAM,SAAUC,cAAV,CACJC,OADI,EAEJC,MAFI,EAEe;EAAnB;IAAAA;EAAmB;;EAEnB,IAAMC,MAAM,GAAGF,OAAO,CAACG,SAAR,CAAkB,IAAlB,CAAf,CAFmB,CAGnB;;EACAD,MAAM,CAACE,eAAP,CAAuB,IAAvB,EAJmB,CAMnB;EACA;;EACAF,MAAM,CAACE,eAAP,CAAuB,MAAvB,EARmB,CAUnB;;EACAF,MAAM,CAACG,KAAP,CAAaC,QAAb,GAAwB,OAAxB;EACAJ,MAAM,CAACG,KAAP,CAAaE,UAAb,GAA0B,QAA1B,CAZmB,CAcnB;EACA;;EACAL,MAAM,CAACG,KAAP,CAAaG,IAAb,GAAoBX,WAAW,CAACI,MAAM,CAACO,IAAR,CAA/B;EACAN,MAAM,CAACG,KAAP,CAAaI,GAAb,GAAmBZ,WAAW,CAACI,MAAM,CAACQ,GAAR,CAA9B;EACAP,MAAM,CAACG,KAAP,CAAaK,KAAb,GAAqBb,WAAW,CAACI,MAAM,CAACS,KAAR,CAAhC;EACAR,MAAM,CAACG,KAAP,CAAaM,MAAb,GAAsBd,WAAW,CAACI,MAAM,CAACU,MAAR,CAAjC,CAnBmB,CAqBnB;;EACAT,MAAM,CAACG,KAAP,CAAaO,eAAb,GAA+B,MAA/B;EACAV,MAAM,CAACG,KAAP,CAAaQ,SAAb,GAAyB,MAAzB;EAEA,IAAMC,MAAM,GAAGd,OAAO,CAACe,aAAR,IAAyBC,QAAQ,CAACC,IAAjD;EACAH,MAAM,CAACI,WAAP,CAAmBhB,MAAnB;EAEA,IAAMiB,IAAI,GAAGjB,MAAM,CAACkB,qBAAP,EAAb;EACAN,MAAM,CAACO,WAAP,CAAmBnB,MAAnB;EAEA,OAAOiB,IAAP;AACD","names":["applyCoords","coord","getElementRect","element","coords","cloned","cloneNode","removeAttribute","style","position","visibility","left","top","right","bottom","webkitTransform","transform","parent","parentElement","document","body","appendChild","rect","getBoundingClientRect","removeChild"],"sources":["C:\\Users\\hungr\\Documents\\VS-CODE\\notes-react\\node_modules\\@react-md\\utils\\src\\positioning\\getElementRect.ts"],"sourcesContent":["import type { Coords } from \"./types\";\n\nfunction applyCoords(coord: number | undefined): string {\n  return typeof coord === \"number\" ? `${coord}px` : \"\";\n}\n\n/**\n * This util is used to get the \"true\" `element.getBoundingClientRect()` that\n * ensures that transitions using transforms don't mess up the sizing so that\n * position calculations are easier to do.\n *\n * @param element - The element to get a rect for.\n * @param coords - An optional object of coordinates to apply to the positioning\n * styles. This should be used when the coords might resize the element since it\n * needs to try to fit within the viewport.\n * @returns either a DOMRect for the element\n * @internal\n */\nexport function getElementRect(\n  element: HTMLElement,\n  coords: Coords = {}\n): DOMRect {\n  const cloned = element.cloneNode(true) as HTMLElement;\n  // remove the id so there won't be two elements with the same id on the page\n  cloned.removeAttribute(\"id\");\n\n  // remove the role just in case the role would alert screen readers once added\n  // to the dom\n  cloned.removeAttribute(\"role\");\n\n  // ensure the cloned node won't shift the page or be visible\n  cloned.style.position = \"fixed\";\n  cloned.style.visibility = \"hidden\";\n\n  // reset positioning to get a \"pure\" calculation. otherwise this will mess up\n  // the height and width if the element is able to line wrap.\n  cloned.style.left = applyCoords(coords.left);\n  cloned.style.top = applyCoords(coords.top);\n  cloned.style.right = applyCoords(coords.right);\n  cloned.style.bottom = applyCoords(coords.bottom);\n\n  // reset transforms so that custom animations don't mess with the sizing\n  cloned.style.webkitTransform = \"none\";\n  cloned.style.transform = \"none\";\n\n  const parent = element.parentElement || document.body;\n  parent.appendChild(cloned);\n\n  const rect = cloned.getBoundingClientRect();\n  parent.removeChild(cloned);\n\n  return rect;\n}\n"]},"metadata":{},"sourceType":"module"}