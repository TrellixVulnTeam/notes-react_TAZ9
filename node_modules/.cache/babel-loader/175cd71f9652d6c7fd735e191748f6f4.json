{"ast":null,"code":"var __read = this && this.__read || function (o, n) {\n  var m = typeof Symbol === \"function\" && o[Symbol.iterator];\n  if (!m) return o;\n  var i = m.call(o),\n      r,\n      ar = [],\n      e;\n\n  try {\n    while ((n === void 0 || n-- > 0) && !(r = i.next()).done) ar.push(r.value);\n  } catch (error) {\n    e = {\n      error: error\n    };\n  } finally {\n    try {\n      if (r && !r.done && (m = i[\"return\"])) m.call(i);\n    } finally {\n      if (e) throw e.error;\n    }\n  }\n\n  return ar;\n};\n\nvar __spreadArray = this && this.__spreadArray || function (to, from, pack) {\n  if (pack || arguments.length === 2) for (var i = 0, l = from.length, ar; i < l; i++) {\n    if (ar || !(i in from)) {\n      if (!ar) ar = Array.prototype.slice.call(from, 0, i);\n      ar[i] = from[i];\n    }\n  }\n  return to.concat(ar || Array.prototype.slice.call(from));\n};\n/**\n * Gets all the child items for a specific parent item id. If the `recursive`\n * argument is enabled, all children of the items will also be returned instead\n * of only the top level items.\n *\n * @param data - Either the flattened tree data or a list of all the tree data\n * to iterate over\n * @param parentId - The parent id to get children of\n * @param recursive - Boolean if the children's children should also be returned\n * @returns a list of all the items for a specific parent item id. Note: if the\n * recursive param is enabled, the list will be ordered so that the children of\n * a item will appear before the next item at the same level. So you either need\n * to sort by `parentId` or something else if you want a specific order.\n */\n\n\nexport function getChildItems(data, parentId, recursive) {\n  if (recursive === void 0) {\n    recursive = false;\n  }\n\n  var items = Array.isArray(data) ? data : Object.values(data);\n  return items.reduce(function (list, item) {\n    if (parentId !== item.parentId) {\n      return list;\n    }\n\n    return __spreadArray(__spreadArray(__spreadArray([], __read(list), false), [item], false), __read(recursive ? getChildItems(items, item.itemId, recursive) : []), false);\n  }, []);\n}","map":{"version":3,"mappings":";;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AAOA;;;;;;;;;;;;;;;;AAcA,OAAM,SAAUA,aAAV,CACJC,IADI,EAEJC,QAFI,EAGJC,SAHI,EAGa;EAAjB;IAAAA;EAAiB;;EAEjB,IAAMC,KAAK,GAAGC,KAAK,CAACC,OAAN,CAAcL,IAAd,IAAsBA,IAAtB,GAA6BM,MAAM,CAACC,MAAP,CAAcP,IAAd,CAA3C;EAEA,OAAOG,KAAK,CAACK,MAAN,CAAkB,UAACC,IAAD,EAAOC,IAAP,EAAW;IAClC,IAAIT,QAAQ,KAAKS,IAAI,CAACT,QAAtB,EAAgC;MAC9B,OAAOQ,IAAP;IACD;;IAED,4DACKA,IADL,GACS,KADT,GACS,CACPC,IADO,CADT,iBAGMR,SAAS,GAAGH,aAAa,CAACI,KAAD,EAAQO,IAAI,CAACC,MAAb,EAAqBT,SAArB,CAAhB,GAAkD,GAHjE,EAGoE,KAHpE;EAKD,CAVM,EAUJ,EAVI,CAAP;AAWD","names":["getChildItems","data","parentId","recursive","items","Array","isArray","Object","values","reduce","list","item","itemId"],"sources":["C:\\Users\\hungr\\Documents\\VS-CODE\\notes-react\\node_modules\\@react-md\\tree\\src\\getChildItems.ts"],"sourcesContent":["import type {\n  BaseTreeItem,\n  TreeData,\n  TreeItemId,\n  UnknownTreeItem,\n} from \"./types\";\n\n/**\n * Gets all the child items for a specific parent item id. If the `recursive`\n * argument is enabled, all children of the items will also be returned instead\n * of only the top level items.\n *\n * @param data - Either the flattened tree data or a list of all the tree data\n * to iterate over\n * @param parentId - The parent id to get children of\n * @param recursive - Boolean if the children's children should also be returned\n * @returns a list of all the items for a specific parent item id. Note: if the\n * recursive param is enabled, the list will be ordered so that the children of\n * a item will appear before the next item at the same level. So you either need\n * to sort by `parentId` or something else if you want a specific order.\n */\nexport function getChildItems<T extends BaseTreeItem = UnknownTreeItem>(\n  data: TreeData<T> | readonly T[],\n  parentId: TreeItemId | null,\n  recursive = false\n): readonly T[] {\n  const items = Array.isArray(data) ? data : Object.values(data);\n\n  return items.reduce<T[]>((list, item) => {\n    if (parentId !== item.parentId) {\n      return list;\n    }\n\n    return [\n      ...list,\n      item,\n      ...(recursive ? getChildItems(items, item.itemId, recursive) : []),\n    ];\n  }, []);\n}\n"]},"metadata":{},"sourceType":"module"}