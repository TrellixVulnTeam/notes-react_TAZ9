{"ast":null,"code":"import { useEffect, useRef } from \"react\";\n/**\n * This hook is used to focus the previous element when a component unmounts.\n * The default behavior is to store the current activeElement within the\n * document when the component mounts and then try to focus it again when the\n * component unmounts.  You can also provide your own HTMLElement to focus when\n * unmounting.\n *\n * During the unmount phase, it will wait for an animation frame before checking\n * if the fallback element still exists within the page. If it doesn't, it will\n * use the fallback query/element/function to attempt to find another element to\n * focus. If the element exists within the page, it will then finally be\n * focused.\n *\n * The animation frame is unfortunately required for keyboard users as pressing\n * enter key will click the previous element immediately on focus as well.\n *\n * @param disabled - Boolean if the focus behavior should be disabled.\n * @param fallback - The fallback query, element, or function to use if the\n * previous element no longer exists in the DOM.\n * @param previousElement - An optional previous element to focus. If this is\n * omitted, the `document.activeElement` will be used instead.\n */\n\nexport function usePreviousFocus(disabled, fallback, previousElement) {\n  if (fallback === void 0) {\n    fallback = undefined;\n  }\n\n  if (previousElement === void 0) {\n    previousElement = null;\n  }\n\n  var options = useRef({\n    disabled: disabled,\n    fallback: fallback\n  });\n  useEffect(function () {\n    options.current = {\n      disabled: disabled,\n      fallback: fallback\n    };\n  });\n  useEffect(function () {\n    if (disabled) {\n      return;\n    }\n\n    var element = previousElement || document.activeElement; // i'll need to think of a better way to handle this flow. There's just a\n    // weird one where if going from a menu to a dialog, we get lost without\n    // specifying a fallback. So if we are in a menu, try to find the\n    // corresponding menu button for this flow to fallback to.\n\n    var menu = element.closest('[role=\"menu\"]');\n    var menuButton = null;\n\n    if (menu) {\n      // first try to get the button by using the menu's id minus the trailing\n      // -menu since that's the normal pattern within react-md.\n      menuButton = document.getElementById(menu.id.replace(/-menu$/, \"\"));\n\n      if (!menuButton) {\n        // if no menu button, try to see if the `aria-labelledby` points to the\n        // button... but since the `aria-labelledby` is a space-delimitated\n        // string of ids, have to check each one\n        var labelledBy = menu.getAttribute(\"aria-labelledby\") || \"\";\n        var query = labelledBy.split(\" \").map(function (id) {\n          return \"#\".concat(id, \"[tabindex]\");\n        }).join(\",\");\n        menuButton = query ? document.querySelector(query) : null;\n      }\n    }\n\n    return function () {\n      var _a = options.current,\n          fallback = _a.fallback,\n          disabled = _a.disabled;\n\n      if (disabled) {\n        // this has been added just for support for scrolling menus out of view.\n        // It is not ideal since keyboard focus is lost at this point, but\n        // _technically_ shouldn't be able to reach this flow with keyboard\n        // movement\n        return;\n      }\n\n      if (menu && menuButton && !previousElement && !fallback && !document.contains(element) && document.contains(menuButton)) {\n        menuButton.focus();\n        return;\n      }\n\n      var el = element;\n\n      if (!document.contains(el)) {\n        el = previousElement && document.contains(previousElement) ? previousElement : null;\n      }\n\n      if (!el && fallback) {\n        switch (typeof fallback) {\n          case \"string\":\n            el = document.querySelector(fallback);\n            break;\n\n          case \"function\":\n            el = fallback();\n            break;\n\n          default:\n            el = fallback;\n        }\n      }\n\n      if (el && !document.contains(el)) {\n        el = null;\n      }\n\n      if (el) {\n        el.focus();\n      }\n    }; // disabled since useRefCache and don't wnt to update on disabled change\n    // eslint-disable-next-line react-hooks/exhaustive-deps\n  }, []);\n}","map":{"version":3,"mappings":"AAAA,SAASA,SAAT,EAAoBC,MAApB,QAAkC,OAAlC;AAaA;;;;;;;;;;;;;;;;;;;;;;;AAsBA,OAAM,SAAUC,gBAAV,CACJC,QADI,EAEJC,QAFI,EAGJC,eAHI,EAGsC;EAD1C;IAAAD;EAAmC;;EACnC;IAAAC;EAA0C;;EAE1C,IAAMC,OAAO,GAAGL,MAAM,CAAC;IACrBE,QAAQ,UADa;IAErBC,QAAQ;EAFa,CAAD,CAAtB;EAKAJ,SAAS,CAAC;IACRM,OAAO,CAACC,OAAR,GAAkB;MAChBJ,QAAQ,UADQ;MAEhBC,QAAQ;IAFQ,CAAlB;EAID,CALQ,CAAT;EAOAJ,SAAS,CAAC;IACR,IAAIG,QAAJ,EAAc;MACZ;IACD;;IAED,IAAMK,OAAO,GAAGH,eAAe,IAAKI,QAAQ,CAACC,aAA7C,CALQ,CAOR;IACA;IACA;IACA;;IACA,IAAMC,IAAI,GAAGH,OAAO,CAACI,OAAR,CAAgB,eAAhB,CAAb;IACA,IAAIC,UAAU,GAAuB,IAArC;;IACA,IAAIF,IAAJ,EAAU;MACR;MACA;MACAE,UAAU,GAAGJ,QAAQ,CAACK,cAAT,CAAwBH,IAAI,CAACI,EAAL,CAAQC,OAAR,CAAgB,QAAhB,EAA0B,EAA1B,CAAxB,CAAb;;MACA,IAAI,CAACH,UAAL,EAAiB;QACf;QACA;QACA;QACA,IAAMI,UAAU,GAAGN,IAAI,CAACO,YAAL,CAAkB,iBAAlB,KAAwC,EAA3D;QACA,IAAMC,KAAK,GAAGF,UAAU,CACrBG,KADW,CACL,GADK,EAEXC,GAFW,CAEP,UAACN,EAAD,EAAG;UAAK,kBAAIA,EAAJ,EAAM,YAAN;QAAkB,CAFnB,EAGXO,IAHW,CAGN,GAHM,CAAd;QAKAT,UAAU,GAAGM,KAAK,GAAGV,QAAQ,CAACc,aAAT,CAAoCJ,KAApC,CAAH,GAAgD,IAAlE;MACD;IACF;;IAED,OAAO;MACC,SAAyBb,OAAO,CAACC,OAAjC;MAAA,IAAEH,QAAQ,cAAV;MAAA,IAAYD,QAAQ,cAApB;;MACN,IAAIA,QAAJ,EAAc;QACZ;QACA;QACA;QACA;QACA;MACD;;MAED,IACEQ,IAAI,IACJE,UADA,IAEA,CAACR,eAFD,IAGA,CAACD,QAHD,IAIA,CAACK,QAAQ,CAACe,QAAT,CAAkBhB,OAAlB,CAJD,IAKAC,QAAQ,CAACe,QAAT,CAAkBX,UAAlB,CANF,EAOE;QACAA,UAAU,CAACY,KAAX;QACA;MACD;;MAED,IAAIC,EAAE,GAAuBlB,OAA7B;;MACA,IAAI,CAACC,QAAQ,CAACe,QAAT,CAAkBE,EAAlB,CAAL,EAA4B;QAC1BA,EAAE,GACArB,eAAe,IAAII,QAAQ,CAACe,QAAT,CAAkBnB,eAAlB,CAAnB,GACIA,eADJ,GAEI,IAHN;MAID;;MAED,IAAI,CAACqB,EAAD,IAAOtB,QAAX,EAAqB;QACnB,QAAQ,OAAOA,QAAf;UACE,KAAK,QAAL;YACEsB,EAAE,GAAGjB,QAAQ,CAACc,aAAT,CAAoCnB,QAApC,CAAL;YACA;;UACF,KAAK,UAAL;YACEsB,EAAE,GAAGtB,QAAQ,EAAb;YACA;;UACF;YACEsB,EAAE,GAAGtB,QAAL;QARJ;MAUD;;MAED,IAAIsB,EAAE,IAAI,CAACjB,QAAQ,CAACe,QAAT,CAAkBE,EAAlB,CAAX,EAAkC;QAChCA,EAAE,GAAG,IAAL;MACD;;MAED,IAAIA,EAAJ,EAAQ;QACNA,EAAE,CAACD,KAAH;MACD;IACF,CAlDD,CA/BQ,CAkFR;IACA;EACD,CApFQ,EAoFN,EApFM,CAAT;AAqFD","names":["useEffect","useRef","usePreviousFocus","disabled","fallback","previousElement","options","current","element","document","activeElement","menu","closest","menuButton","getElementById","id","replace","labelledBy","getAttribute","query","split","map","join","querySelector","contains","focus","el"],"sources":["C:\\Users\\hungr\\Documents\\VS-CODE\\notes-react\\node_modules\\@react-md\\utils\\src\\wia-aria\\usePreviousFocus.ts"],"sourcesContent":["import { useEffect, useRef } from \"react\";\n\n/**\n * This can either be a query selector string, a specific HTMLElement, or a\n * function that finds a specific HTMLElement to focus.\n */\nexport type FocusFallback =\n  | string\n  | HTMLElement\n  | (() => HTMLElement | null)\n  | null\n  | undefined;\n\n/**\n * This hook is used to focus the previous element when a component unmounts.\n * The default behavior is to store the current activeElement within the\n * document when the component mounts and then try to focus it again when the\n * component unmounts.  You can also provide your own HTMLElement to focus when\n * unmounting.\n *\n * During the unmount phase, it will wait for an animation frame before checking\n * if the fallback element still exists within the page. If it doesn't, it will\n * use the fallback query/element/function to attempt to find another element to\n * focus. If the element exists within the page, it will then finally be\n * focused.\n *\n * The animation frame is unfortunately required for keyboard users as pressing\n * enter key will click the previous element immediately on focus as well.\n *\n * @param disabled - Boolean if the focus behavior should be disabled.\n * @param fallback - The fallback query, element, or function to use if the\n * previous element no longer exists in the DOM.\n * @param previousElement - An optional previous element to focus. If this is\n * omitted, the `document.activeElement` will be used instead.\n */\nexport function usePreviousFocus(\n  disabled: boolean,\n  fallback: FocusFallback = undefined,\n  previousElement: HTMLElement | null = null\n): void {\n  const options = useRef({\n    disabled,\n    fallback,\n  });\n\n  useEffect(() => {\n    options.current = {\n      disabled,\n      fallback,\n    };\n  });\n\n  useEffect(() => {\n    if (disabled) {\n      return;\n    }\n\n    const element = previousElement || (document.activeElement as HTMLElement);\n\n    // i'll need to think of a better way to handle this flow. There's just a\n    // weird one where if going from a menu to a dialog, we get lost without\n    // specifying a fallback. So if we are in a menu, try to find the\n    // corresponding menu button for this flow to fallback to.\n    const menu = element.closest('[role=\"menu\"]');\n    let menuButton: HTMLElement | null = null;\n    if (menu) {\n      // first try to get the button by using the menu's id minus the trailing\n      // -menu since that's the normal pattern within react-md.\n      menuButton = document.getElementById(menu.id.replace(/-menu$/, \"\"));\n      if (!menuButton) {\n        // if no menu button, try to see if the `aria-labelledby` points to the\n        // button... but since the `aria-labelledby` is a space-delimitated\n        // string of ids, have to check each one\n        const labelledBy = menu.getAttribute(\"aria-labelledby\") || \"\";\n        const query = labelledBy\n          .split(\" \")\n          .map((id) => `#${id}[tabindex]`)\n          .join(\",\");\n\n        menuButton = query ? document.querySelector<HTMLElement>(query) : null;\n      }\n    }\n\n    return () => {\n      const { fallback, disabled } = options.current;\n      if (disabled) {\n        // this has been added just for support for scrolling menus out of view.\n        // It is not ideal since keyboard focus is lost at this point, but\n        // _technically_ shouldn't be able to reach this flow with keyboard\n        // movement\n        return;\n      }\n\n      if (\n        menu &&\n        menuButton &&\n        !previousElement &&\n        !fallback &&\n        !document.contains(element) &&\n        document.contains(menuButton)\n      ) {\n        menuButton.focus();\n        return;\n      }\n\n      let el: HTMLElement | null = element;\n      if (!document.contains(el)) {\n        el =\n          previousElement && document.contains(previousElement)\n            ? previousElement\n            : null;\n      }\n\n      if (!el && fallback) {\n        switch (typeof fallback) {\n          case \"string\":\n            el = document.querySelector<HTMLElement>(fallback);\n            break;\n          case \"function\":\n            el = fallback();\n            break;\n          default:\n            el = fallback;\n        }\n      }\n\n      if (el && !document.contains(el)) {\n        el = null;\n      }\n\n      if (el) {\n        el.focus();\n      }\n    };\n    // disabled since useRefCache and don't wnt to update on disabled change\n    // eslint-disable-next-line react-hooks/exhaustive-deps\n  }, []);\n}\n"]},"metadata":{},"sourceType":"module"}