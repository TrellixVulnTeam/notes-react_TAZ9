{"ast":null,"code":"var __read = this && this.__read || function (o, n) {\n  var m = typeof Symbol === \"function\" && o[Symbol.iterator];\n  if (!m) return o;\n  var i = m.call(o),\n      r,\n      ar = [],\n      e;\n\n  try {\n    while ((n === void 0 || n-- > 0) && !(r = i.next()).done) ar.push(r.value);\n  } catch (error) {\n    e = {\n      error: error\n    };\n  } finally {\n    try {\n      if (r && !r.done && (m = i[\"return\"])) m.call(i);\n    } finally {\n      if (e) throw e.error;\n    }\n  }\n\n  return ar;\n};\n\nimport { scrollIntoView } from \"../scrollIntoView\";\nimport { getFocusableElements } from \"./getFocusableElements\";\nimport { isFocusable } from \"./isFocusable\";\n/**\n * A function that is used to focus an element within the provided node.  This\n * can either focus the first, last, or a querySelector found element.\n *\n * @param container - Either an HTMLElement or the document to focus an element\n * within.\n * @param focus - Either the \"first\" or \"last\" string to focus the first or last\n * focusable element within the container or a query selector string to find a\n * focusable element within the container.\n * @param programmatic - Boolean if programmatically focusable elements should be\n * included as well.\n * @param preventScroll - Boolean if the focus event should not scroll the\n * element into view. This should normally remain `false`, but can be useful if\n * the element gets focused while offscreen during a transition.\n * @param elements - Optional child elements to search\n * @remarks \\@since 2.8.0 Supports focusing the container element if it is\n * focusable\n */\n\nexport function focusElementWithin(container, focus, programmatic, preventScroll, elements) {\n  var _a;\n\n  if (programmatic === void 0) {\n    programmatic = false;\n  }\n\n  if (preventScroll === void 0) {\n    preventScroll = false;\n  }\n\n  if (!elements || !elements.length) {\n    elements = getFocusableElements(container, programmatic);\n  }\n\n  var el;\n\n  switch (focus) {\n    case \"first\":\n      _a = __read(elements, 1), el = _a[0];\n      break;\n\n    case \"last\":\n      el = elements[elements.length - 1];\n      break;\n\n    default:\n      el = container.querySelector(focus);\n  } // just allow any focusable-type element\n\n\n  if (!el && isFocusable(container, \"programmatic\")) {\n    el = container;\n  }\n\n  if (!el) {\n    throw new Error(\"Unable to find a focusable element\");\n  }\n\n  el.focus({\n    preventScroll: preventScroll\n  });\n\n  if (!preventScroll && container !== document) {\n    scrollIntoView(container, el);\n  }\n}","map":{"version":3,"mappings":";;;;;;;;;;;;;;;;;;;;;;;;;AAAA,SAASA,cAAT,QAA+B,mBAA/B;AACA,SAASC,oBAAT,QAAqC,wBAArC;AACA,SAASC,WAAT,QAA4B,eAA5B;AAIA;;;;;;;;;;;;;;;;;;;AAkBA,OAAM,SAAUC,kBAAV,CACJC,SADI,EAEJC,KAFI,EAGJC,YAHI,EAIJC,aAJI,EAKJC,QALI,EAK6B;;;EAFjC;IAAAF;EAAoB;;EACpB;IAAAC;EAAqB;;EAGrB,IAAI,CAACC,QAAD,IAAa,CAACA,QAAQ,CAACC,MAA3B,EAAmC;IACjCD,QAAQ,GAAGP,oBAAoB,CAACG,SAAD,EAAYE,YAAZ,CAA/B;EACD;;EAED,IAAII,EAAJ;;EACA,QAAQL,KAAR;IACE,KAAK,OAAL;MACEM,YAAOH,QAAP,EAAe,CAAf,GAACE,EAAE,QAAH;MACA;;IACF,KAAK,MAAL;MACEA,EAAE,GAAGF,QAAQ,CAACA,QAAQ,CAACC,MAAT,GAAkB,CAAnB,CAAb;MACA;;IACF;MACEC,EAAE,GAAGN,SAAS,CAACQ,aAAV,CAAqCP,KAArC,CAAL;EARJ,CAPiC,CAkBjC;;;EACA,IAAI,CAACK,EAAD,IAAOR,WAAW,CAACE,SAAD,EAAY,cAAZ,CAAtB,EAAmD;IACjDM,EAAE,GAAGN,SAAL;EACD;;EAED,IAAI,CAACM,EAAL,EAAS;IACP,MAAM,IAAIG,KAAJ,CAAU,oCAAV,CAAN;EACD;;EAEDH,EAAE,CAACL,KAAH,CAAS;IAAEE,aAAa;EAAf,CAAT;;EACA,IAAI,CAACA,aAAD,IAAkBH,SAAS,KAAKU,QAApC,EAA8C;IAC5Cd,cAAc,CAACI,SAAD,EAA2BM,EAA3B,CAAd;EACD;AACF","names":["scrollIntoView","getFocusableElements","isFocusable","focusElementWithin","container","focus","programmatic","preventScroll","elements","length","el","_a","querySelector","Error","document"],"sources":["C:\\Users\\hungr\\Documents\\VS-CODE\\notes-react\\node_modules\\@react-md\\utils\\src\\wia-aria\\focusElementWithin.ts"],"sourcesContent":["import { scrollIntoView } from \"../scrollIntoView\";\nimport { getFocusableElements } from \"./getFocusableElements\";\nimport { isFocusable } from \"./isFocusable\";\n\nexport type Focus = \"first\" | \"last\" | string;\n\n/**\n * A function that is used to focus an element within the provided node.  This\n * can either focus the first, last, or a querySelector found element.\n *\n * @param container - Either an HTMLElement or the document to focus an element\n * within.\n * @param focus - Either the \"first\" or \"last\" string to focus the first or last\n * focusable element within the container or a query selector string to find a\n * focusable element within the container.\n * @param programmatic - Boolean if programmatically focusable elements should be\n * included as well.\n * @param preventScroll - Boolean if the focus event should not scroll the\n * element into view. This should normally remain `false`, but can be useful if\n * the element gets focused while offscreen during a transition.\n * @param elements - Optional child elements to search\n * @remarks \\@since 2.8.0 Supports focusing the container element if it is\n * focusable\n */\nexport function focusElementWithin(\n  container: HTMLElement | Document,\n  focus: Focus,\n  programmatic = false,\n  preventScroll = false,\n  elements?: readonly HTMLElement[]\n): void {\n  if (!elements || !elements.length) {\n    elements = getFocusableElements(container, programmatic);\n  }\n\n  let el: HTMLElement | null;\n  switch (focus) {\n    case \"first\":\n      [el] = elements;\n      break;\n    case \"last\":\n      el = elements[elements.length - 1];\n      break;\n    default:\n      el = container.querySelector<HTMLElement>(focus);\n  }\n\n  // just allow any focusable-type element\n  if (!el && isFocusable(container, \"programmatic\")) {\n    el = container;\n  }\n\n  if (!el) {\n    throw new Error(\"Unable to find a focusable element\");\n  }\n\n  el.focus({ preventScroll });\n  if (!preventScroll && container !== document) {\n    scrollIntoView(container as HTMLElement, el);\n  }\n}\n"]},"metadata":{},"sourceType":"module"}