{"ast":null,"code":"import { getCenterXCoord, getInnerLeftCoord, getInnerRightCoord, getLeftCoord, getRightCoord } from \"./getCoord\";\n/**\n * Attempts to position the fixed element so that it will appear to the left of\n * the container element but also within the viewport boundaries. When swapping\n * is enabled, it will attempt to swap to the right position if it can't fit\n * within the viewport to the left. If it can't fit in the viewport even after\n * being swapped to the right or swapping is disabled, it will be positioned to\n * the viewport left boundary.\n *\n * @internal\n */\n\nexport function createAnchoredLeft(config) {\n  var vwMargin = config.vwMargin,\n      screenRight = config.screenRight,\n      elWidth = config.elWidth,\n      disableSwapping = config.disableSwapping;\n  var left = getLeftCoord(config);\n  var actualX = \"left\";\n\n  if (left >= vwMargin) {\n    return {\n      actualX: actualX,\n      left: left\n    };\n  }\n\n  var swappedLeft = getRightCoord(config);\n\n  if (disableSwapping || swappedLeft + elWidth > screenRight) {\n    left = vwMargin;\n  } else {\n    left = swappedLeft;\n    actualX = \"right\";\n  }\n\n  return {\n    actualX: actualX,\n    left: left\n  };\n}\n/**\n * Attempts to position the fixed element so that it will appear to the\n * inner-left of the container element but also within the viewport boundaries.\n * When swapping is enabled, it will attempt to swap to the right position if it\n * can't fit within the viewport to the left. If it can't fit in the viewport\n * even after being swapped to the right or swapping is disabled, it will be\n * positioned to the viewport left boundary.\n *\n * @internal\n */\n\nexport function createAnchoredInnerLeft(config) {\n  var vwMargin = config.vwMargin,\n      screenRight = config.screenRight,\n      elWidth = config.elWidth,\n      disableSwapping = config.disableSwapping;\n  var left = getInnerLeftCoord(config);\n  var actualX = \"inner-left\";\n\n  if (left + elWidth <= screenRight && left >= vwMargin) {\n    return {\n      actualX: actualX,\n      left: left\n    };\n  }\n\n  if (disableSwapping) {\n    if (left + elWidth > screenRight) {\n      left = screenRight - elWidth;\n    } else {\n      left = vwMargin;\n    }\n\n    return {\n      actualX: actualX,\n      left: left\n    };\n  }\n\n  var swappedLeft = getInnerRightCoord(config);\n\n  if (swappedLeft < vwMargin) {\n    left = vwMargin;\n  } else if (swappedLeft + elWidth > screenRight) {\n    left = screenRight - elWidth;\n    actualX = \"inner-right\";\n  } else {\n    left = swappedLeft;\n    actualX = \"inner-right\";\n  }\n\n  return {\n    actualX: actualX,\n    left: left\n  };\n}\n/**\n * Attempts to position the fixed element so that it will appear at the center\n * of the container element but also within the viewport boundaries. If the\n * centered element can't fit within the viewport, it will use the vwMargin\n * value if it overflowed to the left, it'll position to the screen right\n * boundary.\n *\n * @internal\n */\n\nexport function createAnchoredCenter(config) {\n  var vwMargin = config.vwMargin,\n      screenRight = config.screenRight,\n      elWidth = config.elWidth;\n  var left = getCenterXCoord(config);\n\n  if (left < vwMargin) {\n    left = vwMargin;\n  } else if (left + elWidth > screenRight || left < vwMargin) {\n    left = screenRight - elWidth;\n  }\n\n  return {\n    actualX: \"center\",\n    left: left\n  };\n}\n/**\n * Attempts to position the fixed element so that it will appear to the\n * inner-right of the container element but also within the viewport boundaries.\n * When swapping is enabled, it will attempt to swap to the inner-left position\n * if it can't fit within the viewport to the right. If it can't fit in the\n * viewport even after being swapped to the left or swapping is disabled, it\n * will be positioned to the viewport right boundary.\n *\n * @internal\n */\n\nexport function createAnchoredInnerRight(config) {\n  var screenRight = config.screenRight,\n      vwMargin = config.vwMargin,\n      elWidth = config.elWidth,\n      disableSwapping = config.disableSwapping;\n  var left = getInnerRightCoord(config);\n  var actualX = \"inner-right\";\n\n  if (left >= vwMargin) {\n    return {\n      actualX: actualX,\n      left: Math.min(left, screenRight - elWidth)\n    };\n  }\n\n  var swappedLeft = getInnerLeftCoord(config);\n\n  if (disableSwapping || swappedLeft + elWidth > screenRight) {\n    left = vwMargin;\n  } else {\n    left = Math.max(swappedLeft, vwMargin);\n    actualX = \"inner-left\";\n  }\n\n  return {\n    actualX: actualX,\n    left: left\n  };\n}\n/**\n * Attempts to position the fixed element so that it will appear to the right of\n * the container element but also within the viewport boundaries. When swapping\n * is enabled, it will attempt to swap to the left position if it can't fit\n * within the viewport to the right. If it can't fit in the viewport even after\n * being swapped to the left or swapping is disabled, it will be positioned to\n * the viewport right boundary.\n *\n * @internal\n */\n\nexport function createAnchoredRight(config) {\n  var screenRight = config.screenRight,\n      vwMargin = config.vwMargin,\n      elWidth = config.elWidth,\n      disableSwapping = config.disableSwapping;\n  var left = getRightCoord(config);\n  var actualX = \"right\";\n\n  if (left + elWidth <= screenRight) {\n    return {\n      actualX: actualX,\n      left: left\n    };\n  }\n\n  var swappedLeft = getLeftCoord(config);\n\n  if (disableSwapping || swappedLeft < vwMargin) {\n    left = screenRight - elWidth;\n  } else {\n    left = swappedLeft;\n    actualX = \"left\";\n  }\n\n  return {\n    actualX: actualX,\n    left: left\n  };\n}\n/**\n * @internal\n */\n\nexport function createEqualWidth(_a) {\n  var x = _a.x,\n      vw = _a.vw,\n      elWidth = _a.elWidth,\n      xMargin = _a.xMargin,\n      vwMargin = _a.vwMargin,\n      initialX = _a.initialX,\n      containerRect = _a.containerRect,\n      isMinWidth = _a.isMinWidth;\n  var left = initialX !== null && initialX !== void 0 ? initialX : containerRect.left + xMargin;\n  var width = containerRect.width - xMargin * 2;\n  var minWidth;\n  var right;\n\n  if (isMinWidth) {\n    minWidth = width;\n    width = undefined;\n\n    if (left + elWidth > vw - vwMargin) {\n      right = vwMargin;\n    }\n  } // going to assume that the container element is visible in the DOM and just\n  // make the fixed element have the same left and right corners\n\n\n  return {\n    left: left,\n    right: right,\n    width: width,\n    minWidth: minWidth,\n    actualX: x\n  };\n}\n/**\n * Creates the horizontal position for a fixed element with the provided\n * options.\n * @internal\n */\n\nexport function createHorizontalPosition(_a) {\n  var x = _a.x,\n      vw = _a.vw,\n      vwMargin = _a.vwMargin,\n      xMargin = _a.xMargin,\n      width = _a.width,\n      elWidth = _a.elWidth,\n      initialX = _a.initialX,\n      containerRect = _a.containerRect,\n      disableSwapping = _a.disableSwapping;\n\n  if (width === \"min\" || width === \"equal\") {\n    return createEqualWidth({\n      x: x,\n      vw: vw,\n      vwMargin: vwMargin,\n      xMargin: xMargin,\n      elWidth: elWidth,\n      initialX: initialX,\n      containerRect: containerRect,\n      isMinWidth: width === \"min\"\n    });\n  }\n\n  if (elWidth > vw - vwMargin * 2) {\n    // if the element's width is greater than the viewport's width minus the\n    // margin on both sides, just make the element span the entire viewport with\n    // the margin\n    return {\n      left: vwMargin,\n      right: vwMargin,\n      actualX: x\n    };\n  }\n\n  var config = {\n    vwMargin: vwMargin,\n    xMargin: xMargin,\n    elWidth: elWidth,\n    initialX: initialX,\n    screenRight: vw - vwMargin,\n    containerRect: containerRect,\n    disableSwapping: disableSwapping\n  };\n\n  switch (x) {\n    case \"left\":\n      return createAnchoredLeft(config);\n\n    case \"inner-left\":\n      return createAnchoredInnerLeft(config);\n\n    case \"center\":\n      return createAnchoredCenter(config);\n\n    case \"inner-right\":\n      return createAnchoredInnerRight(config);\n\n    case \"right\":\n      return createAnchoredRight(config);\n  }\n}","map":{"version":3,"mappings":"AACA,SACEA,eADF,EAEEC,iBAFF,EAGEC,kBAHF,EAIEC,YAJF,EAKEC,aALF,QAMO,YANP;AA8CA;;;;;;;;;;;AAUA,OAAM,SAAUC,kBAAV,CAA6BC,MAA7B,EAA8C;EAC1C,YAAQ,GAA4CA,MAAM,SAA1D;EAAA,IAAUC,WAAW,GAA+BD,MAAM,YAA1D;EAAA,IAAuBE,OAAO,GAAsBF,MAAM,QAA1D;EAAA,IAAgCG,eAAe,GAAKH,MAAM,gBAA1D;EAER,IAAII,IAAI,GAAGP,YAAY,CAACG,MAAD,CAAvB;EACA,IAAIK,OAAO,GAAuB,MAAlC;;EACA,IAAID,IAAI,IAAIE,QAAZ,EAAsB;IACpB,OAAO;MAAED,OAAO,SAAT;MAAWD,IAAI;IAAf,CAAP;EACD;;EAED,IAAMG,WAAW,GAAGT,aAAa,CAACE,MAAD,CAAjC;;EACA,IAAIG,eAAe,IAAII,WAAW,GAAGL,OAAd,GAAwBD,WAA/C,EAA4D;IAC1DG,IAAI,GAAGE,QAAP;EACD,CAFD,MAEO;IACLF,IAAI,GAAGG,WAAP;IACAF,OAAO,GAAG,OAAV;EACD;;EAED,OAAO;IAAEA,OAAO,SAAT;IAAWD,IAAI;EAAf,CAAP;AACD;AAED;;;;;;;;;;;AAUA,OAAM,SAAUI,uBAAV,CAAkCR,MAAlC,EAAmD;EAC/C,YAAQ,GAA4CA,MAAM,SAA1D;EAAA,IAAUC,WAAW,GAA+BD,MAAM,YAA1D;EAAA,IAAuBE,OAAO,GAAsBF,MAAM,QAA1D;EAAA,IAAgCG,eAAe,GAAKH,MAAM,gBAA1D;EAER,IAAII,IAAI,GAAGT,iBAAiB,CAACK,MAAD,CAA5B;EACA,IAAIK,OAAO,GAAuB,YAAlC;;EACA,IAAID,IAAI,GAAGF,OAAP,IAAkBD,WAAlB,IAAiCG,IAAI,IAAIE,QAA7C,EAAuD;IACrD,OAAO;MAAED,OAAO,SAAT;MAAWD,IAAI;IAAf,CAAP;EACD;;EAED,IAAID,eAAJ,EAAqB;IACnB,IAAIC,IAAI,GAAGF,OAAP,GAAiBD,WAArB,EAAkC;MAChCG,IAAI,GAAGH,WAAW,GAAGC,OAArB;IACD,CAFD,MAEO;MACLE,IAAI,GAAGE,QAAP;IACD;;IAED,OAAO;MAAED,OAAO,SAAT;MAAWD,IAAI;IAAf,CAAP;EACD;;EAED,IAAMG,WAAW,GAAGX,kBAAkB,CAACI,MAAD,CAAtC;;EACA,IAAIO,WAAW,GAAGD,QAAlB,EAA4B;IAC1BF,IAAI,GAAGE,QAAP;EACD,CAFD,MAEO,IAAIC,WAAW,GAAGL,OAAd,GAAwBD,WAA5B,EAAyC;IAC9CG,IAAI,GAAGH,WAAW,GAAGC,OAArB;IACAG,OAAO,GAAG,aAAV;EACD,CAHM,MAGA;IACLD,IAAI,GAAGG,WAAP;IACAF,OAAO,GAAG,aAAV;EACD;;EAED,OAAO;IAAEA,OAAO,SAAT;IAAWD,IAAI;EAAf,CAAP;AACD;AAED;;;;;;;;;;AASA,OAAM,SAAUK,oBAAV,CAA+BT,MAA/B,EAAgD;EAC5C,YAAQ,GAA2BA,MAAM,SAAzC;EAAA,IAAUC,WAAW,GAAcD,MAAM,YAAzC;EAAA,IAAuBE,OAAO,GAAKF,MAAM,QAAzC;EACR,IAAII,IAAI,GAAGV,eAAe,CAACM,MAAD,CAA1B;;EACA,IAAII,IAAI,GAAGE,QAAX,EAAqB;IACnBF,IAAI,GAAGE,QAAP;EACD,CAFD,MAEO,IAAIF,IAAI,GAAGF,OAAP,GAAiBD,WAAjB,IAAgCG,IAAI,GAAGE,QAA3C,EAAqD;IAC1DF,IAAI,GAAGH,WAAW,GAAGC,OAArB;EACD;;EAED,OAAO;IAAEG,OAAO,EAAE,QAAX;IAAqBD,IAAI;EAAzB,CAAP;AACD;AAED;;;;;;;;;;;AAUA,OAAM,SAAUM,wBAAV,CAAmCV,MAAnC,EAAoD;EAChD,eAAW,GAAyCA,MAAM,YAA1D;EAAA,IAAaM,QAAQ,GAA+BN,MAAM,SAA1D;EAAA,IAAuBE,OAAO,GAAsBF,MAAM,QAA1D;EAAA,IAAgCG,eAAe,GAAKH,MAAM,gBAA1D;EAER,IAAII,IAAI,GAAGR,kBAAkB,CAACI,MAAD,CAA7B;EACA,IAAIK,OAAO,GAAuB,aAAlC;;EACA,IAAID,IAAI,IAAIE,QAAZ,EAAsB;IACpB,OAAO;MAAED,OAAO,SAAT;MAAWD,IAAI,EAAEO,IAAI,CAACC,GAAL,CAASR,IAAT,EAAeH,WAAW,GAAGC,OAA7B;IAAjB,CAAP;EACD;;EAED,IAAMK,WAAW,GAAGZ,iBAAiB,CAACK,MAAD,CAArC;;EACA,IAAIG,eAAe,IAAII,WAAW,GAAGL,OAAd,GAAwBD,WAA/C,EAA4D;IAC1DG,IAAI,GAAGE,QAAP;EACD,CAFD,MAEO;IACLF,IAAI,GAAGO,IAAI,CAACE,GAAL,CAASN,WAAT,EAAsBD,QAAtB,CAAP;IACAD,OAAO,GAAG,YAAV;EACD;;EAED,OAAO;IAAEA,OAAO,SAAT;IAAWD,IAAI;EAAf,CAAP;AACD;AAED;;;;;;;;;;;AAUA,OAAM,SAAUU,mBAAV,CAA8Bd,MAA9B,EAA+C;EAC3C,eAAW,GAAyCA,MAAM,YAA1D;EAAA,IAAaM,QAAQ,GAA+BN,MAAM,SAA1D;EAAA,IAAuBE,OAAO,GAAsBF,MAAM,QAA1D;EAAA,IAAgCG,eAAe,GAAKH,MAAM,gBAA1D;EAER,IAAII,IAAI,GAAGN,aAAa,CAACE,MAAD,CAAxB;EACA,IAAIK,OAAO,GAAuB,OAAlC;;EACA,IAAID,IAAI,GAAGF,OAAP,IAAkBD,WAAtB,EAAmC;IACjC,OAAO;MAAEI,OAAO,SAAT;MAAWD,IAAI;IAAf,CAAP;EACD;;EAED,IAAMG,WAAW,GAAGV,YAAY,CAACG,MAAD,CAAhC;;EACA,IAAIG,eAAe,IAAII,WAAW,GAAGD,QAArC,EAA+C;IAC7CF,IAAI,GAAGH,WAAW,GAAGC,OAArB;EACD,CAFD,MAEO;IACLE,IAAI,GAAGG,WAAP;IACAF,OAAO,GAAG,MAAV;EACD;;EAED,OAAO;IAAEA,OAAO,SAAT;IAAWD,IAAI;EAAf,CAAP;AACD;AAgBD;;;;AAGA,OAAM,SAAUW,gBAAV,CAA2BC,EAA3B,EASc;MARlBC,CAAC;MACDC,EAAE;MACFhB,OAAO;MACPiB,OAAO;MACPb,QAAQ;MACRc,QAAQ;MACRC,aAAa;MACbC,UAAU;EAEV,IAAMlB,IAAI,GAAGgB,QAAQ,SAAR,YAAQ,WAAR,cAAYC,aAAa,CAACjB,IAAd,GAAqBe,OAA9C;EAEA,IAAII,KAAK,GAAuBF,aAAa,CAACE,KAAd,GAAsBJ,OAAO,GAAG,CAAhE;EACA,IAAIK,QAAJ;EACA,IAAIC,KAAJ;;EACA,IAAIH,UAAJ,EAAgB;IACdE,QAAQ,GAAGD,KAAX;IACAA,KAAK,GAAGG,SAAR;;IACA,IAAItB,IAAI,GAAGF,OAAP,GAAiBgB,EAAE,GAAGZ,QAA1B,EAAoC;MAClCmB,KAAK,GAAGnB,QAAR;IACD;EACF,CAZiB,CAclB;EACA;;;EACA,OAAO;IACLF,IAAI,MADC;IAELqB,KAAK,OAFA;IAGLF,KAAK,OAHA;IAILC,QAAQ,UAJH;IAKLnB,OAAO,EAAEY;EALJ,CAAP;AAOD;AAED;;;;;;AAKA,OAAM,SAAUU,wBAAV,CAAmCX,EAAnC,EAUI;MATRC,CAAC;MACDC,EAAE;MACFZ,QAAQ;MACRa,OAAO;MACPI,KAAK;MACLrB,OAAO;MACPkB,QAAQ;MACRC,aAAa;MACblB,eAAe;;EAEf,IAAIoB,KAAK,KAAK,KAAV,IAAmBA,KAAK,KAAK,OAAjC,EAA0C;IACxC,OAAOR,gBAAgB,CAAC;MACtBE,CAAC,GADqB;MAEtBC,EAAE,IAFoB;MAGtBZ,QAAQ,UAHc;MAItBa,OAAO,SAJe;MAKtBjB,OAAO,SALe;MAMtBkB,QAAQ,UANc;MAOtBC,aAAa,eAPS;MAQtBC,UAAU,EAAEC,KAAK,KAAK;IARA,CAAD,CAAvB;EAUD;;EAED,IAAIrB,OAAO,GAAGgB,EAAE,GAAGZ,QAAQ,GAAG,CAA9B,EAAiC;IAC/B;IACA;IACA;IACA,OAAO;MACLF,IAAI,EAAEE,QADD;MAELmB,KAAK,EAAEnB,QAFF;MAGLD,OAAO,EAAEY;IAHJ,CAAP;EAKD;;EAED,IAAMjB,MAAM,GAAc;IACxBM,QAAQ,UADgB;IAExBa,OAAO,SAFiB;IAGxBjB,OAAO,SAHiB;IAIxBkB,QAAQ,UAJgB;IAKxBnB,WAAW,EAAEiB,EAAE,GAAGZ,QALM;IAMxBe,aAAa,eANW;IAOxBlB,eAAe;EAPS,CAA1B;;EAUA,QAAQc,CAAR;IACE,KAAK,MAAL;MACE,OAAOlB,kBAAkB,CAACC,MAAD,CAAzB;;IACF,KAAK,YAAL;MACE,OAAOQ,uBAAuB,CAACR,MAAD,CAA9B;;IACF,KAAK,QAAL;MACE,OAAOS,oBAAoB,CAACT,MAAD,CAA3B;;IACF,KAAK,aAAL;MACE,OAAOU,wBAAwB,CAACV,MAAD,CAA/B;;IACF,KAAK,OAAL;MACE,OAAOc,mBAAmB,CAACd,MAAD,CAA1B;EAVJ;AAYD","names":["getCenterXCoord","getInnerLeftCoord","getInnerRightCoord","getLeftCoord","getRightCoord","createAnchoredLeft","config","screenRight","elWidth","disableSwapping","left","actualX","vwMargin","swappedLeft","createAnchoredInnerLeft","createAnchoredCenter","createAnchoredInnerRight","Math","min","max","createAnchoredRight","createEqualWidth","_a","x","vw","xMargin","initialX","containerRect","isMinWidth","width","minWidth","right","undefined","createHorizontalPosition"],"sources":["C:\\Users\\hungr\\Documents\\VS-CODE\\notes-react\\node_modules\\@react-md\\utils\\src\\positioning\\createHorizontalPosition.ts"],"sourcesContent":["import type { XCoordConfig } from \"./getCoord\";\nimport {\n  getCenterXCoord,\n  getInnerLeftCoord,\n  getInnerRightCoord,\n  getLeftCoord,\n  getRightCoord,\n} from \"./getCoord\";\nimport type { FixedPositionOptions, HorizontalPosition } from \"./types\";\n\n/**\n * @internal\n */\ninterface XPosition {\n  left: number;\n  right?: number;\n  width?: number;\n  minWidth?: number;\n  actualX: HorizontalPosition;\n}\n\n/**\n * @internal\n */\nexport interface FixConfig extends XCoordConfig {\n  vwMargin: number;\n  screenRight: number;\n  disableSwapping: boolean;\n}\n\n/**\n * @internal\n */\ninterface Options\n  extends Required<\n    Pick<\n      FixedPositionOptions,\n      \"vwMargin\" | \"xMargin\" | \"width\" | \"disableSwapping\"\n    >\n  > {\n  x: HorizontalPosition;\n  vw: number;\n  elWidth: number;\n  initialX?: number;\n  containerRect: DOMRect;\n}\n\n/**\n * Attempts to position the fixed element so that it will appear to the left of\n * the container element but also within the viewport boundaries. When swapping\n * is enabled, it will attempt to swap to the right position if it can't fit\n * within the viewport to the left. If it can't fit in the viewport even after\n * being swapped to the right or swapping is disabled, it will be positioned to\n * the viewport left boundary.\n *\n * @internal\n */\nexport function createAnchoredLeft(config: FixConfig): XPosition {\n  const { vwMargin, screenRight, elWidth, disableSwapping } = config;\n\n  let left = getLeftCoord(config);\n  let actualX: HorizontalPosition = \"left\";\n  if (left >= vwMargin) {\n    return { actualX, left };\n  }\n\n  const swappedLeft = getRightCoord(config);\n  if (disableSwapping || swappedLeft + elWidth > screenRight) {\n    left = vwMargin;\n  } else {\n    left = swappedLeft;\n    actualX = \"right\";\n  }\n\n  return { actualX, left };\n}\n\n/**\n * Attempts to position the fixed element so that it will appear to the\n * inner-left of the container element but also within the viewport boundaries.\n * When swapping is enabled, it will attempt to swap to the right position if it\n * can't fit within the viewport to the left. If it can't fit in the viewport\n * even after being swapped to the right or swapping is disabled, it will be\n * positioned to the viewport left boundary.\n *\n * @internal\n */\nexport function createAnchoredInnerLeft(config: FixConfig): XPosition {\n  const { vwMargin, screenRight, elWidth, disableSwapping } = config;\n\n  let left = getInnerLeftCoord(config);\n  let actualX: HorizontalPosition = \"inner-left\";\n  if (left + elWidth <= screenRight && left >= vwMargin) {\n    return { actualX, left };\n  }\n\n  if (disableSwapping) {\n    if (left + elWidth > screenRight) {\n      left = screenRight - elWidth;\n    } else {\n      left = vwMargin;\n    }\n\n    return { actualX, left };\n  }\n\n  const swappedLeft = getInnerRightCoord(config);\n  if (swappedLeft < vwMargin) {\n    left = vwMargin;\n  } else if (swappedLeft + elWidth > screenRight) {\n    left = screenRight - elWidth;\n    actualX = \"inner-right\";\n  } else {\n    left = swappedLeft;\n    actualX = \"inner-right\";\n  }\n\n  return { actualX, left };\n}\n\n/**\n * Attempts to position the fixed element so that it will appear at the center\n * of the container element but also within the viewport boundaries. If the\n * centered element can't fit within the viewport, it will use the vwMargin\n * value if it overflowed to the left, it'll position to the screen right\n * boundary.\n *\n * @internal\n */\nexport function createAnchoredCenter(config: FixConfig): XPosition {\n  const { vwMargin, screenRight, elWidth } = config;\n  let left = getCenterXCoord(config);\n  if (left < vwMargin) {\n    left = vwMargin;\n  } else if (left + elWidth > screenRight || left < vwMargin) {\n    left = screenRight - elWidth;\n  }\n\n  return { actualX: \"center\", left };\n}\n\n/**\n * Attempts to position the fixed element so that it will appear to the\n * inner-right of the container element but also within the viewport boundaries.\n * When swapping is enabled, it will attempt to swap to the inner-left position\n * if it can't fit within the viewport to the right. If it can't fit in the\n * viewport even after being swapped to the left or swapping is disabled, it\n * will be positioned to the viewport right boundary.\n *\n * @internal\n */\nexport function createAnchoredInnerRight(config: FixConfig): XPosition {\n  const { screenRight, vwMargin, elWidth, disableSwapping } = config;\n\n  let left = getInnerRightCoord(config);\n  let actualX: HorizontalPosition = \"inner-right\";\n  if (left >= vwMargin) {\n    return { actualX, left: Math.min(left, screenRight - elWidth) };\n  }\n\n  const swappedLeft = getInnerLeftCoord(config);\n  if (disableSwapping || swappedLeft + elWidth > screenRight) {\n    left = vwMargin;\n  } else {\n    left = Math.max(swappedLeft, vwMargin);\n    actualX = \"inner-left\";\n  }\n\n  return { actualX, left };\n}\n\n/**\n * Attempts to position the fixed element so that it will appear to the right of\n * the container element but also within the viewport boundaries. When swapping\n * is enabled, it will attempt to swap to the left position if it can't fit\n * within the viewport to the right. If it can't fit in the viewport even after\n * being swapped to the left or swapping is disabled, it will be positioned to\n * the viewport right boundary.\n *\n * @internal\n */\nexport function createAnchoredRight(config: FixConfig): XPosition {\n  const { screenRight, vwMargin, elWidth, disableSwapping } = config;\n\n  let left = getRightCoord(config);\n  let actualX: HorizontalPosition = \"right\";\n  if (left + elWidth <= screenRight) {\n    return { actualX, left };\n  }\n\n  const swappedLeft = getLeftCoord(config);\n  if (disableSwapping || swappedLeft < vwMargin) {\n    left = screenRight - elWidth;\n  } else {\n    left = swappedLeft;\n    actualX = \"left\";\n  }\n\n  return { actualX, left };\n}\n\ninterface EqualWidthOptions\n  extends Pick<\n    Options,\n    | \"x\"\n    | \"vw\"\n    | \"elWidth\"\n    | \"xMargin\"\n    | \"vwMargin\"\n    | \"containerRect\"\n    | \"initialX\"\n  > {\n  isMinWidth: boolean;\n}\n\n/**\n * @internal\n */\nexport function createEqualWidth({\n  x,\n  vw,\n  elWidth,\n  xMargin,\n  vwMargin,\n  initialX,\n  containerRect,\n  isMinWidth,\n}: EqualWidthOptions): XPosition {\n  const left = initialX ?? containerRect.left + xMargin;\n\n  let width: number | undefined = containerRect.width - xMargin * 2;\n  let minWidth: number | undefined;\n  let right: number | undefined;\n  if (isMinWidth) {\n    minWidth = width;\n    width = undefined;\n    if (left + elWidth > vw - vwMargin) {\n      right = vwMargin;\n    }\n  }\n\n  // going to assume that the container element is visible in the DOM and just\n  // make the fixed element have the same left and right corners\n  return {\n    left,\n    right,\n    width,\n    minWidth,\n    actualX: x,\n  };\n}\n\n/**\n * Creates the horizontal position for a fixed element with the provided\n * options.\n * @internal\n */\nexport function createHorizontalPosition({\n  x,\n  vw,\n  vwMargin,\n  xMargin,\n  width,\n  elWidth,\n  initialX,\n  containerRect,\n  disableSwapping,\n}: Options): XPosition {\n  if (width === \"min\" || width === \"equal\") {\n    return createEqualWidth({\n      x,\n      vw,\n      vwMargin,\n      xMargin,\n      elWidth,\n      initialX,\n      containerRect,\n      isMinWidth: width === \"min\",\n    });\n  }\n\n  if (elWidth > vw - vwMargin * 2) {\n    // if the element's width is greater than the viewport's width minus the\n    // margin on both sides, just make the element span the entire viewport with\n    // the margin\n    return {\n      left: vwMargin,\n      right: vwMargin,\n      actualX: x,\n    };\n  }\n\n  const config: FixConfig = {\n    vwMargin,\n    xMargin,\n    elWidth,\n    initialX,\n    screenRight: vw - vwMargin,\n    containerRect,\n    disableSwapping,\n  };\n\n  switch (x) {\n    case \"left\":\n      return createAnchoredLeft(config);\n    case \"inner-left\":\n      return createAnchoredInnerLeft(config);\n    case \"center\":\n      return createAnchoredCenter(config);\n    case \"inner-right\":\n      return createAnchoredInnerRight(config);\n    case \"right\":\n      return createAnchoredRight(config);\n  }\n}\n"]},"metadata":{},"sourceType":"module"}