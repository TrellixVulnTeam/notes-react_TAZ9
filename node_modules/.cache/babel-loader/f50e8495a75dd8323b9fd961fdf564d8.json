{"ast":null,"code":"var __assign = this && this.__assign || function () {\n  __assign = Object.assign || function (t) {\n    for (var s, i = 1, n = arguments.length; i < n; i++) {\n      s = arguments[i];\n\n      for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p)) t[p] = s[p];\n    }\n\n    return t;\n  };\n\n  return __assign.apply(this, arguments);\n};\n\nvar __rest = this && this.__rest || function (s, e) {\n  var t = {};\n\n  for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0) t[p] = s[p];\n\n  if (s != null && typeof Object.getOwnPropertySymbols === \"function\") for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {\n    if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i])) t[p[i]] = s[p[i]];\n  }\n  return t;\n};\n\nimport { jsx as _jsx } from \"react/jsx-runtime\";\nimport { forwardRef, useRef } from \"react\";\nimport cn from \"classnames\";\nimport { DEFAULT_SHEET_TIMEOUT } from \"@react-md/sheet\";\nimport { useCSSTransition } from \"@react-md/transition\";\nimport { bem, useIsUserInteractionMode } from \"@react-md/utils\";\nimport { DEFAULT_LAYOUT_MAIN_CLASSNAMES } from \"./constants\";\nimport { useLayoutConfig } from \"./LayoutProvider\";\nimport { isTemporaryLayout, isToggleableLayout } from \"./utils\";\nvar styles = bem(\"rmd-layout-main\");\n/**\n * This is the `<main>` element for your app that has some built in styles to be\n * able to update based on the current layout types.\n */\n\nexport var LayoutMain = forwardRef(function LayoutMain(_a, nodeRef) {\n  var className = _a.className,\n      propTabIndex = _a.tabIndex,\n      _b = _a.component,\n      Component = _b === void 0 ? \"main\" : _b,\n      propNavOffset = _a.navOffset,\n      _c = _a.headerOffset,\n      headerOffset = _c === void 0 ? false : _c,\n      _d = _a.timeout,\n      propTimeout = _d === void 0 ? DEFAULT_SHEET_TIMEOUT : _d,\n      _e = _a.classNames,\n      classNames = _e === void 0 ? DEFAULT_LAYOUT_MAIN_CLASSNAMES : _e,\n      _f = _a.mini,\n      mini = _f === void 0 ? false : _f,\n      _g = _a.miniHidden,\n      miniHidden = _g === void 0 ? false : _g,\n      props = __rest(_a, [\"className\", \"tabIndex\", \"component\", \"navOffset\", \"headerOffset\", \"timeout\", \"classNames\", \"mini\", \"miniHidden\"]); // this makes it so that the SkipToMainContent button can still\n  // focus the `<main>` element, but the `<main>` will no longer be\n  // focused if the user clicks inside. This is super nice since one\n  // of my bigger patterns is to click somewhere then press tab to\n  // focus a specific element. Without this fix, the first element in\n  // the `<main>` tag would be focused instead of the closest focusable\n  // element to the click area.\n\n\n  var tabIndex = propTabIndex;\n\n  if (useIsUserInteractionMode(\"keyboard\") && typeof propTabIndex === \"undefined\") {\n    tabIndex = -1;\n  }\n\n  var _h = useLayoutConfig(),\n      layout = _h.layout,\n      visible = _h.visible,\n      fixedAppBar = _h.fixedAppBar;\n\n  var navOffset = propNavOffset;\n\n  if (typeof navOffset === \"undefined\") {\n    navOffset = visible && !isTemporaryLayout(layout);\n  }\n\n  var timeout = propTimeout;\n  var prevLayout = useRef(layout);\n\n  if (prevLayout.current !== layout) {\n    // this is kind of weird and hacky, but this will allow for the required\n    // classnames to be applied to the main element based on the current\n    // layout type without needing a unique `key` for the main content. this\n    // is super nice since we really don't want to remount the full app each\n    // time the layout changes.\n    timeout = 0;\n  }\n\n  var isMini = mini && (fixedAppBar || miniHidden);\n  var isMiniOffset = mini && navOffset && !fixedAppBar && visible && isToggleableLayout(layout);\n  var elementProps = useCSSTransition({\n    nodeRef: nodeRef,\n    transitionIn: !!navOffset,\n    temporary: false,\n    className: cn(styles({\n      mini: isMini && (isTemporaryLayout(layout) || !visible),\n      \"nav-offset\": isMini,\n      \"mini-offset\": isMiniOffset,\n      \"header-offset\": headerOffset\n    }), className),\n    timeout: timeout,\n    classNames: classNames,\n    onEntered: function () {\n      prevLayout.current = layout;\n    },\n    onExited: function () {\n      prevLayout.current = layout;\n    }\n  }).elementProps;\n  return _jsx(Component, __assign({}, props, elementProps, {\n    tabIndex: tabIndex\n  }));\n});","map":{"version":3,"mappings":"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","names":["forwardRef","useRef","cn","DEFAULT_SHEET_TIMEOUT","useCSSTransition","bem","useIsUserInteractionMode","DEFAULT_LAYOUT_MAIN_CLASSNAMES","useLayoutConfig","isTemporaryLayout","isToggleableLayout","styles","LayoutMain","_a","nodeRef","propTabIndex","_b","Component","propNavOffset","_c","headerOffset","_d","propTimeout","_e","classNames","_f","mini","_g","miniHidden","props","tabIndex","layout","visible","fixedAppBar","navOffset","timeout","prevLayout","current","isMini","isMiniOffset","transitionIn","temporary","className","onEntered","onExited","elementProps","_jsx","__assign"],"sources":["C:\\Users\\hungr\\Documents\\VS-CODE\\notes-react\\node_modules\\@react-md\\layout\\src\\LayoutMain.tsx"],"sourcesContent":["import type { HTMLAttributes } from \"react\";\nimport { forwardRef, useRef } from \"react\";\nimport cn from \"classnames\";\nimport { DEFAULT_SHEET_TIMEOUT } from \"@react-md/sheet\";\nimport type {\n  CSSTransitionClassNames,\n  TransitionTimeout,\n} from \"@react-md/transition\";\nimport { useCSSTransition } from \"@react-md/transition\";\nimport { bem, useIsUserInteractionMode } from \"@react-md/utils\";\n\nimport { DEFAULT_LAYOUT_MAIN_CLASSNAMES } from \"./constants\";\nimport { useLayoutConfig } from \"./LayoutProvider\";\nimport { isTemporaryLayout, isToggleableLayout } from \"./utils\";\n\nexport interface LayoutMainProps extends HTMLAttributes<HTMLDivElement> {\n  /**\n   * The component to render the main element as. This should normally stay as\n   * the default of `\"main\"`, but if you want to have multiple `Layout` on the\n   * page for some reason, you'll need to use `\"div\"` for the other `Layout`s\n   * since you can only have one `<main>` per page (unless you set the `hidden`\n   * attribute on all the others).\n   */\n  component?: \"div\" | \"main\";\n\n  /**\n   * Boolean if the main element should be offset by the current navigation\n   * tree's width.\n   */\n  navOffset?: boolean;\n\n  /**\n   * Boolean if the main element should be offset by the `AppBar`'s height\n   */\n  headerOffset?: boolean;\n\n  /**\n   * Boolean of there is a mini nav visible within the layout. This makes sure\n   * that the content if offset by the current nav's width when needed.\n   *\n   * @remarks \\@since 2.7.0\n   */\n  mini?: boolean;\n\n  /**\n   * Boolean if the mini layout is currently hidden to help determine if\n   * specific mini styles should be applied when the {@link LayoutContext.fixedAppBar}\n   * config is `false`.\n   *\n   * @internal\n   * @remarks \\@since 2.8.3\n   */\n  miniHidden?: boolean;\n\n  /**\n   * The transition timeout to use for the toggleable `LayoutNavigation` either\n   * comes into view or expands from mini to full-width. The transition can be\n   * disabled by setting this value to `0`.\n   */\n  timeout?: TransitionTimeout;\n\n  /**\n   * The transition classnames to use for the toggleable `LayoutNavigation`\n   * either comes into view or expands from mini to full-width.\n   */\n  classNames?: CSSTransitionClassNames;\n}\n\nconst styles = bem(\"rmd-layout-main\");\n\n/**\n * This is the `<main>` element for your app that has some built in styles to be\n * able to update based on the current layout types.\n */\nexport const LayoutMain = forwardRef<HTMLDivElement, LayoutMainProps>(\n  function LayoutMain(\n    {\n      className,\n      tabIndex: propTabIndex,\n      component: Component = \"main\",\n      navOffset: propNavOffset,\n      headerOffset = false,\n      timeout: propTimeout = DEFAULT_SHEET_TIMEOUT,\n      classNames = DEFAULT_LAYOUT_MAIN_CLASSNAMES,\n      mini = false,\n      miniHidden = false,\n      ...props\n    },\n    nodeRef\n  ) {\n    // this makes it so that the SkipToMainContent button can still\n    // focus the `<main>` element, but the `<main>` will no longer be\n    // focused if the user clicks inside. This is super nice since one\n    // of my bigger patterns is to click somewhere then press tab to\n    // focus a specific element. Without this fix, the first element in\n    // the `<main>` tag would be focused instead of the closest focusable\n    // element to the click area.\n    let tabIndex = propTabIndex;\n    if (\n      useIsUserInteractionMode(\"keyboard\") &&\n      typeof propTabIndex === \"undefined\"\n    ) {\n      tabIndex = -1;\n    }\n\n    const { layout, visible, fixedAppBar } = useLayoutConfig();\n    let navOffset = propNavOffset;\n    if (typeof navOffset === \"undefined\") {\n      navOffset = visible && !isTemporaryLayout(layout);\n    }\n\n    let timeout = propTimeout;\n    const prevLayout = useRef(layout);\n    if (prevLayout.current !== layout) {\n      // this is kind of weird and hacky, but this will allow for the required\n      // classnames to be applied to the main element based on the current\n      // layout type without needing a unique `key` for the main content. this\n      // is super nice since we really don't want to remount the full app each\n      // time the layout changes.\n      timeout = 0;\n    }\n\n    const isMini = mini && (fixedAppBar || miniHidden);\n    const isMiniOffset =\n      mini &&\n      navOffset &&\n      !fixedAppBar &&\n      visible &&\n      isToggleableLayout(layout);\n\n    const { elementProps } = useCSSTransition<HTMLDivElement>({\n      nodeRef,\n      transitionIn: !!navOffset,\n      temporary: false,\n      className: cn(\n        styles({\n          mini: isMini && (isTemporaryLayout(layout) || !visible),\n          \"nav-offset\": isMini,\n          \"mini-offset\": isMiniOffset,\n          \"header-offset\": headerOffset,\n        }),\n        className\n      ),\n      timeout,\n      classNames,\n      onEntered: () => {\n        prevLayout.current = layout;\n      },\n      onExited: () => {\n        prevLayout.current = layout;\n      },\n    });\n\n    return <Component {...props} {...elementProps} tabIndex={tabIndex} />;\n  }\n);\n"]},"metadata":{},"sourceType":"module"}