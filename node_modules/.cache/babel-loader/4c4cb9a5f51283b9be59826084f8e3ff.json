{"ast":null,"code":"var __assign = this && this.__assign || function () {\n  __assign = Object.assign || function (t) {\n    for (var s, i = 1, n = arguments.length; i < n; i++) {\n      s = arguments[i];\n\n      for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p)) t[p] = s[p];\n    }\n\n    return t;\n  };\n\n  return __assign.apply(this, arguments);\n};\n\nvar __read = this && this.__read || function (o, n) {\n  var m = typeof Symbol === \"function\" && o[Symbol.iterator];\n  if (!m) return o;\n  var i = m.call(o),\n      r,\n      ar = [],\n      e;\n\n  try {\n    while ((n === void 0 || n-- > 0) && !(r = i.next()).done) ar.push(r.value);\n  } catch (error) {\n    e = {\n      error: error\n    };\n  } finally {\n    try {\n      if (r && !r.done && (m = i[\"return\"])) m.call(i);\n    } finally {\n      if (e) throw e.error;\n    }\n  }\n\n  return ar;\n};\n\nimport { jsx as _jsx } from \"react/jsx-runtime\";\nimport { createContext, useCallback, useContext, useMemo, useState } from \"react\";\n\nvar noop = function () {// do nothing\n};\n\nvar context = createContext({\n  stack: [],\n  add: noop,\n  remove: noop\n});\n/* istanbul ignore next */\n\nif (process.env.NODE_ENV !== \"production\") {\n  context.displayName = \"NestedDialogContext\";\n}\n\nvar Provider = context.Provider;\n/**\n * This component is used to help with handling nested dialogs by:\n * - preventing all dialogs to be closed when the escape key is pressed\n * - hiding the overlays for dialogs that are not the top-most focus\n *\n * This should be added to the root of your app if you would like to enable this\n * feature.\n */\n\nexport function NestedDialogContextProvider(_a) {\n  var children = _a.children;\n\n  var _b = __read(useState([]), 2),\n      stack = _b[0],\n      setStack = _b[1];\n\n  var add = useCallback(function (dialogId) {\n    setStack(function (prevStack) {\n      /* istanbul ignore next */\n      if (process.env.NODE_ENV !== \"production\" && prevStack.includes(dialogId)) {\n        /* eslint-disable no-console */\n        console.warn(\"Tried to add a duplicate dialog id to the `NestedDialogContext`.\");\n        console.warn(\"This means that you have two dialogs with the same id: `\".concat(dialogId, \"`.\"));\n        console.warn(\"This should be fixed before moving to production since this will break accessibility and is technically invalid.\");\n      }\n\n      return prevStack.concat(dialogId);\n    });\n  }, []);\n  var remove = useCallback(function (dialogId) {\n    setStack(function (prevStack) {\n      return prevStack.filter(function (id) {\n        return id !== dialogId;\n      });\n    });\n  }, []);\n  var value = useMemo(function () {\n    return {\n      stack: stack,\n      add: add,\n      remove: remove\n    };\n  }, [add, remove, stack]);\n  return _jsx(Provider, __assign({\n    value: value\n  }, {\n    children: children\n  }));\n}\n/**\n * Gets the current nested dialog context. This shouldn't really be used\n * externally and is a private context hook.\n *\n * @internal\n */\n\nexport function useNestedDialogContext() {\n  return useContext(context);\n}","map":{"version":3,"mappings":";;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AACA,SACEA,aADF,EAEEC,WAFF,EAGEC,UAHF,EAIEC,OAJF,EAKEC,QALF,QAMO,OANP;;AAcA,IAAMC,IAAI,GAAG,aACX;AACD,CAFD;;AAIA,IAAMC,OAAO,GAAGN,aAAa,CAAsB;EACjDO,KAAK,EAAE,EAD0C;EAEjDC,GAAG,EAAEH,IAF4C;EAGjDI,MAAM,EAAEJ;AAHyC,CAAtB,CAA7B;AAMA;;AACA,IAAIK,OAAO,CAACC,GAAR,CAAYC,QAAZ,KAAyB,YAA7B,EAA2C;EACzCN,OAAO,CAACO,WAAR,GAAsB,qBAAtB;AACD;;AAEO,YAAQ,GAAKP,OAAO,SAApB;AAMR;;;;;;;;;AAQA,OAAM,SAAUQ,2BAAV,CAAsCC,EAAtC,EAE6B;MADjCC,QAAQ;;EAEF,gBAAoBZ,QAAQ,CAAoB,EAApB,CAA5B,EAAmD,CAAnD;EAAA,IAACG,KAAK,QAAN;EAAA,IAAQU,QAAQ,QAAhB;;EACN,IAAMT,GAAG,GAAGP,WAAW,CAAC,UAACiB,QAAD,EAAiB;IACvCD,QAAQ,CAAC,UAACE,SAAD,EAAU;MACjB;MACA,IACET,OAAO,CAACC,GAAR,CAAYC,QAAZ,KAAyB,YAAzB,IACAO,SAAS,CAACC,QAAV,CAAmBF,QAAnB,CAFF,EAGE;QACA;QACAG,OAAO,CAACC,IAAR,CACE,kEADF;QAGAD,OAAO,CAACC,IAAR,CACE,kEAA4DJ,QAA5D,EAAoE,IAApE,CADF;QAGAG,OAAO,CAACC,IAAR,CACE,kHADF;MAGD;;MAED,OAAOH,SAAS,CAACI,MAAV,CAAiBL,QAAjB,CAAP;IACD,CAnBO,CAAR;EAoBD,CArBsB,EAqBpB,EArBoB,CAAvB;EAsBA,IAAMT,MAAM,GAAGR,WAAW,CAAC,UAACiB,QAAD,EAAiB;IAC1CD,QAAQ,CAAC,UAACE,SAAD,EAAU;MAAK,gBAAS,CAACK,MAAV,CAAiB,UAACC,EAAD,EAAG;QAAK,SAAE,KAAKP,QAAP;MAAe,CAAxC;IAAyC,CAAzD,CAAR;EACD,CAFyB,EAEvB,EAFuB,CAA1B;EAGA,IAAMQ,KAAK,GAAGvB,OAAO,CAAC;IAAM,OAAC;MAAEI,KAAK,OAAP;MAASC,GAAG,KAAZ;MAAcC,MAAM;IAApB,CAAD;EAAwB,CAA/B,EAAiC,CAACD,GAAD,EAAMC,MAAN,EAAcF,KAAd,CAAjC,CAArB;EAEA,OAAOoB,KAACC,QAAD,EAASC;IAACH,KAAK,EAAEA;EAAR,GAAa;IAAAV,UAAGA;EAAH,CAAb,CAAT,CAAP;AACD;AAED;;;;;;;AAMA,OAAM,SAAUc,sBAAV,GAAgC;EACpC,OAAO5B,UAAU,CAACI,OAAD,CAAjB;AACD","names":["createContext","useCallback","useContext","useMemo","useState","noop","context","stack","add","remove","process","env","NODE_ENV","displayName","NestedDialogContextProvider","_a","children","setStack","dialogId","prevStack","includes","console","warn","concat","filter","id","value","_jsx","Provider","__assign","useNestedDialogContext"],"sources":["C:\\Users\\hungr\\Documents\\VS-CODE\\notes-react\\node_modules\\@react-md\\dialog\\src\\NestedDialogContext.tsx"],"sourcesContent":["import type { ReactElement, ReactNode } from \"react\";\nimport {\n  createContext,\n  useCallback,\n  useContext,\n  useMemo,\n  useState,\n} from \"react\";\n\ninterface NestedDialogContext {\n  stack: readonly string[];\n  add: (dialogId: string) => void;\n  remove: (dialogId: string) => void;\n}\n\nconst noop = (): void => {\n  // do nothing\n};\n\nconst context = createContext<NestedDialogContext>({\n  stack: [],\n  add: noop,\n  remove: noop,\n});\n\n/* istanbul ignore next */\nif (process.env.NODE_ENV !== \"production\") {\n  context.displayName = \"NestedDialogContext\";\n}\n\nconst { Provider } = context;\n\nexport interface NestedDialogContextProviderProps {\n  children: ReactNode;\n}\n\n/**\n * This component is used to help with handling nested dialogs by:\n * - preventing all dialogs to be closed when the escape key is pressed\n * - hiding the overlays for dialogs that are not the top-most focus\n *\n * This should be added to the root of your app if you would like to enable this\n * feature.\n */\nexport function NestedDialogContextProvider({\n  children,\n}: NestedDialogContextProviderProps): ReactElement {\n  const [stack, setStack] = useState<readonly string[]>([]);\n  const add = useCallback((dialogId: string) => {\n    setStack((prevStack) => {\n      /* istanbul ignore next */\n      if (\n        process.env.NODE_ENV !== \"production\" &&\n        prevStack.includes(dialogId)\n      ) {\n        /* eslint-disable no-console */\n        console.warn(\n          \"Tried to add a duplicate dialog id to the `NestedDialogContext`.\"\n        );\n        console.warn(\n          `This means that you have two dialogs with the same id: \\`${dialogId}\\`.`\n        );\n        console.warn(\n          \"This should be fixed before moving to production since this will break accessibility and is technically invalid.\"\n        );\n      }\n\n      return prevStack.concat(dialogId);\n    });\n  }, []);\n  const remove = useCallback((dialogId: string) => {\n    setStack((prevStack) => prevStack.filter((id) => id !== dialogId));\n  }, []);\n  const value = useMemo(() => ({ stack, add, remove }), [add, remove, stack]);\n\n  return <Provider value={value}>{children}</Provider>;\n}\n\n/**\n * Gets the current nested dialog context. This shouldn't really be used\n * externally and is a private context hook.\n *\n * @internal\n */\nexport function useNestedDialogContext(): NestedDialogContext {\n  return useContext(context);\n}\n"]},"metadata":{},"sourceType":"module"}