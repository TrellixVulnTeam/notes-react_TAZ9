{"ast":null,"code":"var __assign = this && this.__assign || function () {\n  __assign = Object.assign || function (t) {\n    for (var s, i = 1, n = arguments.length; i < n; i++) {\n      s = arguments[i];\n\n      for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p)) t[p] = s[p];\n    }\n\n    return t;\n  };\n\n  return __assign.apply(this, arguments);\n};\n\nvar __read = this && this.__read || function (o, n) {\n  var m = typeof Symbol === \"function\" && o[Symbol.iterator];\n  if (!m) return o;\n  var i = m.call(o),\n      r,\n      ar = [],\n      e;\n\n  try {\n    while ((n === void 0 || n-- > 0) && !(r = i.next()).done) ar.push(r.value);\n  } catch (error) {\n    e = {\n      error: error\n    };\n  } finally {\n    try {\n      if (r && !r.done && (m = i[\"return\"])) m.call(i);\n    } finally {\n      if (e) throw e.error;\n    }\n  }\n\n  return ar;\n};\n\nimport { createContext, useCallback, useContext, useState } from \"react\";\nimport cn from \"classnames\";\nimport { useResizeObserver } from \"../sizing/useResizeObserver\";\nimport { useEnsuredRef } from \"../useEnsuredRef\";\nimport { scrollbarSize } from \"./scrollbarSize\";\n/**\n * This is the css variable that is used store the current size of each cell.\n */\n\nexport var CELL_SIZE_VAR = \"--rmd-cell-size\";\n/**\n * This is the css variable that is used store the current margin of each cell.\n */\n\nexport var CELL_MARGIN_VAR = \"--rmd-cell-margin\";\n/**\n * @remarks \\@since 2.3.0\n */\n\nexport var DEFAULT_GRID_LIST_MAX_CELL_SIZE = 150;\n/**\n * @remarks \\@since 2.3.0\n */\n\nexport var DEFAULT_GRID_LIST_PADDING = 16;\nvar context = createContext({\n  columns: -1,\n  cellWidth: -1\n});\n/**\n * @remarks \\@since 2.3.0\n */\n\nexport var GridListSizeProvider = context.Provider;\n\nif (process.env.NODE_ENV !== \"production\") {\n  context.displayName = \"GridListSizeProvider\";\n}\n/**\n * Gets the current size of each cell within the `GridList` component. If this\n * is used without a parent `GridList` component, `-1` is returned instead.\n *\n * @remarks \\@since 2.3.0\n */\n\n\nexport function useGridListSize() {\n  return useContext(context);\n}\n/**\n * The `useGridList` hook allows you to get all the grid and sizing\n * functionality of the `GridList` component without needing to wrap your\n * children in a `<div>` element.\n *\n * Example:\n *\n * ```tsx\n * const [gridListProps] = useGridList({\n *   cellMargin: 16,\n *   maxCellSize: 300,\n *   containerPadding: 4,\n * });\n *\n * return <div {...gridListProps}>{children}</div>;\n * ```\n *\n * Note: You must manually provide the `gridSize` to the `GridListSizeProvider`\n * component that was added in 2.3.0 if you want to use the `useGridSize` hook.\n *\n * Example:\n *\n * ```tsx\n * const [gridListProps, gridSize] = useGridList()\n *\n * return (\n *   <GridListSizeProvider value={gridSize}>\n *     <MyComponent {...gridListProps} />\n *   </GridListSizeProvider>\n * );\n * ```\n *\n * @remarks \\@since 2.3.0\n */\n\nexport function useGridList(_a) {\n  var _b;\n\n  var _c = _a === void 0 ? {} : _a,\n      propRef = _c.ref,\n      style = _c.style,\n      className = _c.className,\n      cellMargin = _c.cellMargin,\n      defaultSize = _c.defaultSize,\n      _d = _c.maxCellSize,\n      maxCellSize = _d === void 0 ? DEFAULT_GRID_LIST_MAX_CELL_SIZE : _d,\n      _e = _c.disableHeight,\n      disableHeight = _e === void 0 ? false : _e,\n      _f = _c.disableWidth,\n      disableWidth = _f === void 0 ? false : _f,\n      _g = _c.containerPadding,\n      containerPadding = _g === void 0 ? DEFAULT_GRID_LIST_PADDING : _g;\n\n  var _h = __read(useEnsuredRef(propRef), 2),\n      ref = _h[0],\n      mergedRef = _h[1];\n\n  var _j = __read(useState(defaultSize || {\n    columns: -1,\n    cellWidth: maxCellSize\n  }), 2),\n      gridSize = _j[0],\n      setGridSize = _j[1];\n\n  var recalculate = useCallback(function () {\n    var target = ref.current;\n\n    if (!target) {\n      return;\n    } // need to use rect instead of offsetWidth since we need decimal precision\n    // for the width since offsetWidth is basically Math.ceil(width). the\n    // calculations for max columns will be off on high-pixel-density monitors\n    // or some zoom levels.\n\n\n    var width = target.getBoundingClientRect().width;\n    width -= containerPadding; // just need to see if there is a scrollbar visible and subtract that width.\n    // don't need decimal precision here since both values will be rounded\n\n    if (target.offsetHeight < target.scrollHeight) {\n      width -= scrollbarSize(\"width\");\n    }\n\n    var columns = Math.ceil(width / maxCellSize);\n    setGridSize({\n      cellWidth: width / columns,\n      columns: columns\n    });\n  }, [containerPadding, maxCellSize, ref]);\n\n  var _k = __read(useResizeObserver(recalculate, {\n    ref: mergedRef,\n    disableHeight: disableHeight,\n    disableWidth: disableWidth\n  }), 2),\n      refHandler = _k[1];\n\n  var mergedStyle = __assign(__assign({}, style), (_b = {}, _b[CELL_SIZE_VAR] = \"\".concat(gridSize.cellWidth, \"px\"), _b));\n\n  if (cellMargin) {\n    mergedStyle[CELL_MARGIN_VAR] = cellMargin;\n  }\n\n  return [{\n    ref: refHandler,\n    style: mergedStyle,\n    className: cn(\"rmd-grid-list\", className)\n  }, gridSize];\n}","map":{"version":3,"mappings":";;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AACA,SAASA,aAAT,EAAwBC,WAAxB,EAAqCC,UAArC,EAAiDC,QAAjD,QAAiE,OAAjE;AACA,OAAOC,EAAP,MAAe,YAAf;AAEA,SAASC,iBAAT,QAAkC,6BAAlC;AAEA,SAASC,aAAT,QAA8B,kBAA9B;AACA,SAASC,aAAT,QAA8B,iBAA9B;AAEA;;;;AAGA,OAAO,IAAMC,aAAa,GAAG,iBAAtB;AAEP;;;;AAGA,OAAO,IAAMC,eAAe,GAAG,mBAAxB;AAEP;;;;AAGA,OAAO,IAAMC,+BAA+B,GAAG,GAAxC;AAEP;;;;AAGA,OAAO,IAAMC,yBAAyB,GAAG,EAAlC;AAcP,IAAMC,OAAO,GAAGZ,aAAa,CAAe;EAC1Ca,OAAO,EAAE,CAAC,CADgC;EAE1CC,SAAS,EAAE,CAAC;AAF8B,CAAf,CAA7B;AAKA;;;;AAGA,OAAe,IAAUC,oBAAoB,GAAKH,OAAO,SAA1C;;AAEf,IAAII,OAAO,CAACC,GAAR,CAAYC,QAAZ,KAAyB,YAA7B,EAA2C;EACzCN,OAAO,CAACO,WAAR,GAAsB,sBAAtB;AACD;AAED;;;;;;;;AAMA,OAAM,SAAUC,eAAV,GAAyB;EAC7B,OAAOlB,UAAU,CAACU,OAAD,CAAjB;AACD;AA8ED;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AAkCA,OAAM,SAAUS,WAAV,CAA6CC,EAA7C,EAUqC;;;MAVQC,qBAUV,EAVU,GAURD;MATpCE,OAAO;MACZC,KAAK;MACLC,SAAS;MACTC,UAAU;MACVC,WAAW;MACXC;MAAAC,WAAW,mBAAGpB,+BAAH,GAAkCmB;MAC7CE;MAAAC,aAAa,mBAAG,KAAH,GAAQD;MACrBE;MAAAC,YAAY,mBAAG,KAAH,GAAQD;MACpBE;MAAAC,gBAAgB,mBAAGzB,yBAAH,GAA4BwB;;EAEtC,gBAAmB7B,aAAa,CAACkB,OAAD,CAAhC,EAAyC,CAAzC;EAAA,IAACa,GAAG,QAAJ;EAAA,IAAMC,SAAS,QAAf;;EACA,gBAA0BnC,QAAQ,CACtCyB,WAAW,IAAI;IAAEf,OAAO,EAAE,CAAC,CAAZ;IAAeC,SAAS,EAAEgB;EAA1B,CADuB,CAAlC,EAEL,CAFK;EAAA,IAACS,QAAQ,QAAT;EAAA,IAAWC,WAAW,QAAtB;;EAGN,IAAMC,WAAW,GAAGxC,WAAW,CAAC;IAC9B,IAAMyC,MAAM,GAAGL,GAAG,CAACM,OAAnB;;IACA,IAAI,CAACD,MAAL,EAAa;MACX;IACD,CAJ6B,CAM9B;IACA;IACA;IACA;;;IACM,SAAK,GAAKA,MAAM,CAACE,qBAAP,GAA8BC,KAAxC;IACNA,KAAK,IAAIT,gBAAT,CAX8B,CAa9B;IACA;;IACA,IAAIM,MAAM,CAACI,YAAP,GAAsBJ,MAAM,CAACK,YAAjC,EAA+C;MAC7CF,KAAK,IAAItC,aAAa,CAAC,OAAD,CAAtB;IACD;;IAED,IAAMM,OAAO,GAAGmC,IAAI,CAACC,IAAL,CAAUJ,KAAK,GAAGf,WAAlB,CAAhB;IACAU,WAAW,CAAC;MAAE1B,SAAS,EAAE+B,KAAK,GAAGhC,OAArB;MAA8BA,OAAO;IAArC,CAAD,CAAX;EACD,CArB8B,EAqB5B,CAACuB,gBAAD,EAAmBN,WAAnB,EAAgCO,GAAhC,CArB4B,CAA/B;;EAsBM,gBAAiBhC,iBAAiB,CAACoC,WAAD,EAAc;IACpDJ,GAAG,EAAEC,SAD+C;IAEpDN,aAAa,eAFuC;IAGpDE,YAAY;EAHwC,CAAd,CAAlC,EAIJ,CAJI;EAAA,IAAGgB,UAAU,QAAb;;EAMN,IAAMC,WAAW,yBACZ1B,KADY,IACP2B,YACP5C,aADO,IACS,UAAG+B,QAAQ,CAACzB,SAAZ,EAAqB,IAArB,CADT,EACkCsC,EAF3B,EAAjB;;EAIA,IAAIzB,UAAJ,EAAgB;IACdwB,WAAW,CAAC1C,eAAD,CAAX,GAA+BkB,UAA/B;EACD;;EAED,OAAO,CACL;IACEU,GAAG,EAAEa,UADP;IAEEzB,KAAK,EAAE0B,WAFT;IAGEzB,SAAS,EAAEtB,EAAE,CAAC,eAAD,EAAkBsB,SAAlB;EAHf,CADK,EAMLa,QANK,CAAP;AAQD","names":["createContext","useCallback","useContext","useState","cn","useResizeObserver","useEnsuredRef","scrollbarSize","CELL_SIZE_VAR","CELL_MARGIN_VAR","DEFAULT_GRID_LIST_MAX_CELL_SIZE","DEFAULT_GRID_LIST_PADDING","context","columns","cellWidth","GridListSizeProvider","process","env","NODE_ENV","displayName","useGridListSize","useGridList","_a","_c","propRef","style","className","cellMargin","defaultSize","_d","maxCellSize","_e","disableHeight","_f","disableWidth","_g","containerPadding","ref","mergedRef","gridSize","setGridSize","recalculate","target","current","getBoundingClientRect","width","offsetHeight","scrollHeight","Math","ceil","refHandler","mergedStyle","_b"],"sources":["C:\\Users\\hungr\\Documents\\VS-CODE\\notes-react\\node_modules\\@react-md\\utils\\src\\layout\\useGridList.ts"],"sourcesContent":["import type { RefCallback } from \"react\";\nimport { createContext, useCallback, useContext, useState } from \"react\";\nimport cn from \"classnames\";\n\nimport { useResizeObserver } from \"../sizing/useResizeObserver\";\nimport type { PropsWithRef } from \"../types\";\nimport { useEnsuredRef } from \"../useEnsuredRef\";\nimport { scrollbarSize } from \"./scrollbarSize\";\n\n/**\n * This is the css variable that is used store the current size of each cell.\n */\nexport const CELL_SIZE_VAR = \"--rmd-cell-size\";\n\n/**\n * This is the css variable that is used store the current margin of each cell.\n */\nexport const CELL_MARGIN_VAR = \"--rmd-cell-margin\";\n\n/**\n * @remarks \\@since 2.3.0\n */\nexport const DEFAULT_GRID_LIST_MAX_CELL_SIZE = 150;\n\n/**\n * @remarks \\@since 2.3.0\n */\nexport const DEFAULT_GRID_LIST_PADDING = 16;\n\nexport interface GridListSize {\n  /**\n   * The current number of columns in the `GridList`.\n   */\n  columns: number;\n\n  /**\n   * The current width of each cell within the grid.\n   */\n  cellWidth: number;\n}\n\nconst context = createContext<GridListSize>({\n  columns: -1,\n  cellWidth: -1,\n});\n\n/**\n * @remarks \\@since 2.3.0\n */\nexport const { Provider: GridListSizeProvider } = context;\n\nif (process.env.NODE_ENV !== \"production\") {\n  context.displayName = \"GridListSizeProvider\";\n}\n\n/**\n * Gets the current size of each cell within the `GridList` component. If this\n * is used without a parent `GridList` component, `-1` is returned instead.\n *\n * @remarks \\@since 2.3.0\n */\nexport function useGridListSize(): GridListSize {\n  return useContext(context);\n}\n\n/**\n * @remarks \\@since 2.3.0\n */\nexport interface UseGridListOptions {\n  /**\n   * An optional style object to merge with the grid custom css properties\n   * object.\n   */\n  style?: React.CSSProperties;\n\n  /**\n   * An optional className to merge with the grid list class name\n   */\n  className?: string;\n\n  /**\n   * Boolean if the recalculation of grid sizing should not happen for height\n   * changes.\n   */\n  disableHeight?: boolean;\n\n  /**\n   * Boolean if the recalculation of grid sizing should not happen for width\n   * changes.\n   */\n  disableWidth?: boolean;\n\n  /**\n   * An optional margin to apply to each cell as the `CELL_MARGIN_VAR` css\n   * variable only when it is defined. This has to be a number string with a\n   * `px`, `em`, `rem` or `%` suffix or else the grid will break.\n   */\n  cellMargin?: string;\n\n  /**\n   * The max size that each cell can be.\n   */\n  maxCellSize?: number;\n\n  /**\n   * Since the `GridList` requires being fully rendered in the DOM to be able to\n   * correctly calculate the number of `columns` and `cellWidth`, this _might_\n   * cause problems when server-side rendering when using the children renderer\n   * to create a grid list dynamically based on the number of columns. If the\n   * number of columns and default `cellWidth` can be guessed server-side, you\n   * should provide this prop. Otherwise it will be:\n   * `{ cellSize; maxCellSize, columns: -1 }`\n   */\n  defaultSize?: GridListSize | (() => GridListSize);\n\n  /**\n   * This is _normally_ the amount of padding on the grid list item itself to\n   * subtract from the `offsetWidth` since `padding`, `border`, and vertical\n   * scrollbars will be included.  If you add a border or change the padding or\n   * add borders to this component, you'll need to update the `containerPadding`\n   * to be the new number.\n   */\n  containerPadding?: number;\n}\n\nexport interface ProvidedGridListProps<E extends HTMLElement> {\n  ref: RefCallback<E | null>;\n  style: CSSProperties;\n  className: string;\n}\n\ntype CSSProperties = React.CSSProperties & {\n  [CELL_SIZE_VAR]: string;\n  [CELL_MARGIN_VAR]?: string;\n};\n\nexport type UseGridListReturnValue<E extends HTMLElement> = readonly [\n  ProvidedGridListProps<E>,\n  GridListSize\n];\n\n/**\n * The `useGridList` hook allows you to get all the grid and sizing\n * functionality of the `GridList` component without needing to wrap your\n * children in a `<div>` element.\n *\n * Example:\n *\n * ```tsx\n * const [gridListProps] = useGridList({\n *   cellMargin: 16,\n *   maxCellSize: 300,\n *   containerPadding: 4,\n * });\n *\n * return <div {...gridListProps}>{children}</div>;\n * ```\n *\n * Note: You must manually provide the `gridSize` to the `GridListSizeProvider`\n * component that was added in 2.3.0 if you want to use the `useGridSize` hook.\n *\n * Example:\n *\n * ```tsx\n * const [gridListProps, gridSize] = useGridList()\n *\n * return (\n *   <GridListSizeProvider value={gridSize}>\n *     <MyComponent {...gridListProps} />\n *   </GridListSizeProvider>\n * );\n * ```\n *\n * @remarks \\@since 2.3.0\n */\nexport function useGridList<E extends HTMLElement>({\n  ref: propRef,\n  style,\n  className,\n  cellMargin,\n  defaultSize,\n  maxCellSize = DEFAULT_GRID_LIST_MAX_CELL_SIZE,\n  disableHeight = false,\n  disableWidth = false,\n  containerPadding = DEFAULT_GRID_LIST_PADDING,\n}: PropsWithRef<UseGridListOptions, E> = {}): UseGridListReturnValue<E> {\n  const [ref, mergedRef] = useEnsuredRef(propRef);\n  const [gridSize, setGridSize] = useState(\n    defaultSize || { columns: -1, cellWidth: maxCellSize }\n  );\n  const recalculate = useCallback(() => {\n    const target = ref.current;\n    if (!target) {\n      return;\n    }\n\n    // need to use rect instead of offsetWidth since we need decimal precision\n    // for the width since offsetWidth is basically Math.ceil(width). the\n    // calculations for max columns will be off on high-pixel-density monitors\n    // or some zoom levels.\n    let { width } = target.getBoundingClientRect();\n    width -= containerPadding;\n\n    // just need to see if there is a scrollbar visible and subtract that width.\n    // don't need decimal precision here since both values will be rounded\n    if (target.offsetHeight < target.scrollHeight) {\n      width -= scrollbarSize(\"width\");\n    }\n\n    const columns = Math.ceil(width / maxCellSize);\n    setGridSize({ cellWidth: width / columns, columns });\n  }, [containerPadding, maxCellSize, ref]);\n  const [, refHandler] = useResizeObserver(recalculate, {\n    ref: mergedRef,\n    disableHeight,\n    disableWidth,\n  });\n\n  const mergedStyle: CSSProperties = {\n    ...style,\n    [CELL_SIZE_VAR]: `${gridSize.cellWidth}px`,\n  };\n  if (cellMargin) {\n    mergedStyle[CELL_MARGIN_VAR] = cellMargin;\n  }\n\n  return [\n    {\n      ref: refHandler,\n      style: mergedStyle,\n      className: cn(\"rmd-grid-list\", className),\n    },\n    gridSize,\n  ];\n}\n"]},"metadata":{},"sourceType":"module"}