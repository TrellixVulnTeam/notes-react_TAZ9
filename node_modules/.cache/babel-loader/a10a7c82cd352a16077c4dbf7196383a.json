{"ast":null,"code":"var __extends = this && this.__extends || function () {\n  var extendStatics = function (d, b) {\n    extendStatics = Object.setPrototypeOf || {\n      __proto__: []\n    } instanceof Array && function (d, b) {\n      d.__proto__ = b;\n    } || function (d, b) {\n      for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p];\n    };\n\n    return extendStatics(d, b);\n  };\n\n  return function (d, b) {\n    if (typeof b !== \"function\" && b !== null) throw new TypeError(\"Class extends value \" + String(b) + \" is not a constructor or null\");\n    extendStatics(d, b);\n\n    function __() {\n      this.constructor = d;\n    }\n\n    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n  };\n}();\n\nimport { nanoid } from \"nanoid\";\n/**\n * An error that will be created if a user tries dragging and dropping files\n * from a shared directory that they do not have access to. This error will not\n * occur much.\n *\n * @remarks \\@since 2.9.0\n */\n\nvar FileAccessError =\n/** @class */\nfunction (_super) {\n  __extends(FileAccessError, _super);\n  /**\n   *\n   * @param message - An optional message for the error.\n   */\n\n\n  function FileAccessError(message) {\n    var _this = _super.call(this, message) || this;\n\n    _this.key = nanoid();\n    _this.name = \"FileAccessError\";\n    return _this;\n  }\n\n  return FileAccessError;\n}(Error);\n\nexport { FileAccessError };\n/**\n * An error that just requires a `File` to be passed as the first argument.\n *\n * @remarks \\@since 2.9.0\n */\n\nvar GenericFileError =\n/** @class */\nfunction (_super) {\n  __extends(GenericFileError, _super);\n  /**\n   *\n   * @param files - A list of files that caused the error.\n   * @param reason - An optional reason for the error\n   */\n\n\n  function GenericFileError(files, reason) {\n    var _this = _super.call(this, \"Invalid files\") || this;\n\n    _this.files = files;\n    _this.reason = reason;\n    _this.key = nanoid();\n    _this.name = \"GenericFileError\";\n    return _this;\n  }\n\n  return GenericFileError;\n}(Error);\n\nexport { GenericFileError };\n/**\n * An error that is created during the upload process if the number of files\n * exceeds the {@link FileUploadOptions.maxFiles} amount.\n *\n * @remarks \\@since 2.9.0\n */\n\nvar TooManyFilesError =\n/** @class */\nfunction (_super) {\n  __extends(TooManyFilesError, _super);\n  /**\n   *\n   * @param files - The list of files that could not be uploaded due to the file\n   * limit defined.\n   * @param limit - The max limit of files allowed.\n   */\n\n\n  function TooManyFilesError(files, limit) {\n    var _this = _super.call(this, files, \"file limit\") || this;\n\n    _this.limit = limit;\n    _this.name = \"TooManyFilesError\";\n    return _this;\n  }\n\n  return TooManyFilesError;\n}(GenericFileError);\n\nexport { TooManyFilesError };\n/**\n * An error that will be created if a user tries to upload a file that\n * is either:\n * - less than the {@link FileValidationOptions.minFileSize}\n * - greater than the {@link FileValidationOptions.maxFileSize}\n * - including the file would be greater than the {@link FileValidationOptions.totalFileSize}\n *\n * @remarks \\@since 2.9.0\n */\n\nvar FileSizeError =\n/** @class */\nfunction (_super) {\n  __extends(FileSizeError, _super);\n  /**\n   *\n   * @param files - The list of files that have the file size error\n   * @param type - The file size error type\n   * @param limit - The number of bytes allowed based on the type\n   */\n\n\n  function FileSizeError(files, type, limit) {\n    var _this = _super.call(this, files, \"file size\") || this;\n\n    _this.type = type;\n    _this.limit = limit;\n    _this.name = \"FileSizeError\";\n    return _this;\n  }\n\n  return FileSizeError;\n}(GenericFileError);\n\nexport { FileSizeError };\n/**\n * An error that will be created if a user tries to upload a file that does not\n * end with one of the {@link FileValidationOptions.extensions}.\n *\n * @remarks \\@since 2.9.0\n */\n\nvar FileExtensionError =\n/** @class */\nfunction (_super) {\n  __extends(FileExtensionError, _super);\n  /**\n   *\n   * @param files - The file that caused the error\n   * @param extensions - The allowed list of file extensions\n   */\n\n\n  function FileExtensionError(files, extensions) {\n    var _this = _super.call(this, files, \"extension\") || this;\n\n    _this.extensions = extensions;\n    _this.name = \"FileExtensionError\";\n    return _this;\n  }\n\n  return FileExtensionError;\n}(GenericFileError);\n\nexport { FileExtensionError };\n/**\n * A simple type-guard that can be used to check if the\n * {@link FileValidationError} is the {@link GenericFileError} which can be\n * useful when displaying the errors to the user.\n *\n * @param error - The error to check\n * @returns true if the error is a {@link FileAccessError}\n */\n\nexport function isGenericFileError(error) {\n  return \"name\" in error && error.name === \"GenericFileError\";\n}\n/**\n * A simple type-guard that can be used to check if the\n * {@link FileValidationError} is the {@link FileAccessError} which can be\n * useful when displaying the errors to the user.\n *\n * @param error - The error to check\n * @returns true if the error is a {@link FileAccessError}\n */\n\nexport function isFileAccessError(error) {\n  return \"name\" in error && error.name === \"FileAccessError\";\n}\n/**\n * A simple type-guard that can be used to check if the\n * {@link FileValidationError} is the {@link TooManyFilesError} which can be\n * useful when displaying the errors to the user.\n *\n * @param error - The error to check\n * @returns true if the error is a {@link TooManyFilesError}\n */\n\nexport function isTooManyFilesError(error) {\n  return \"name\" in error && error.name === \"TooManyFilesError\";\n}\n/**\n * A simple type-guard that can be used to check if the\n * {@link FileValidationError} is the {@link FileSizeError} which can be\n * useful when displaying the errors to the user.\n *\n * @param error - The error to check\n * @returns true if the error is a {@link FileSizeError}\n */\n\nexport function isFileSizeError(error) {\n  return \"name\" in error && error.name === \"FileSizeError\";\n}\n/**\n * A simple type-guard that can be used to check if the\n * {@link FileValidationError} is the {@link FileExtensionError} which can be\n * useful when displaying the errors to the user.\n *\n * @param error - The error to check\n * @returns true if the error is a {@link FileExtensionError}\n */\n\nexport function isFileExtensionError(error) {\n  return \"name\" in error && error.name === \"FileExtensionError\";\n}\n/**\n *\n * @defaultValue `matcher?.test(file.name) ?? true`\n * @remarks \\@since 3.1.0\n */\n\nexport var isValidFileName = function (file, matcher) {\n  var _a;\n\n  return (_a = matcher === null || matcher === void 0 ? void 0 : matcher.test(file.name)) !== null && _a !== void 0 ? _a : true;\n};\n/**\n * A pretty decent default implementation for validating files with the\n * {@link useFileUpload} that ensures the {@link FilesValidationOptions} are\n * enforced before allowing a file to be uploaded.\n *\n * @typeparam E - An optional custom file validation error.\n * @param files - The list of files to check\n * @param options - The {@link FilesValidationOptions}\n * @returns the {@link ValidatedFilesResult}\n * @remarks \\@since 2.9.0\n */\n\nexport function validateFiles(files, _a) {\n  var maxFiles = _a.maxFiles,\n      extensions = _a.extensions,\n      minFileSize = _a.minFileSize,\n      maxFileSize = _a.maxFileSize,\n      totalBytes = _a.totalBytes,\n      totalFiles = _a.totalFiles,\n      totalFileSize = _a.totalFileSize,\n      isValidFileName = _a.isValidFileName;\n  var errors = [];\n  var pending = [];\n  var extraFiles = [];\n  var extensionRegExp = extensions.length > 0 ? new RegExp(\"\\\\.(\".concat(extensions.join(\"|\"), \")$\"), \"i\") : undefined;\n  var maxFilesReached = maxFiles > 0 && totalFiles >= maxFiles;\n  var remainingBytes = totalFileSize - totalBytes;\n  var extensionErrors = [];\n  var minErrors = [];\n  var maxErrors = [];\n  var totalSizeErrors = [];\n\n  for (var i = 0; i < files.length; i += 1) {\n    var file = files[i];\n    var valid = true;\n    var size = file.size;\n\n    if (!isValidFileName(file, extensionRegExp, extensions)) {\n      valid = false;\n      extensionErrors.push(file);\n    }\n\n    if (minFileSize > 0 && size < minFileSize) {\n      valid = false;\n      minErrors.push(file);\n    }\n\n    if (maxFileSize > 0 && size > maxFileSize) {\n      valid = false;\n      maxErrors.push(file);\n    } else if (totalFileSize > 0 && remainingBytes - file.size < 0) {\n      // don't want both errors displaying\n      valid = false;\n      totalSizeErrors.push(file);\n    }\n\n    if (maxFilesReached && valid) {\n      extraFiles.push(file);\n    } else if (!maxFilesReached && valid) {\n      pending.push(file);\n      remainingBytes -= file.size;\n      maxFilesReached = maxFilesReached || maxFiles > 0 && totalFiles + pending.length >= maxFiles;\n    }\n  }\n\n  if (extensionErrors.length) {\n    errors.push(new FileExtensionError(extensionErrors, extensions));\n  }\n\n  if (minErrors.length) {\n    errors.push(new FileSizeError(minErrors, \"min\", minFileSize));\n  }\n\n  if (maxErrors.length) {\n    errors.push(new FileSizeError(maxErrors, \"max\", maxFileSize));\n  }\n\n  if (totalSizeErrors.length) {\n    errors.push(new FileSizeError(totalSizeErrors, \"total\", totalFileSize));\n  }\n\n  if (extraFiles.length) {\n    errors.push(new TooManyFilesError(extraFiles, maxFiles));\n  }\n\n  return {\n    pending: pending,\n    errors: errors\n  };\n}\n/**\n * This will first check if the mime-type of the file starts with `text/` and\n * fallback to checking a few file names or extensions that should be considered\n * text.\n *\n * This function is not guaranteed to be 100% correct and is only useful if\n * trying to generate a preview of files uploaded to the browser.\n *\n * @param file - The file to check\n * @returns `true` if the file should be considered as a text-content file.\n * @remarks \\@since 2.9.0\n */\n\nexport function isTextFile(file) {\n  return /\\.((j|t)sx?|json|lock|hbs|ya?ml|log|txt|md)$/i.test(file.name);\n}\n/**\n * This will first check if the mime-type of the file starts with `text\\/` and\n * fallback to checking a few file names or extensions that should be considered\n * text.\n *\n * This function is not guaranteed to be 100% correct and is only useful if\n * trying to generate a preview of files uploaded to the browser.\n *\n * @param file - The file to check\n * @returns `true` if the file should be considered as a text content file.\n * @remarks \\@since 2.9.0\n */\n\nexport function isImageFile(file) {\n  return /\\.(a?png|avif|svg|tiff|gifv?|jpe?g)/i.test(file.name);\n}\n/**\n * This will first check if the mime-type of the file starts with `audio/` and\n * fallback to checking a few file names or extensions that should be considered\n * audio.\n *\n * This function is not guaranteed to be 100% correct and is only useful if\n * trying to generate a preview of files uploaded to the browser.\n *\n * @param file - The file to check\n * @returns `true` if the file should be considered as a audio content file.\n * @remarks \\@since 2.9.0\n */\n\nexport function isAudioFile(file) {\n  return /\\.(mp3|wav|ogg|m4p|flac)$/i.test(file.name);\n}\n/**\n * This will first check if the mime-type of the file starts with `video/` and\n * fallback to checking a few file names or extensions that should be considered\n * video.\n *\n * This function is not guaranteed to be 100% correct and is only useful if\n * trying to generate a preview of files uploaded to the browser.\n *\n * @param file - The file to check\n * @returns `true` if the file should be considered as a video content file.\n * @remarks \\@since 2.9.0\n */\n\nexport function isVideoFile(file) {\n  return /\\.(mkv|mpe?g|mov|avi|flv|webm|mp4)$/i.test(file.name);\n}\n/**\n * This function is not guaranteed to be 100% correct and is only useful if\n * trying to generate a preview of files uploaded to the browser.\n *\n * @param file - The file to check\n * @returns `true` if the file matches an image, audio, or video file.\n * @remarks \\@since 2.9.0\n */\n\nexport function isMediaFile(file) {\n  return isImageFile(file) || isAudioFile(file) || isVideoFile(file);\n}\n/**\n * This function will attempt to read:\n * - media (image, audio, and video) files as a data url so they can be\n *   previewed in `<img>`, `<audio>`, and `<video>` tags\n * - text files as plain text\n * - everything else as an `ArrayBuffer` which can be manually converted into a\n *   data url if needed with `URL.createObjectURL`\n *\n * @remarks \\@since 2.9.0\n */\n\nexport var getFileParser = function (file) {\n  if (isMediaFile(file)) {\n    return \"readAsDataURL\";\n  }\n\n  if (isTextFile(file)) {\n    return \"readAsText\";\n  }\n\n  return \"readAsArrayBuffer\";\n};\n/**\n * This util will split all the current upload stats by status.\n *\n * @param stats - The {@link FileUploadStats} list generally returned by the\n * {@link useFileUpload} hook.\n * @returns the {@link SplitFileUploads}.\n * @remarks \\@since 2.9.0\n */\n\nexport function getSplitFileUploads(stats) {\n  var pending = [];\n  var uploading = [];\n  var complete = [];\n  stats.forEach(function (stat) {\n    if (stat.status === \"pending\") {\n      pending.push(stat);\n    } else if (stat.status === \"uploading\") {\n      uploading.push(stat);\n    } else if (stat.status === \"complete\") {\n      complete.push(stat);\n    } else {\n      /* istanbul ignore next */\n      throw new Error(\"Invalid upload stat\");\n    }\n  });\n  return {\n    pending: pending,\n    uploading: uploading,\n    complete: complete\n  };\n}","map":{"version":3,"mappings":"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","names":["nanoid","__extends","message","_super","_this","key","name","Error","files","reason","limit","GenericFileError","type","extensions","isGenericFileError","error","isFileAccessError","isTooManyFilesError","isFileSizeError","isFileExtensionError","isValidFileName","file","matcher","test","_a","validateFiles","maxFiles","minFileSize","maxFileSize","totalBytes","totalFiles","totalFileSize","errors","pending","extraFiles","extensionRegExp","length","RegExp","join","undefined","maxFilesReached","remainingBytes","extensionErrors","minErrors","maxErrors","totalSizeErrors","i","valid","push","size","FileExtensionError","FileSizeError","TooManyFilesError","isTextFile","isImageFile","isAudioFile","isVideoFile","isMediaFile","getFileParser","getSplitFileUploads","stats","uploading","complete","forEach","stat","status"],"sources":["C:\\Users\\hungr\\Documents\\VS-CODE\\notes-react\\node_modules\\@react-md\\form\\src\\file-input\\utils.ts"],"sourcesContent":["import type { ChangeEventHandler, DragEventHandler } from \"react\";\nimport { nanoid } from \"nanoid\";\n\n/** @remarks \\@since 2.9.0 */\nexport interface BaseFileUploadStats {\n  /**\n   * A unique key associated with each upload generated by `nanoid`.\n   */\n  key: string;\n\n  /**\n   * The file instance that is being uploaded.\n   */\n  file: File;\n\n  /**\n   * The current upload progress as a percentage from 0 - 100 percent.\n   */\n  progress: number;\n}\n\n/** @remarks \\@since 2.9.0 */\nexport interface ProcessingFileUploadStats extends BaseFileUploadStats {\n  status: \"pending\" | \"uploading\";\n}\n\n/** @remarks \\@since 2.9.0 */\nexport type FileReaderResult = FileReader[\"result\"];\n\n/** @remarks \\@since 2.9.0 */\nexport interface CompletedFileUploadStats extends BaseFileUploadStats {\n  status: \"complete\";\n\n  /**\n   * The result after a `FileReader` has read a file completely.\n   *\n   * Note: This _should_ be an `ArrayBuffer` if the next step is to upload to a\n   * server.\n   *\n   * @see {@link FileReaderParser}\n   * @see {@link getFileParser}\n   * @see {@link https://developer.mozilla.org/en-US/docs/Web/API/FileReader | FileReader}\n   */\n  result: FileReaderResult;\n}\n\n/** @remarks \\@since 2.9.0 */\nexport type FileUploadStats =\n  | ProcessingFileUploadStats\n  | CompletedFileUploadStats;\n\n/** @remarks \\@since 2.9.0 */\nexport type FileUploadStatus = FileUploadStats[\"status\"];\n\n/** @remarks \\@since 2.9.0 */\nexport interface FileUploadHandlers<E extends HTMLElement> {\n  onDrop?: DragEventHandler<E>;\n  onChange?: ChangeEventHandler<HTMLInputElement>;\n}\n\n/**\n * An error that will be created if a user tries dragging and dropping files\n * from a shared directory that they do not have access to. This error will not\n * occur much.\n *\n * @remarks \\@since 2.9.0\n */\nexport class FileAccessError extends Error {\n  /**\n   * A unique key generated by `nanoid` that can be used as a `React` key\n   */\n  public key: string;\n\n  /**\n   *\n   * @param message - An optional message for the error.\n   */\n  constructor(message?: string) {\n    super(message);\n    this.key = nanoid();\n    this.name = \"FileAccessError\";\n  }\n}\n\n/**\n * An error that just requires a `File` to be passed as the first argument.\n *\n * @remarks \\@since 2.9.0\n */\nexport class GenericFileError extends Error {\n  /**\n   * A unique key generated by `nanoid` that can be used as a `React` key\n   */\n  public key: string;\n\n  /**\n   *\n   * @param files - A list of files that caused the error.\n   * @param reason - An optional reason for the error\n   */\n  constructor(public files: readonly File[], public reason?: string) {\n    super(\"Invalid files\");\n    this.key = nanoid();\n    this.name = \"GenericFileError\";\n  }\n}\n\n/**\n * An error that is created during the upload process if the number of files\n * exceeds the {@link FileUploadOptions.maxFiles} amount.\n *\n * @remarks \\@since 2.9.0\n */\nexport class TooManyFilesError extends GenericFileError {\n  /**\n   *\n   * @param files - The list of files that could not be uploaded due to the file\n   * limit defined.\n   * @param limit - The max limit of files allowed.\n   */\n  constructor(files: readonly File[], public limit: number) {\n    super(files, \"file limit\");\n    this.name = \"TooManyFilesError\";\n  }\n}\n\n/**\n * An error that will be created if a user tries to upload a file that\n * is either:\n * - less than the {@link FileValidationOptions.minFileSize}\n * - greater than the {@link FileValidationOptions.maxFileSize}\n * - including the file would be greater than the {@link FileValidationOptions.totalFileSize}\n *\n * @remarks \\@since 2.9.0\n */\nexport class FileSizeError extends GenericFileError {\n  /**\n   *\n   * @param files - The list of files that have the file size error\n   * @param type - The file size error type\n   * @param limit - The number of bytes allowed based on the type\n   */\n  constructor(\n    files: readonly File[],\n    public type: \"min\" | \"max\" | \"total\",\n    public limit: number\n  ) {\n    super(files, \"file size\");\n    this.name = \"FileSizeError\";\n  }\n}\n\n/**\n * An error that will be created if a user tries to upload a file that does not\n * end with one of the {@link FileValidationOptions.extensions}.\n *\n * @remarks \\@since 2.9.0\n */\nexport class FileExtensionError extends GenericFileError {\n  /**\n   *\n   * @param files - The file that caused the error\n   * @param extensions - The allowed list of file extensions\n   */\n  constructor(files: readonly File[], public extensions: readonly string[]) {\n    super(files, \"extension\");\n    this.name = \"FileExtensionError\";\n  }\n}\n\n/**\n * Mostly an internal type that is used to allow custom validation errors\n *\n * @remarks \\@since 2.9.0\n */\nexport type FileValidationError<E = GenericFileError> =\n  | FileAccessError\n  | TooManyFilesError\n  | FileSizeError\n  | FileExtensionError\n  | E;\n\n/**\n * A simple type-guard that can be used to check if the\n * {@link FileValidationError} is the {@link GenericFileError} which can be\n * useful when displaying the errors to the user.\n *\n * @param error - The error to check\n * @returns true if the error is a {@link FileAccessError}\n */\nexport function isGenericFileError<CustomError>(\n  error: FileValidationError<CustomError>\n): error is GenericFileError {\n  return \"name\" in error && error.name === \"GenericFileError\";\n}\n\n/**\n * A simple type-guard that can be used to check if the\n * {@link FileValidationError} is the {@link FileAccessError} which can be\n * useful when displaying the errors to the user.\n *\n * @param error - The error to check\n * @returns true if the error is a {@link FileAccessError}\n */\nexport function isFileAccessError<CustomError>(\n  error: FileValidationError<CustomError>\n): error is FileAccessError {\n  return \"name\" in error && error.name === \"FileAccessError\";\n}\n\n/**\n * A simple type-guard that can be used to check if the\n * {@link FileValidationError} is the {@link TooManyFilesError} which can be\n * useful when displaying the errors to the user.\n *\n * @param error - The error to check\n * @returns true if the error is a {@link TooManyFilesError}\n */\nexport function isTooManyFilesError<CustomError>(\n  error: FileValidationError<CustomError>\n): error is TooManyFilesError {\n  return \"name\" in error && error.name === \"TooManyFilesError\";\n}\n\n/**\n * A simple type-guard that can be used to check if the\n * {@link FileValidationError} is the {@link FileSizeError} which can be\n * useful when displaying the errors to the user.\n *\n * @param error - The error to check\n * @returns true if the error is a {@link FileSizeError}\n */\nexport function isFileSizeError<CustomError>(\n  error: FileValidationError<CustomError>\n): error is FileSizeError {\n  return \"name\" in error && error.name === \"FileSizeError\";\n}\n\n/**\n * A simple type-guard that can be used to check if the\n * {@link FileValidationError} is the {@link FileExtensionError} which can be\n * useful when displaying the errors to the user.\n *\n * @param error - The error to check\n * @returns true if the error is a {@link FileExtensionError}\n */\nexport function isFileExtensionError<CustomError>(\n  error: FileValidationError<CustomError>\n): error is FileExtensionError {\n  return \"name\" in error && error.name === \"FileExtensionError\";\n}\n\n/**\n * This function is used to determine if a file should be added to the\n * {@link FileExtensionError}. The default implementation should work for most\n * use cases except when files that do not have extensions can be uploaded. i.e.\n * LICENSE files.\n *\n * @param file - The file being checked\n * @param extensionRegExp - A regex that will only be defined if the\n * `extensions` list had at least one value.\n * @param extensions - The list of extensions allowed\n * @returns true if the file has a valid name.\n * @remarks \\@since 3.1.0\n */\nexport type IsValidFileName = (\n  file: File,\n  extensionRegExp: RegExp | undefined,\n  extensions: readonly string[]\n) => boolean;\n\n/**\n *\n * @defaultValue `matcher?.test(file.name) ?? true`\n * @remarks \\@since 3.1.0\n */\nexport const isValidFileName: IsValidFileName = (file, matcher) =>\n  matcher?.test(file.name) ?? true;\n\n/** @remarks \\@since 2.9.0 */\nexport interface FileValidationOptions {\n  /**\n   * If the number of files should be limited, set this value to a number\n   * greater than `0`.\n   *\n   * Note: This still allows \"infinite\" files when set to `0` since the\n   * `<input>` element should normally be set to `disabled` if files should not\n   * be able to be uploaded.\n   *\n   * @defaultValue `-1`\n   */\n  maxFiles?: number;\n\n  /**\n   * An optional minimum file size to enforce for each file. This will only be\n   * used when it is greater than `0`.\n   *\n   * @defaultValue `-1`\n   */\n  minFileSize?: number;\n\n  /**\n   * An optional maximum file size to enforce for each file. This will only be\n   * used when it is greater than `0`.\n   *\n   * @defaultValue `-1`\n   */\n  maxFileSize?: number;\n\n  /**\n   * An optional list of extensions to enforce when uploading files.\n   *\n   * Note: The extensions and file names will be compared ignoring case.\n   *\n   * @example\n   * Only Allow Images\n   * ```ts\n   * const extensions = [\"png\", \"jpeg\", \"jpg\", \"gif\"];\n   * ```\n   */\n  extensions?: readonly string[];\n\n  /** {@inheritDoc IsValidFileName} */\n  isValidFileName?: IsValidFileName;\n\n  /**\n   * An optional total file size to enforce when the {@link maxFiles} option is\n   * not set to `1`.\n   *\n   * @defaultValue `-1`\n   */\n  totalFileSize?: number;\n}\n\n/** @remarks \\@since 2.9.0 */\nexport interface FilesValidationOptions\n  extends Required<FileValidationOptions> {\n  /**\n   * The total number of bytes in the {@link FileUploadHookReturnValue.stats}\n   * list. This is really just:\n   *\n   * ```ts\n   * const totalBytes = stats.reduce((total, stat) => total + stat.file.size, 0);\n   * ```\n   */\n  totalBytes: number;\n\n  /**\n   * The total number of files in the {@link FileUploadHookReturnValue.stats}.\n   */\n  totalFiles: number;\n}\n\n/** @remarks \\@since 2.9.0 */\nexport interface ValidatedFilesResult<CustomError> {\n  /**\n   * A filtered list of files that have been validated and can be queued for the\n   * upload process.\n   */\n  pending: readonly File[];\n\n  /**\n   * A list of {@link FileValidationError} that occurred during the validation\n   * step.\n   *\n   * Note: If an error has occurred, the file **should not** be added to the\n   * {@link pending} list of files.\n   */\n  errors: readonly FileValidationError<CustomError>[];\n}\n\n/**\n * This function will be called whenever a file has been uploaded by the user\n * either through an `<input type=\"file\">` or drag and drop behavior.\n *\n * @example\n * Simple Example\n * ```ts\n * const validateFiles: FilesValidator = (files, options) => {\n *   const invalid: File[] = [];\n *   const pending: File[] = [];\n *   for (const file of files) {\n *     if (!/\\.(jpe?g|svg|png)$/i.test(name)) {\n *       invalid.push(file);\n *     } else {\n *       pending.push(file);\n *     }\n *   }\n *\n *   const errors: FileValidationError[] = [];\n *   if (invalid.length) {\n *     errors.push(new GenericFileError(invalid))\n *   }\n *\n *   return { pending, errors };\n * };\n * ```\n *\n * @typeparam E - An optional custom file validation error.\n * @param files - The list of files to check\n * @param options - The {@link FilesValidationOptions}\n * @returns the {@link ValidatedFilesResult}\n * @see {@link validateFiles} for the default implementation\n * @remarks \\@since 2.9.0\n */\nexport type FilesValidator<CustomError = never> = (\n  files: readonly File[],\n  options: FilesValidationOptions\n) => ValidatedFilesResult<CustomError>;\n\n/**\n * A pretty decent default implementation for validating files with the\n * {@link useFileUpload} that ensures the {@link FilesValidationOptions} are\n * enforced before allowing a file to be uploaded.\n *\n * @typeparam E - An optional custom file validation error.\n * @param files - The list of files to check\n * @param options - The {@link FilesValidationOptions}\n * @returns the {@link ValidatedFilesResult}\n * @remarks \\@since 2.9.0\n */\nexport function validateFiles<CustomError>(\n  files: readonly File[],\n  {\n    maxFiles,\n    extensions,\n    minFileSize,\n    maxFileSize,\n    totalBytes,\n    totalFiles,\n    totalFileSize,\n    isValidFileName,\n  }: FilesValidationOptions\n): ValidatedFilesResult<CustomError> {\n  const errors: FileValidationError<CustomError>[] = [];\n  const pending: File[] = [];\n  const extraFiles: File[] = [];\n  const extensionRegExp =\n    extensions.length > 0\n      ? new RegExp(`\\\\.(${extensions.join(\"|\")})$`, \"i\")\n      : undefined;\n\n  let maxFilesReached = maxFiles > 0 && totalFiles >= maxFiles;\n  let remainingBytes = totalFileSize - totalBytes;\n  const extensionErrors: File[] = [];\n  const minErrors: File[] = [];\n  const maxErrors: File[] = [];\n  const totalSizeErrors: File[] = [];\n  for (let i = 0; i < files.length; i += 1) {\n    const file = files[i];\n\n    let valid = true;\n    const { size } = file;\n    if (!isValidFileName(file, extensionRegExp, extensions)) {\n      valid = false;\n      extensionErrors.push(file);\n    }\n\n    if (minFileSize > 0 && size < minFileSize) {\n      valid = false;\n      minErrors.push(file);\n    }\n\n    if (maxFileSize > 0 && size > maxFileSize) {\n      valid = false;\n      maxErrors.push(file);\n    } else if (totalFileSize > 0 && remainingBytes - file.size < 0) {\n      // don't want both errors displaying\n      valid = false;\n      totalSizeErrors.push(file);\n    }\n\n    if (maxFilesReached && valid) {\n      extraFiles.push(file);\n    } else if (!maxFilesReached && valid) {\n      pending.push(file);\n      remainingBytes -= file.size;\n      maxFilesReached =\n        maxFilesReached ||\n        (maxFiles > 0 && totalFiles + pending.length >= maxFiles);\n    }\n  }\n\n  if (extensionErrors.length) {\n    errors.push(new FileExtensionError(extensionErrors, extensions));\n  }\n\n  if (minErrors.length) {\n    errors.push(new FileSizeError(minErrors, \"min\", minFileSize));\n  }\n\n  if (maxErrors.length) {\n    errors.push(new FileSizeError(maxErrors, \"max\", maxFileSize));\n  }\n\n  if (totalSizeErrors.length) {\n    errors.push(new FileSizeError(totalSizeErrors, \"total\", totalFileSize));\n  }\n\n  if (extraFiles.length) {\n    errors.push(new TooManyFilesError(extraFiles, maxFiles));\n  }\n\n  return { pending, errors };\n}\n\n/**\n * This will first check if the mime-type of the file starts with `text/` and\n * fallback to checking a few file names or extensions that should be considered\n * text.\n *\n * This function is not guaranteed to be 100% correct and is only useful if\n * trying to generate a preview of files uploaded to the browser.\n *\n * @param file - The file to check\n * @returns `true` if the file should be considered as a text-content file.\n * @remarks \\@since 2.9.0\n */\nexport function isTextFile(file: File): boolean {\n  return /\\.((j|t)sx?|json|lock|hbs|ya?ml|log|txt|md)$/i.test(file.name);\n}\n\n/**\n * This will first check if the mime-type of the file starts with `text\\/` and\n * fallback to checking a few file names or extensions that should be considered\n * text.\n *\n * This function is not guaranteed to be 100% correct and is only useful if\n * trying to generate a preview of files uploaded to the browser.\n *\n * @param file - The file to check\n * @returns `true` if the file should be considered as a text content file.\n * @remarks \\@since 2.9.0\n */\nexport function isImageFile(file: File): boolean {\n  return /\\.(a?png|avif|svg|tiff|gifv?|jpe?g)/i.test(file.name);\n}\n\n/**\n * This will first check if the mime-type of the file starts with `audio/` and\n * fallback to checking a few file names or extensions that should be considered\n * audio.\n *\n * This function is not guaranteed to be 100% correct and is only useful if\n * trying to generate a preview of files uploaded to the browser.\n *\n * @param file - The file to check\n * @returns `true` if the file should be considered as a audio content file.\n * @remarks \\@since 2.9.0\n */\nexport function isAudioFile(file: File): boolean {\n  return /\\.(mp3|wav|ogg|m4p|flac)$/i.test(file.name);\n}\n\n/**\n * This will first check if the mime-type of the file starts with `video/` and\n * fallback to checking a few file names or extensions that should be considered\n * video.\n *\n * This function is not guaranteed to be 100% correct and is only useful if\n * trying to generate a preview of files uploaded to the browser.\n *\n * @param file - The file to check\n * @returns `true` if the file should be considered as a video content file.\n * @remarks \\@since 2.9.0\n */\nexport function isVideoFile(file: File): boolean {\n  return /\\.(mkv|mpe?g|mov|avi|flv|webm|mp4)$/i.test(file.name);\n}\n\n/**\n * This function is not guaranteed to be 100% correct and is only useful if\n * trying to generate a preview of files uploaded to the browser.\n *\n * @param file - The file to check\n * @returns `true` if the file matches an image, audio, or video file.\n * @remarks \\@since 2.9.0\n */\nexport function isMediaFile(file: File): boolean {\n  return isImageFile(file) || isAudioFile(file) || isVideoFile(file);\n}\n\n/**\n * One of the function names from a `FileReader` to upload a file to the\n * client.\n *\n * Note: If this file does not need to be previewed in the browser and will\n * immediately be uploaded to a server, use `readAsArrayBuffer`.\n *\n * @remarks \\@since 2.9.0\n */\nexport type FileReaderParser =\n  | \"readAsText\"\n  | \"readAsDataURL\"\n  | \"readAsBinaryString\"\n  | \"readAsArrayBuffer\";\n\n/**\n * A function that should return one of the {@link FileReaderParser} functions\n * to start uploading a file to the browser.\n *\n * @example\n * The Default File Upload Parser\n * ```ts\n * export const getFileParser: GetFileParser = (file) => {\n *   if (isMediaFile(file)) {\n *     return \"readAsDataURL\";\n *   }\n *\n *   if (isTextFile(file)) {\n *     return \"readAsText\";\n *   }\n *\n *   return \"readAsArrayBuffer\";\n * };\n * ```\n *\n * @param file - The file to get a parser for\n * @returns the {@link FileReaderParser} string.\n * @remarks \\@since 2.9.0\n */\nexport type GetFileParser = (file: File) => FileReaderParser;\n\n/**\n * This function will attempt to read:\n * - media (image, audio, and video) files as a data url so they can be\n *   previewed in `<img>`, `<audio>`, and `<video>` tags\n * - text files as plain text\n * - everything else as an `ArrayBuffer` which can be manually converted into a\n *   data url if needed with `URL.createObjectURL`\n *\n * @remarks \\@since 2.9.0\n */\nexport const getFileParser: GetFileParser = (file) => {\n  if (isMediaFile(file)) {\n    return \"readAsDataURL\";\n  }\n\n  if (isTextFile(file)) {\n    return \"readAsText\";\n  }\n\n  return \"readAsArrayBuffer\";\n};\n\n/** @remarks \\@since 2.9.0 */\nexport interface SplitFileUploads {\n  readonly pending: readonly ProcessingFileUploadStats[];\n  readonly uploading: readonly ProcessingFileUploadStats[];\n  readonly complete: readonly CompletedFileUploadStats[];\n}\n\n/**\n * This util will split all the current upload stats by status.\n *\n * @param stats - The {@link FileUploadStats} list generally returned by the\n * {@link useFileUpload} hook.\n * @returns the {@link SplitFileUploads}.\n * @remarks \\@since 2.9.0\n */\nexport function getSplitFileUploads(\n  stats: readonly FileUploadStats[]\n): SplitFileUploads {\n  const pending: ProcessingFileUploadStats[] = [];\n  const uploading: ProcessingFileUploadStats[] = [];\n  const complete: CompletedFileUploadStats[] = [];\n  stats.forEach((stat) => {\n    if (stat.status === \"pending\") {\n      pending.push(stat);\n    } else if (stat.status === \"uploading\") {\n      uploading.push(stat);\n    } else if (stat.status === \"complete\") {\n      complete.push(stat);\n    } else {\n      /* istanbul ignore next */\n      throw new Error(\"Invalid upload stat\");\n    }\n  });\n\n  return { pending, uploading, complete };\n}\n"]},"metadata":{},"sourceType":"module"}