{"ast":null,"code":"var delegatedEvents = [];\n/* eslint-disable @typescript-eslint/explicit-function-return-type */\n\n/**\n * Creates the delegated event handler that will run all the callbacks once an\n * event happens. The callbacks' invocation can also be throttled for event\n * types that trigger rapidly for additional performance.\n *\n * The `<K extends keyof WindowEventMap` is a nice thing I found while looking\n * through the `lib.d.ts` implementation of `addEventListener` that will allow\n * you to get the \"correct\" event type when using the `add` and `remove`\n * functions once you have created this event handler. Otherwise there'd be ts\n * errors trying to do `MouseEvent` or `KeyboardEvent` in your listeners.\n */\n\nfunction createEventHandler(throttle, callbacks) {\n  var running = false;\n\n  var runCallbacks = function (event) {\n    return function () {\n      for (var i = 0; i < callbacks.length; i += 1) {\n        callbacks[i](event);\n      }\n\n      running = false;\n    };\n  };\n\n  return function eventHandler(event) {\n    if (!throttle) {\n      runCallbacks(event)();\n      return;\n    }\n\n    if (running) {\n      return;\n    }\n\n    running = true;\n    window.requestAnimationFrame(runCallbacks(event));\n  };\n}\n/* eslint-enable @typescript-eslint/explicit-function-return-type */\n\n/**\n * Creates a throttled event handler for the provided event type and event\n * target.\n */\n\n\nfunction createDelegatedEventHandler(eventType, eventTarget, throttle, options) {\n  if (eventTarget === void 0) {\n    eventTarget = window;\n  }\n\n  if (throttle === void 0) {\n    throttle = false;\n  }\n\n  var callbacks = [];\n  var handler = createEventHandler(throttle, callbacks);\n  return {\n    /**\n     * Attempts to add the provided callback to the list of callbacks for the\n     * throttled event. If this is the first callback to be added, the throttled\n     * event will also be started.\n     */\n    add: function (callback) {\n      if (!callbacks.length) {\n        eventTarget.addEventListener(eventType, handler, options);\n      }\n\n      if (callbacks.indexOf(callback) === -1) {\n        callbacks.push(callback);\n      }\n    },\n\n    /**\n     * Attempts to remove the provided callback from the list of callbacks for\n     * the throttled event. If this is the last callback that was removed, the\n     * throttled event will also be stopped.\n     */\n    remove: function (callback) {\n      var i = callbacks.indexOf(callback);\n\n      if (i >= 0) {\n        callbacks.splice(i, 1);\n\n        if (!callbacks.length) {\n          eventTarget.removeEventListener(eventType, handler, options);\n        }\n      }\n    }\n  };\n}\n/**\n * Creates a delegated event listener using custom events. Most of this code\n * comes from the MDN about resize listeners.\n *\n * This will return an object for adding or removing event handlers for the\n * provided `eventType` since only one base throttled event listener will be\n * created. Each callback that is added will be called with the event each time\n * the event is triggered. This does mean that you will manually need to remove\n * your callback like normal or else it can be called when no longer in use.\n * This also means that it doesn't \"hurt\" to call this function without\n * immediately calling the `add` function since the event won't start until\n * there is at least 1 callback.\n *\n * @see https://developer.mozilla.org/en-US/docs/Web/Events/resize#Examples\n * @param eventType - One of the event types that should be used to create a\n * delegated event for. This should be things like resize, click, scroll, etc.\n * @param eventTarget - The target that should have the delegated event handler\n * attached to. This is normally the window, but can be any element as needed.\n * @param throttle - Boolean if the event should be throttled or not. Normally\n * only event types like resize or scroll should be throttled for performance\n * boosts, but anything can be.\n * @returns The delegated event handler that allows you to add or remove\n * `EventListener`s to that event.\n */\n\n\nexport function delegateEvent(eventType, eventTarget, throttle, options) {\n  if (eventTarget === void 0) {\n    eventTarget = window;\n  }\n\n  if (throttle === void 0) {\n    throttle = eventType === \"resize\" || eventType === \"scroll\";\n  }\n\n  var index = delegatedEvents.findIndex(function (event) {\n    return event.type === eventType && event.target === eventTarget && event.options === options && event.throttle === throttle;\n  });\n\n  if (index === -1) {\n    delegatedEvents.push({\n      type: eventType,\n      target: eventTarget,\n      options: options,\n      throttle: throttle,\n      handler: createDelegatedEventHandler(eventType, eventTarget, throttle, options)\n    });\n    index = delegatedEvents.length - 1;\n  }\n\n  return delegatedEvents[index].handler;\n}","map":{"version":3,"mappings":"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","names":["delegatedEvents","createEventHandler","throttle","callbacks","running","runCallbacks","event","i","length","eventHandler","window","requestAnimationFrame","createDelegatedEventHandler","eventType","eventTarget","options","handler","add","callback","addEventListener","indexOf","push","remove","splice","removeEventListener","delegateEvent","index","findIndex","type","target"],"sources":["C:\\Users\\hungr\\Documents\\VS-CODE\\notes-react\\node_modules\\@react-md\\utils\\src\\events\\utils.ts"],"sourcesContent":["export type DelegatedEventTarget = Window | Document | HTMLElement;\n\n/**\n * This is a \"shared\" event handler for the provided `eventType`. The event\n * listener will only be created once, but every single callback will be called\n * when the throttled event is triggered. This means that you will need to make\n * sure to remove the provided callback when it is no longer in use.\n */\nexport interface DelegatedEventHandler {\n  /**\n   * Adds the provided callback to the throttled event listener.\n   */\n  add: (callback: EventListener) => void;\n\n  /**\n   * Attempts to remove the provided callback from the throttled event listener.\n   */\n  remove: (callback: EventListener) => void;\n}\n\nexport interface DelegatableEvent {\n  type: string;\n  target: DelegatedEventTarget;\n  throttle: boolean;\n  handler: DelegatedEventHandler;\n  options?: boolean | AddEventListenerOptions;\n}\n\nconst delegatedEvents: DelegatableEvent[] = [];\n/* eslint-disable @typescript-eslint/explicit-function-return-type */\n\n/**\n * Creates the delegated event handler that will run all the callbacks once an\n * event happens. The callbacks' invocation can also be throttled for event\n * types that trigger rapidly for additional performance.\n *\n * The `<K extends keyof WindowEventMap` is a nice thing I found while looking\n * through the `lib.d.ts` implementation of `addEventListener` that will allow\n * you to get the \"correct\" event type when using the `add` and `remove`\n * functions once you have created this event handler. Otherwise there'd be ts\n * errors trying to do `MouseEvent` or `KeyboardEvent` in your listeners.\n */\nfunction createEventHandler<K extends keyof WindowEventMap>(\n  throttle: boolean,\n  callbacks: readonly EventListener[]\n) {\n  let running = false;\n  const runCallbacks = (event: WindowEventMap[K]) => () => {\n    for (let i = 0; i < callbacks.length; i += 1) {\n      callbacks[i](event);\n    }\n\n    running = false;\n  };\n\n  return function eventHandler(event: WindowEventMap[K]) {\n    if (!throttle) {\n      runCallbacks(event)();\n      return;\n    }\n\n    if (running) {\n      return;\n    }\n\n    running = true;\n    window.requestAnimationFrame(runCallbacks(event));\n  };\n}\n/* eslint-enable @typescript-eslint/explicit-function-return-type */\n\n/**\n * Creates a throttled event handler for the provided event type and event\n * target.\n */\nfunction createDelegatedEventHandler(\n  eventType: string,\n  eventTarget: DelegatedEventTarget = window,\n  throttle = false,\n  options?: boolean | AddEventListenerOptions\n): DelegatedEventHandler {\n  const callbacks: EventListener[] = [];\n  const handler = createEventHandler(throttle, callbacks);\n\n  return {\n    /**\n     * Attempts to add the provided callback to the list of callbacks for the\n     * throttled event. If this is the first callback to be added, the throttled\n     * event will also be started.\n     */\n    add: (callback: EventListener) => {\n      if (!callbacks.length) {\n        eventTarget.addEventListener(eventType, handler, options);\n      }\n\n      if (callbacks.indexOf(callback) === -1) {\n        callbacks.push(callback);\n      }\n    },\n\n    /**\n     * Attempts to remove the provided callback from the list of callbacks for\n     * the throttled event. If this is the last callback that was removed, the\n     * throttled event will also be stopped.\n     */\n    remove: (callback: EventListener) => {\n      const i = callbacks.indexOf(callback);\n      if (i >= 0) {\n        callbacks.splice(i, 1);\n\n        if (!callbacks.length) {\n          eventTarget.removeEventListener(eventType, handler, options);\n        }\n      }\n    },\n  };\n}\n\n/**\n * Creates a delegated event listener using custom events. Most of this code\n * comes from the MDN about resize listeners.\n *\n * This will return an object for adding or removing event handlers for the\n * provided `eventType` since only one base throttled event listener will be\n * created. Each callback that is added will be called with the event each time\n * the event is triggered. This does mean that you will manually need to remove\n * your callback like normal or else it can be called when no longer in use.\n * This also means that it doesn't \"hurt\" to call this function without\n * immediately calling the `add` function since the event won't start until\n * there is at least 1 callback.\n *\n * @see https://developer.mozilla.org/en-US/docs/Web/Events/resize#Examples\n * @param eventType - One of the event types that should be used to create a\n * delegated event for. This should be things like resize, click, scroll, etc.\n * @param eventTarget - The target that should have the delegated event handler\n * attached to. This is normally the window, but can be any element as needed.\n * @param throttle - Boolean if the event should be throttled or not. Normally\n * only event types like resize or scroll should be throttled for performance\n * boosts, but anything can be.\n * @returns The delegated event handler that allows you to add or remove\n * `EventListener`s to that event.\n */\nexport function delegateEvent(\n  eventType: string,\n  eventTarget: DelegatedEventTarget = window,\n  throttle: boolean = eventType === \"resize\" || eventType === \"scroll\",\n  options?: boolean | AddEventListenerOptions\n): DelegatedEventHandler {\n  let index = delegatedEvents.findIndex(\n    (event) =>\n      event.type === eventType &&\n      event.target === eventTarget &&\n      event.options === options &&\n      event.throttle === throttle\n  );\n\n  if (index === -1) {\n    delegatedEvents.push({\n      type: eventType,\n      target: eventTarget,\n      options,\n      throttle,\n      handler: createDelegatedEventHandler(\n        eventType,\n        eventTarget,\n        throttle,\n        options\n      ),\n    });\n\n    index = delegatedEvents.length - 1;\n  }\n\n  return delegatedEvents[index].handler;\n}\n"]},"metadata":{},"sourceType":"module"}