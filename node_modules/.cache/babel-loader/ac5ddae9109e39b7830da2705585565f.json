{"ast":null,"code":"var cached = {\n  height: undefined,\n  width: undefined\n};\n/**\n * This is used to reset the cached value for each test and verify the cached\n * behavior is working\n * @internal\n */\n\nexport var reset = function () {\n  cached.height = undefined;\n  cached.width = undefined;\n};\n/**\n * This will return the scrollbar size for a specific OS by creating a\n * temporary element to compare the height/width between it's inner element and\n * it's own height/width when scrollbars are enabled. This is useful when your\n * height/width calculations need to exclude scrollbars since they are included\n * by default but content can't be shown underneath them for for static\n * elements.\n *\n * Note: This will return `0` on Mac OS with the default \"Only show scrollbars\n * when scrolling\" which is to be expected. These scrollbars overlay the content\n * and actually don't take up height/width real estate.\n *\n * @see https://stackoverflow.com/a/13382873\n * @param type - Either the string \"height\" or \"width\" to determine which size\n * to get\n * @param forced - Boolean if the scrollbar height/width should be force\n * updated. When this is false, the \"cached\" value will be returned immediately\n * instead\n * @returns the current scrollbar width or -1 if running this on the server\n */\n\nexport function scrollbarSize(type, forced) {\n  if (type === void 0) {\n    type = \"width\";\n  }\n\n  if (forced === void 0) {\n    forced = false;\n  }\n  /* istanbul ignore if */\n\n\n  if (typeof window === \"undefined\") {\n    return -1;\n  }\n\n  var value = cached[type];\n\n  if (!forced && typeof value === \"number\") {\n    return value;\n  }\n\n  var outer = document.createElement(\"div\");\n  outer.style.visibility = \"hidden\";\n  outer.style.overflow = \"scroll\";\n  document.body.appendChild(outer);\n  var inner = document.createElement(\"div\");\n  outer.appendChild(inner);\n  var offsetType = type === \"width\" ? \"offsetWidth\" : \"offsetHeight\"; // the scrollbar width can be determined by comparing the width of the parent\n  // element that has scrollbars to the child element that does not.\n\n  value = outer[offsetType] - inner[offsetType];\n  cached[type] = value;\n  document.body.removeChild(outer);\n  return value;\n}","map":{"version":3,"mappings":"AAOA,IAAMA,MAAM,GAAU;EACpBC,MAAM,EAAEC,SADY;EAEpBC,KAAK,EAAED;AAFa,CAAtB;AAKA;;;;;;AAKA,OAAO,IAAME,KAAK,GAAG;EACnBJ,MAAM,CAACC,MAAP,GAAgBC,SAAhB;EACAF,MAAM,CAACG,KAAP,GAAeD,SAAf;AACD,CAHM;AAKP;;;;;;;;;;;;;;;;;;;;;AAoBA,OAAM,SAAUG,aAAV,CACJC,IADI,EAEJC,MAFI,EAEU;EADd;IAAAD;EAA0B;;EAC1B;IAAAC;EAAc;EAEd;;;EACA,IAAI,OAAOC,MAAP,KAAkB,WAAtB,EAAmC;IACjC,OAAO,CAAC,CAAR;EACD;;EAED,IAAIC,KAAK,GAAGT,MAAM,CAACM,IAAD,CAAlB;;EACA,IAAI,CAACC,MAAD,IAAW,OAAOE,KAAP,KAAiB,QAAhC,EAA0C;IACxC,OAAOA,KAAP;EACD;;EAED,IAAMC,KAAK,GAAGC,QAAQ,CAACC,aAAT,CAAuB,KAAvB,CAAd;EACAF,KAAK,CAACG,KAAN,CAAYC,UAAZ,GAAyB,QAAzB;EACAJ,KAAK,CAACG,KAAN,CAAYE,QAAZ,GAAuB,QAAvB;EACAJ,QAAQ,CAACK,IAAT,CAAcC,WAAd,CAA0BP,KAA1B;EAEA,IAAMQ,KAAK,GAAGP,QAAQ,CAACC,aAAT,CAAuB,KAAvB,CAAd;EACAF,KAAK,CAACO,WAAN,CAAkBC,KAAlB;EAEA,IAAMC,UAAU,GAAGb,IAAI,KAAK,OAAT,GAAmB,aAAnB,GAAmC,cAAtD,CApBc,CAsBd;EACA;;EACAG,KAAK,GAAGC,KAAK,CAACS,UAAD,CAAL,GAAoBD,KAAK,CAACC,UAAD,CAAjC;EACAnB,MAAM,CAACM,IAAD,CAAN,GAAeG,KAAf;EACAE,QAAQ,CAACK,IAAT,CAAcI,WAAd,CAA0BV,KAA1B;EAEA,OAAOD,KAAP;AACD","names":["cached","height","undefined","width","reset","scrollbarSize","type","forced","window","value","outer","document","createElement","style","visibility","overflow","body","appendChild","inner","offsetType","removeChild"],"sources":["C:\\Users\\hungr\\Documents\\VS-CODE\\notes-react\\node_modules\\@react-md\\utils\\src\\layout\\scrollbarSize.ts"],"sourcesContent":["interface Cache {\n  height: number | undefined;\n  width: number | undefined;\n}\n\ntype SizingType = \"height\" | \"width\";\n\nconst cached: Cache = {\n  height: undefined,\n  width: undefined,\n};\n\n/**\n * This is used to reset the cached value for each test and verify the cached\n * behavior is working\n * @internal\n */\nexport const reset = (): void => {\n  cached.height = undefined;\n  cached.width = undefined;\n};\n\n/**\n * This will return the scrollbar size for a specific OS by creating a\n * temporary element to compare the height/width between it's inner element and\n * it's own height/width when scrollbars are enabled. This is useful when your\n * height/width calculations need to exclude scrollbars since they are included\n * by default but content can't be shown underneath them for for static\n * elements.\n *\n * Note: This will return `0` on Mac OS with the default \"Only show scrollbars\n * when scrolling\" which is to be expected. These scrollbars overlay the content\n * and actually don't take up height/width real estate.\n *\n * @see https://stackoverflow.com/a/13382873\n * @param type - Either the string \"height\" or \"width\" to determine which size\n * to get\n * @param forced - Boolean if the scrollbar height/width should be force\n * updated. When this is false, the \"cached\" value will be returned immediately\n * instead\n * @returns the current scrollbar width or -1 if running this on the server\n */\nexport function scrollbarSize(\n  type: SizingType = \"width\",\n  forced = false\n): number {\n  /* istanbul ignore if */\n  if (typeof window === \"undefined\") {\n    return -1;\n  }\n\n  let value = cached[type];\n  if (!forced && typeof value === \"number\") {\n    return value;\n  }\n\n  const outer = document.createElement(\"div\");\n  outer.style.visibility = \"hidden\";\n  outer.style.overflow = \"scroll\";\n  document.body.appendChild(outer);\n\n  const inner = document.createElement(\"div\");\n  outer.appendChild(inner);\n\n  const offsetType = type === \"width\" ? \"offsetWidth\" : \"offsetHeight\";\n\n  // the scrollbar width can be determined by comparing the width of the parent\n  // element that has scrollbars to the child element that does not.\n  value = outer[offsetType] - inner[offsetType];\n  cached[type] = value;\n  document.body.removeChild(outer);\n\n  return value;\n}\n"]},"metadata":{},"sourceType":"module"}