{"ast":null,"code":"import { loop } from \"../loop\";\n/**\n * @remarks \\@since 5.0.0\n * @internal\n */\n\nexport var focusElement = function (element) {\n  element.focus();\n};\n/**\n * @remarks \\@since 5.0.0\n * @internal\n */\n\nexport var isNotFocusable = function (element, includeDisabled) {\n  if (!element) {\n    return true;\n  }\n\n  if (includeDisabled) {\n    return false;\n  }\n\n  return element.getAttribute(\"disabled\") !== null || element.getAttribute(\"aria-disabled\") === \"true\";\n};\n/**\n * @remarks \\@since 5.0.0\n * @internal\n */\n\nexport var getFirstFocusableIndex = function (watching, includeDisabled) {\n  if (!watching.length) {\n    return -1;\n  }\n\n  var firstIndex = 0;\n\n  while (firstIndex < watching.length - 1 && isNotFocusable(watching[firstIndex].element, includeDisabled)) {\n    firstIndex += 1;\n  }\n\n  if (isNotFocusable(watching[firstIndex].element, includeDisabled)) {\n    return -1;\n  }\n\n  return firstIndex;\n};\n/**\n * @remarks \\@since 5.0.0\n * @internal\n */\n\nexport var getLastFocusableIndex = function (watching, includeDisabled) {\n  if (!watching.length) {\n    return -1;\n  }\n\n  var lastIndex = watching.length - 1;\n\n  while (lastIndex > 0 && isNotFocusable(watching[lastIndex].element, includeDisabled)) {\n    lastIndex -= 1;\n  }\n\n  if (isNotFocusable(watching[lastIndex].element, includeDisabled)) {\n    return -1;\n  }\n\n  return lastIndex;\n};\n/**\n * @remarks \\@since 5.0.0\n * @internal\n */\n\nexport var getNextFocusableIndex = function (_a) {\n  var loopable = _a.loopable,\n      watching = _a.watching,\n      increment = _a.increment,\n      includeDisabled = _a.includeDisabled,\n      currentFocusIndex = _a.currentFocusIndex;\n  var min = getFirstFocusableIndex(watching, includeDisabled);\n  var max = getLastFocusableIndex(watching, includeDisabled);\n  var nextIndex = loop({\n    min: min,\n    max: max,\n    value: currentFocusIndex,\n    minmax: !loopable,\n    increment: increment\n  });\n\n  while (isNotFocusable(watching[nextIndex].element, includeDisabled) && (loopable || nextIndex !== (increment ? max : min))) {\n    nextIndex = loop({\n      min: min,\n      max: max,\n      value: nextIndex,\n      minmax: !loopable,\n      increment: increment\n    });\n  } // Since the `min` and `max` values are \"safely\" set, I don't need to verify\n  // the nextIndex is still focusable\n\n\n  return nextIndex;\n};\n/**\n * @remarks \\@since 5.0.0\n * @internal\n */\n\nexport function getSearchText(element, searchable) {\n  if (!searchable) {\n    return \"\";\n  }\n\n  var cloned = element.cloneNode(true);\n  cloned.querySelectorAll(\".rmd-icon--font,[aria-hidden=true],[hidden]\").forEach(function (element) {\n    var _a;\n\n    (_a = element.parentNode) === null || _a === void 0 ? void 0 : _a.removeChild(element);\n  }); // Note: It would be good to use `cloned.innerText` (maybe?) at some point,\n  // but it returns `undefined` in jsdom. It also does cause a reflow, so maybe\n  // this is fine?\n  // https://developer.mozilla.org/en-US/docs/Web/API/Node/textContent#differences_from_innertext\n\n  return (cloned.textContent || \"\").substring(0, 1).toUpperCase();\n}","map":{"version":3,"mappings":"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","names":["loop","focusElement","element","focus","isNotFocusable","includeDisabled","getAttribute","getFirstFocusableIndex","watching","length","firstIndex","getLastFocusableIndex","lastIndex","getNextFocusableIndex","_a","loopable","increment","currentFocusIndex","min","max","nextIndex","value","minmax","getSearchText","searchable","cloned","cloneNode","querySelectorAll","forEach","parentNode","removeChild","textContent","substring","toUpperCase"],"sources":["C:\\Users\\hungr\\Documents\\VS-CODE\\notes-react\\node_modules\\@react-md\\utils\\src\\keyboardMovement\\utils.ts"],"sourcesContent":["import type { KeyboardFocusElementData } from \"./types\";\nimport { loop } from \"../loop\";\n\n/**\n * @remarks \\@since 5.0.0\n * @internal\n */\nexport const focusElement = (element: HTMLElement): void => {\n  element.focus();\n};\n\n/**\n * @remarks \\@since 5.0.0\n * @internal\n */\nexport const isNotFocusable = (\n  element: HTMLElement | undefined,\n  includeDisabled: boolean\n): boolean => {\n  if (!element) {\n    return true;\n  }\n\n  if (includeDisabled) {\n    return false;\n  }\n\n  return (\n    element.getAttribute(\"disabled\") !== null ||\n    element.getAttribute(\"aria-disabled\") === \"true\"\n  );\n};\n\n/**\n * @remarks \\@since 5.0.0\n * @internal\n */\nexport const getFirstFocusableIndex = (\n  watching: readonly KeyboardFocusElementData[],\n  includeDisabled: boolean\n): number => {\n  if (!watching.length) {\n    return -1;\n  }\n\n  let firstIndex = 0;\n  while (\n    firstIndex < watching.length - 1 &&\n    isNotFocusable(watching[firstIndex].element, includeDisabled)\n  ) {\n    firstIndex += 1;\n  }\n\n  if (isNotFocusable(watching[firstIndex].element, includeDisabled)) {\n    return -1;\n  }\n\n  return firstIndex;\n};\n\n/**\n * @remarks \\@since 5.0.0\n * @internal\n */\nexport const getLastFocusableIndex = (\n  watching: readonly KeyboardFocusElementData[],\n  includeDisabled: boolean\n): number => {\n  if (!watching.length) {\n    return -1;\n  }\n\n  let lastIndex = watching.length - 1;\n  while (\n    lastIndex > 0 &&\n    isNotFocusable(watching[lastIndex].element, includeDisabled)\n  ) {\n    lastIndex -= 1;\n  }\n\n  if (isNotFocusable(watching[lastIndex].element, includeDisabled)) {\n    return -1;\n  }\n\n  return lastIndex;\n};\n\n/**\n * @remarks \\@since 5.0.0\n * @internal\n */\ninterface NextFocusableIndexOptions {\n  loopable: boolean;\n  watching: readonly KeyboardFocusElementData[];\n  increment: boolean;\n  includeDisabled: boolean;\n  currentFocusIndex: number;\n}\n\n/**\n * @remarks \\@since 5.0.0\n * @internal\n */\nexport const getNextFocusableIndex = ({\n  loopable,\n  watching,\n  increment,\n  includeDisabled,\n  currentFocusIndex,\n}: NextFocusableIndexOptions): number => {\n  const min = getFirstFocusableIndex(watching, includeDisabled);\n  const max = getLastFocusableIndex(watching, includeDisabled);\n  let nextIndex = loop({\n    min,\n    max,\n    value: currentFocusIndex,\n    minmax: !loopable,\n    increment,\n  });\n  while (\n    isNotFocusable(watching[nextIndex].element, includeDisabled) &&\n    (loopable || nextIndex !== (increment ? max : min))\n  ) {\n    nextIndex = loop({\n      min,\n      max,\n      value: nextIndex,\n      minmax: !loopable,\n      increment,\n    });\n  }\n\n  // Since the `min` and `max` values are \"safely\" set, I don't need to verify\n  // the nextIndex is still focusable\n  return nextIndex;\n};\n\n/**\n * @remarks \\@since 5.0.0\n * @internal\n */\nexport function getSearchText(\n  element: HTMLElement,\n  searchable: boolean\n): string {\n  if (!searchable) {\n    return \"\";\n  }\n\n  const cloned = element.cloneNode(true) as HTMLElement;\n  cloned\n    .querySelectorAll(\".rmd-icon--font,[aria-hidden=true],[hidden]\")\n    .forEach((element) => {\n      element.parentNode?.removeChild(element);\n    });\n\n  // Note: It would be good to use `cloned.innerText` (maybe?) at some point,\n  // but it returns `undefined` in jsdom. It also does cause a reflow, so maybe\n  // this is fine?\n  // https://developer.mozilla.org/en-US/docs/Web/API/Node/textContent#differences_from_innertext\n  return (cloned.textContent || \"\").substring(0, 1).toUpperCase();\n}\n"]},"metadata":{},"sourceType":"module"}