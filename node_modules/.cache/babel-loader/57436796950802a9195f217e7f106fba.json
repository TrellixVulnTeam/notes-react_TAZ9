{"ast":null,"code":"var __assign = this && this.__assign || function () {\n  __assign = Object.assign || function (t) {\n    for (var s, i = 1, n = arguments.length; i < n; i++) {\n      s = arguments[i];\n\n      for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p)) t[p] = s[p];\n    }\n\n    return t;\n  };\n\n  return __assign.apply(this, arguments);\n};\n\nvar __read = this && this.__read || function (o, n) {\n  var m = typeof Symbol === \"function\" && o[Symbol.iterator];\n  if (!m) return o;\n  var i = m.call(o),\n      r,\n      ar = [],\n      e;\n\n  try {\n    while ((n === void 0 || n-- > 0) && !(r = i.next()).done) ar.push(r.value);\n  } catch (error) {\n    e = {\n      error: error\n    };\n  } finally {\n    try {\n      if (r && !r.done && (m = i[\"return\"])) m.call(i);\n    } finally {\n      if (e) throw e.error;\n    }\n  }\n\n  return ar;\n};\n\nimport { useCallback, useEffect, useRef, useState } from \"react\";\nimport { useFixedPositioning } from \"@react-md/transition\";\nimport { MovementPresets, scrollIntoView, useActiveDescendantMovement, useCloseOnOutsideClick, useEnsuredRef, useIsUserInteractionMode, useToggle } from \"@react-md/utils\";\nimport { getFilterFunction } from \"./utils\";\n/**\n * This hook handles all the autocomplete's \"logic\" and behavior.\n *\n * @internal\n */\n\nexport function useAutoComplete(_a) {\n  var _b;\n\n  var suggestionsId = _a.suggestionsId,\n      data = _a.data,\n      propValue = _a.propValue,\n      _c = _a.defaultValue,\n      defaultValue = _c === void 0 ? \"\" : _c,\n      filterFn = _a.filter,\n      filterOptions = _a.filterOptions,\n      filterOnNoValue = _a.filterOnNoValue,\n      valueKey = _a.valueKey,\n      getResultId = _a.getResultId,\n      getResultValue = _a.getResultValue,\n      onBlur = _a.onBlur,\n      onFocus = _a.onFocus,\n      onClick = _a.onClick,\n      onChange = _a.onChange,\n      onKeyDown = _a.onKeyDown,\n      forwardedRef = _a.forwardedRef,\n      onAutoComplete = _a.onAutoComplete,\n      clearOnAutoComplete = _a.clearOnAutoComplete,\n      anchor = _a.anchor,\n      xMargin = _a.xMargin,\n      yMargin = _a.yMargin,\n      vwMargin = _a.vwMargin,\n      vhMargin = _a.vhMargin,\n      transformOrigin = _a.transformOrigin,\n      listboxWidth = _a.listboxWidth,\n      listboxStyle = _a.listboxStyle,\n      preventOverlap = _a.preventOverlap,\n      disableSwapping = _a.disableSwapping,\n      disableVHBounds = _a.disableVHBounds,\n      closeOnResize = _a.closeOnResize,\n      closeOnScroll = _a.closeOnScroll,\n      propDisableShowOnFocus = _a.disableShowOnFocus,\n      isListAutocomplete = _a.isListAutocomplete,\n      isInlineAutocomplete = _a.isInlineAutocomplete;\n\n  var _d = __read(useEnsuredRef(forwardedRef), 2),\n      ref = _d[0],\n      refHandler = _d[1];\n\n  var filter = getFilterFunction(filterFn);\n\n  var _e = __read(useState(function () {\n    var _a;\n\n    var options = __assign(__assign({}, filterOptions), {\n      valueKey: valueKey,\n      getItemValue: getResultValue,\n      startsWith: (_a = filterOptions === null || filterOptions === void 0 ? void 0 : filterOptions.startsWith) !== null && _a !== void 0 ? _a : isInlineAutocomplete\n    });\n\n    var value = propValue !== null && propValue !== void 0 ? propValue : defaultValue;\n    var filteredData = filterOnNoValue || value ? filter(value, data, options) : data;\n    var match = value;\n\n    if (isInlineAutocomplete && filteredData.length) {\n      match = getResultValue(filteredData[0], valueKey);\n    }\n\n    return {\n      value: value,\n      match: match,\n      filteredData: filteredData\n    };\n  }), 2),\n      _f = _e[0],\n      stateValue = _f.value,\n      match = _f.match,\n      stateFilteredData = _f.filteredData,\n      setState = _e[1];\n\n  var filteredData = filterFn === \"none\" ? data : stateFilteredData;\n  var startsWith = (_b = filterOptions === null || filterOptions === void 0 ? void 0 : filterOptions.startsWith) !== null && _b !== void 0 ? _b : isInlineAutocomplete;\n  var value = propValue !== null && propValue !== void 0 ? propValue : stateValue;\n  var setValue = useCallback(function (nextValue) {\n    var isBackspace = value.length > nextValue.length || !!match && value.length === nextValue.length;\n    var filtered = data;\n\n    if (nextValue || filterOnNoValue) {\n      var options = __assign(__assign({}, filterOptions), {\n        valueKey: valueKey,\n        getItemValue: getResultValue,\n        startsWith: startsWith\n      });\n\n      filtered = filter(nextValue, data, options);\n    }\n\n    var nextMatch = nextValue;\n\n    if (isInlineAutocomplete && filtered.length && !isBackspace) {\n      nextMatch = getResultValue(filtered[0], valueKey);\n      var input = ref.current;\n\n      if (input && !isBackspace) {\n        input.value = nextMatch;\n        input.setSelectionRange(nextValue.length, nextMatch.length);\n      }\n    }\n\n    setState({\n      value: nextValue,\n      match: nextMatch,\n      filteredData: filtered\n    });\n  }, [ref, data, filter, filterOnNoValue, filterOptions, isInlineAutocomplete, getResultValue, value, match, startsWith, valueKey]); // this is really just a hacky way to make sure that once a value has been\n  // autocompleted, the menu doesn't immediately re-appear due to the hook below\n  // for showing when the value/ filtered data list change\n\n  var autocompleted = useRef(false);\n  var handleChange = useCallback(function (event) {\n    if (onChange) {\n      onChange(event);\n    }\n\n    autocompleted.current = false;\n    setValue(event.currentTarget.value);\n  }, [setValue, onChange]);\n\n  var _g = __read(useToggle(false), 3),\n      visible = _g[0],\n      show = _g[1],\n      hide = _g[2];\n\n  var isTouch = useIsUserInteractionMode(\"touch\");\n  var disableShowOnFocus = propDisableShowOnFocus !== null && propDisableShowOnFocus !== void 0 ? propDisableShowOnFocus : isTouch;\n  var focused = useRef(false);\n  var handleBlur = useCallback(function (event) {\n    if (onBlur) {\n      onBlur(event);\n    }\n\n    focused.current = false;\n  }, [onBlur]);\n  var handleFocus = useCallback(function (event) {\n    if (onFocus) {\n      onFocus(event);\n    }\n\n    if (disableShowOnFocus) {\n      return;\n    }\n\n    focused.current = true;\n\n    if (isListAutocomplete && filteredData.length) {\n      show();\n    }\n  }, [filteredData, isListAutocomplete, onFocus, show, disableShowOnFocus]);\n  var handleClick = useCallback(function (event) {\n    if (onClick) {\n      onClick(event);\n    } // since click events also trigger focus events right beforehand, want to\n    // skip the first click handler and require a second click to show it.\n    // this is why the focused.current isn't set onFocus for\n    // disableShowOnFocus\n\n\n    if (disableShowOnFocus && !focused.current) {\n      focused.current = true;\n      return;\n    }\n\n    if (isListAutocomplete && filteredData.length) {\n      show();\n    }\n  }, [disableShowOnFocus, filteredData.length, isListAutocomplete, onClick, show]);\n  var handleAutoComplete = useCallback(function (index) {\n    var result = filteredData[index];\n    var resultValue = getResultValue(result, valueKey);\n\n    if (onAutoComplete) {\n      onAutoComplete({\n        value: resultValue,\n        index: index,\n        result: result,\n        dataIndex: data.findIndex(function (datum) {\n          return getResultValue(datum, valueKey) === resultValue;\n        }),\n        filteredData: filteredData\n      });\n    }\n\n    setValue(clearOnAutoComplete ? \"\" : resultValue);\n    autocompleted.current = true;\n  }, [clearOnAutoComplete, data, filteredData, getResultValue, onAutoComplete, valueKey, setValue]);\n  var nodeRef = useRef(null);\n\n  var _h = useActiveDescendantMovement(__assign(__assign({}, MovementPresets.VERTICAL_COMBOBOX), {\n    getId: getResultId,\n    items: filteredData,\n    baseId: suggestionsId,\n    onChange: function (_a, itemRefs) {\n      var index = _a.index,\n          items = _a.items,\n          target = _a.target; // the default scroll into view behavior for aria-activedescendant\n      // movement won't work here since the \"target\" element will actually be\n      // the input element instead of the listbox. So need to implement the\n      // scroll into view behavior manually from the listbox instead.\n\n      var item = itemRefs[index] && itemRefs[index].current;\n      var listbox = nodeRef.current;\n\n      if (item && listbox && listbox.scrollHeight > listbox.offsetHeight) {\n        scrollIntoView(listbox, item);\n      }\n\n      if (!isInlineAutocomplete) {\n        return;\n      }\n\n      var nextMatch = getResultValue(items[index], valueKey);\n      target.value = nextMatch;\n      target.setSelectionRange(0, nextMatch.length);\n      setState(function (prevState) {\n        return __assign(__assign({}, prevState), {\n          value: nextMatch,\n          match: nextMatch\n        });\n      });\n    },\n    onKeyDown: function (event) {\n      if (onKeyDown) {\n        onKeyDown(event);\n      }\n\n      var input = event.currentTarget;\n\n      switch (event.key) {\n        case \"ArrowDown\":\n          if (isListAutocomplete && event.altKey && !visible && filteredData.length) {\n            // don't want the cursor to move if there is text\n            event.preventDefault();\n            event.stopPropagation();\n            show();\n            setFocusedIndex(-1);\n          }\n\n          break;\n\n        case \"ArrowUp\":\n          if (isListAutocomplete && event.altKey && visible) {\n            // don't want the cursor to move if there is text\n            event.preventDefault();\n            event.stopPropagation();\n            hide();\n          }\n\n          break;\n\n        case \"Tab\":\n          event.stopPropagation();\n          hide();\n          break;\n\n        case \"ArrowRight\":\n          if (isInlineAutocomplete && input.selectionStart !== input.selectionEnd) {\n            var index = focusedIndex !== -1 ? focusedIndex : 0;\n            hide();\n            handleAutoComplete(index);\n          }\n\n          break;\n\n        case \"Enter\":\n          if (visible && focusedIndex >= 0) {\n            event.stopPropagation();\n            handleAutoComplete(focusedIndex);\n            hide();\n          }\n\n          break;\n\n        case \"Escape\":\n          if (visible) {\n            event.stopPropagation();\n            hide();\n          } else if (value) {\n            event.stopPropagation();\n            setValue(\"\");\n          }\n\n          break;\n        // no default\n      }\n    }\n  })),\n      activeId = _h.activeId,\n      itemRefs = _h.itemRefs,\n      handleKeyDown = _h.onKeyDown,\n      focusedIndex = _h.focusedIndex,\n      setFocusedIndex = _h.setFocusedIndex;\n\n  useCloseOnOutsideClick({\n    enabled: visible,\n    element: ref.current,\n    onOutsideClick: hide\n  });\n\n  var _j = useFixedPositioning({\n    fixedTo: ref,\n    nodeRef: nodeRef,\n    anchor: anchor,\n    onScroll: function (_event, _a) {\n      var visible = _a.visible;\n\n      if (closeOnScroll || !visible) {\n        hide();\n      }\n    },\n    onResize: closeOnResize ? hide : undefined,\n    width: listboxWidth,\n    xMargin: xMargin,\n    yMargin: yMargin,\n    vwMargin: vwMargin,\n    vhMargin: vhMargin,\n    transformOrigin: transformOrigin,\n    preventOverlap: preventOverlap,\n    disableSwapping: disableSwapping,\n    disableVHBounds: disableVHBounds\n  }),\n      listboxRef = _j.ref,\n      style = _j.style,\n      callbacks = _j.callbacks,\n      updateStyle = _j.updateStyle;\n\n  useEffect(function () {\n    if (!focused.current || autocompleted.current) {\n      return;\n    }\n\n    if (filteredData.length && !visible && value.length && isListAutocomplete) {\n      show();\n    } else if (!filteredData.length && visible) {\n      hide();\n    } // this effect is just for toggling the visibility states as needed if the\n    // value or filter data list changes\n    // eslint-disable-next-line react-hooks/exhaustive-deps\n\n  }, [filteredData, value]);\n  useEffect(function () {\n    if (!visible) {\n      setFocusedIndex(-1);\n      return;\n    }\n\n    updateStyle(); // only want to trigger on data changes and setFocusedIndex shouldn't change\n    // anyways\n    // eslint-disable-next-line react-hooks/exhaustive-deps\n  }, [visible, filteredData]);\n  return {\n    ref: refHandler,\n    value: value,\n    match: match,\n    visible: visible,\n    activeId: activeId,\n    itemRefs: itemRefs,\n    filteredData: filteredData,\n    fixedStyle: __assign(__assign({}, style), listboxStyle),\n    transitionHooks: callbacks,\n    listboxRef: listboxRef,\n    handleBlur: handleBlur,\n    handleFocus: handleFocus,\n    handleClick: handleClick,\n    handleChange: handleChange,\n    handleKeyDown: handleKeyDown,\n    handleAutoComplete: handleAutoComplete\n  };\n}","map":{"version":3,"mappings":"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","names":["useCallback","useEffect","useRef","useState","useFixedPositioning","MovementPresets","scrollIntoView","useActiveDescendantMovement","useCloseOnOutsideClick","useEnsuredRef","useIsUserInteractionMode","useToggle","getFilterFunction","useAutoComplete","_a","suggestionsId","data","propValue","_c","defaultValue","filterFn","filterOptions","filterOnNoValue","valueKey","getResultId","getResultValue","onBlur","onFocus","onClick","onChange","onKeyDown","forwardedRef","onAutoComplete","clearOnAutoComplete","anchor","xMargin","yMargin","vwMargin","vhMargin","transformOrigin","listboxWidth","listboxStyle","preventOverlap","disableSwapping","disableVHBounds","closeOnResize","closeOnScroll","propDisableShowOnFocus","isListAutocomplete","isInlineAutocomplete","ref","refHandler","filter","options","getItemValue","startsWith","value","filteredData","match","length","_f","stateValue","stateFilteredData","setState","_b","setValue","nextValue","isBackspace","filtered","nextMatch","input","current","setSelectionRange","autocompleted","handleChange","event","currentTarget","visible","show","hide","isTouch","disableShowOnFocus","focused","handleBlur","handleFocus","handleClick","handleAutoComplete","index","result","resultValue","dataIndex","findIndex","datum","nodeRef","VERTICAL_COMBOBOX","getId","items","baseId","itemRefs","target","item","listbox","scrollHeight","offsetHeight","prevState","key","altKey","preventDefault","stopPropagation","setFocusedIndex","selectionStart","selectionEnd","focusedIndex","activeId","handleKeyDown","enabled","element","onOutsideClick","fixedTo","onScroll","_event","onResize","undefined","width","listboxRef","style","callbacks","updateStyle","fixedStyle","transitionHooks"],"sources":["C:\\Users\\hungr\\Documents\\VS-CODE\\notes-react\\node_modules\\@react-md\\autocomplete\\src\\useAutoComplete.ts"],"sourcesContent":["import type {\n  ChangeEventHandler,\n  CSSProperties,\n  FocusEventHandler,\n  HTMLAttributes,\n  KeyboardEventHandler,\n  MouseEventHandler,\n  Ref,\n} from \"react\";\nimport { useCallback, useEffect, useRef, useState } from \"react\";\nimport type { ListElement } from \"@react-md/list\";\nimport type { FixedPositioningTransitionCallbacks } from \"@react-md/transition\";\nimport { useFixedPositioning } from \"@react-md/transition\";\nimport type { ItemRefList } from \"@react-md/utils\";\nimport {\n  MovementPresets,\n  scrollIntoView,\n  useActiveDescendantMovement,\n  useCloseOnOutsideClick,\n  useEnsuredRef,\n  useIsUserInteractionMode,\n  useToggle,\n} from \"@react-md/utils\";\n\nimport type {\n  AutoCompleteData,\n  AutoCompleteListboxPositionOptions,\n  AutoCompleteProps,\n} from \"./types\";\nimport { getFilterFunction } from \"./utils\";\n\ntype EventHandlers = Pick<\n  HTMLAttributes<HTMLInputElement>,\n  \"onBlur\" | \"onFocus\" | \"onChange\" | \"onClick\" | \"onKeyDown\"\n>;\n\nexport type RequiredAutoCompleteProps = Required<\n  Pick<\n    AutoCompleteProps,\n    | \"data\"\n    | \"filter\"\n    | \"filterOptions\"\n    | \"filterOnNoValue\"\n    | \"valueKey\"\n    | \"getResultId\"\n    | \"getResultValue\"\n    | \"clearOnAutoComplete\"\n  >\n>;\n\nexport type OptionalAutoCompleteProps = Pick<\n  AutoCompleteProps,\n  \"onAutoComplete\" | \"disableShowOnFocus\"\n>;\n\nexport interface AutoCompleteOptions\n  extends EventHandlers,\n    OptionalAutoCompleteProps,\n    RequiredAutoCompleteProps,\n    AutoCompleteListboxPositionOptions {\n  isListAutocomplete: boolean;\n  isInlineAutocomplete: boolean;\n  forwardedRef?: Ref<HTMLInputElement>;\n  suggestionsId: string;\n  propValue?: string;\n  defaultValue?: string;\n}\n\nexport interface AutoCompleteReturnValue {\n  ref: (instance: HTMLInputElement | null) => void;\n  match: string;\n  value: string;\n  visible: boolean;\n  activeId: string;\n  itemRefs: ItemRefList<HTMLLIElement>;\n  filteredData: readonly AutoCompleteData[];\n  listboxRef: Ref<ListElement>;\n  handleBlur: FocusEventHandler<HTMLInputElement>;\n  handleFocus: FocusEventHandler<HTMLInputElement>;\n  handleClick: MouseEventHandler<HTMLInputElement>;\n  handleChange: ChangeEventHandler<HTMLInputElement>;\n  handleKeyDown: KeyboardEventHandler<HTMLInputElement>;\n  handleAutoComplete: (index: number) => void;\n  fixedStyle: CSSProperties | undefined;\n  transitionHooks: Required<FixedPositioningTransitionCallbacks>;\n}\n\n/**\n * This hook handles all the autocomplete's \"logic\" and behavior.\n *\n * @internal\n */\nexport function useAutoComplete({\n  suggestionsId,\n  data,\n  propValue,\n  defaultValue = \"\",\n  filter: filterFn,\n  filterOptions,\n  filterOnNoValue,\n  valueKey,\n  getResultId,\n  getResultValue,\n  onBlur,\n  onFocus,\n  onClick,\n  onChange,\n  onKeyDown,\n  forwardedRef,\n  onAutoComplete,\n  clearOnAutoComplete,\n  anchor,\n  xMargin,\n  yMargin,\n  vwMargin,\n  vhMargin,\n  transformOrigin,\n  listboxWidth,\n  listboxStyle,\n  preventOverlap,\n  disableSwapping,\n  disableVHBounds,\n  closeOnResize,\n  closeOnScroll,\n  disableShowOnFocus: propDisableShowOnFocus,\n  isListAutocomplete,\n  isInlineAutocomplete,\n}: AutoCompleteOptions): AutoCompleteReturnValue {\n  const [ref, refHandler] = useEnsuredRef(forwardedRef);\n\n  const filter = getFilterFunction(filterFn);\n  const [\n    { value: stateValue, match, filteredData: stateFilteredData },\n    setState,\n  ] = useState(() => {\n    const options = {\n      ...filterOptions,\n      valueKey,\n      getItemValue: getResultValue,\n      startsWith: filterOptions?.startsWith ?? isInlineAutocomplete,\n    };\n    const value = propValue ?? defaultValue;\n    const filteredData =\n      filterOnNoValue || value ? filter(value, data, options) : data;\n\n    let match = value;\n    if (isInlineAutocomplete && filteredData.length) {\n      match = getResultValue(filteredData[0], valueKey);\n    }\n\n    return {\n      value,\n      match,\n      filteredData,\n    };\n  });\n  const filteredData = filterFn === \"none\" ? data : stateFilteredData;\n  const startsWith = filterOptions?.startsWith ?? isInlineAutocomplete;\n  const value = propValue ?? stateValue;\n\n  const setValue = useCallback(\n    (nextValue: string) => {\n      const isBackspace =\n        value.length > nextValue.length ||\n        (!!match && value.length === nextValue.length);\n\n      let filtered = data;\n      if (nextValue || filterOnNoValue) {\n        const options = {\n          ...filterOptions,\n          valueKey,\n          getItemValue: getResultValue,\n          startsWith,\n        };\n\n        filtered = filter(nextValue, data, options);\n      }\n\n      let nextMatch = nextValue;\n      if (isInlineAutocomplete && filtered.length && !isBackspace) {\n        nextMatch = getResultValue(filtered[0], valueKey);\n\n        const input = ref.current;\n        if (input && !isBackspace) {\n          input.value = nextMatch;\n          input.setSelectionRange(nextValue.length, nextMatch.length);\n        }\n      }\n\n      setState({ value: nextValue, match: nextMatch, filteredData: filtered });\n    },\n    [\n      ref,\n      data,\n      filter,\n      filterOnNoValue,\n      filterOptions,\n      isInlineAutocomplete,\n      getResultValue,\n      value,\n      match,\n      startsWith,\n      valueKey,\n    ]\n  );\n\n  // this is really just a hacky way to make sure that once a value has been\n  // autocompleted, the menu doesn't immediately re-appear due to the hook below\n  // for showing when the value/ filtered data list change\n  const autocompleted = useRef(false);\n\n  const handleChange = useCallback(\n    (event: React.ChangeEvent<HTMLInputElement>) => {\n      if (onChange) {\n        onChange(event);\n      }\n\n      autocompleted.current = false;\n      setValue(event.currentTarget.value);\n    },\n    [setValue, onChange]\n  );\n\n  const [visible, show, hide] = useToggle(false);\n  const isTouch = useIsUserInteractionMode(\"touch\");\n  const disableShowOnFocus = propDisableShowOnFocus ?? isTouch;\n\n  const focused = useRef(false);\n  const handleBlur = useCallback(\n    (event: React.FocusEvent<HTMLInputElement>) => {\n      if (onBlur) {\n        onBlur(event);\n      }\n\n      focused.current = false;\n    },\n    [onBlur]\n  );\n  const handleFocus = useCallback(\n    (event: React.FocusEvent<HTMLInputElement>) => {\n      if (onFocus) {\n        onFocus(event);\n      }\n\n      if (disableShowOnFocus) {\n        return;\n      }\n\n      focused.current = true;\n      if (isListAutocomplete && filteredData.length) {\n        show();\n      }\n    },\n    [filteredData, isListAutocomplete, onFocus, show, disableShowOnFocus]\n  );\n  const handleClick = useCallback(\n    (event: React.MouseEvent<HTMLInputElement>) => {\n      if (onClick) {\n        onClick(event);\n      }\n\n      // since click events also trigger focus events right beforehand, want to\n      // skip the first click handler and require a second click to show it.\n      // this is why the focused.current isn't set onFocus for\n      // disableShowOnFocus\n      if (disableShowOnFocus && !focused.current) {\n        focused.current = true;\n        return;\n      }\n\n      if (isListAutocomplete && filteredData.length) {\n        show();\n      }\n    },\n    [disableShowOnFocus, filteredData.length, isListAutocomplete, onClick, show]\n  );\n\n  const handleAutoComplete = useCallback(\n    (index: number) => {\n      const result = filteredData[index];\n      const resultValue = getResultValue(result, valueKey);\n      if (onAutoComplete) {\n        onAutoComplete({\n          value: resultValue,\n          index,\n          result,\n          dataIndex: data.findIndex(\n            (datum) => getResultValue(datum, valueKey) === resultValue\n          ),\n          filteredData,\n        });\n      }\n\n      setValue(clearOnAutoComplete ? \"\" : resultValue);\n      autocompleted.current = true;\n    },\n    [\n      clearOnAutoComplete,\n      data,\n      filteredData,\n      getResultValue,\n      onAutoComplete,\n      valueKey,\n      setValue,\n    ]\n  );\n\n  const nodeRef = useRef<ListElement | null>(null);\n  const {\n    activeId,\n    itemRefs,\n    onKeyDown: handleKeyDown,\n    focusedIndex,\n    setFocusedIndex,\n  } = useActiveDescendantMovement<\n    AutoCompleteData,\n    HTMLInputElement,\n    HTMLLIElement\n  >({\n    ...MovementPresets.VERTICAL_COMBOBOX,\n    getId: getResultId,\n    items: filteredData,\n    baseId: suggestionsId,\n    onChange({ index, items, target }, itemRefs) {\n      // the default scroll into view behavior for aria-activedescendant\n      // movement won't work here since the \"target\" element will actually be\n      // the input element instead of the listbox. So need to implement the\n      // scroll into view behavior manually from the listbox instead.\n      const item = itemRefs[index] && itemRefs[index].current;\n      const { current: listbox } = nodeRef;\n      if (item && listbox && listbox.scrollHeight > listbox.offsetHeight) {\n        scrollIntoView(listbox, item);\n      }\n\n      if (!isInlineAutocomplete) {\n        return;\n      }\n\n      const nextMatch = getResultValue(items[index], valueKey);\n      target.value = nextMatch;\n      target.setSelectionRange(0, nextMatch.length);\n      setState((prevState) => ({\n        ...prevState,\n        value: nextMatch,\n        match: nextMatch,\n      }));\n    },\n    onKeyDown(event) {\n      if (onKeyDown) {\n        onKeyDown(event);\n      }\n\n      const input = event.currentTarget;\n      switch (event.key) {\n        case \"ArrowDown\":\n          if (\n            isListAutocomplete &&\n            event.altKey &&\n            !visible &&\n            filteredData.length\n          ) {\n            // don't want the cursor to move if there is text\n            event.preventDefault();\n            event.stopPropagation();\n            show();\n            setFocusedIndex(-1);\n          }\n          break;\n        case \"ArrowUp\":\n          if (isListAutocomplete && event.altKey && visible) {\n            // don't want the cursor to move if there is text\n            event.preventDefault();\n            event.stopPropagation();\n            hide();\n          }\n          break;\n        case \"Tab\":\n          event.stopPropagation();\n          hide();\n          break;\n        case \"ArrowRight\":\n          if (\n            isInlineAutocomplete &&\n            input.selectionStart !== input.selectionEnd\n          ) {\n            const index = focusedIndex !== -1 ? focusedIndex : 0;\n            hide();\n            handleAutoComplete(index);\n          }\n          break;\n        case \"Enter\":\n          if (visible && focusedIndex >= 0) {\n            event.stopPropagation();\n            handleAutoComplete(focusedIndex);\n            hide();\n          }\n          break;\n        case \"Escape\":\n          if (visible) {\n            event.stopPropagation();\n            hide();\n          } else if (value) {\n            event.stopPropagation();\n            setValue(\"\");\n          }\n          break;\n        // no default\n      }\n    },\n  });\n\n  useCloseOnOutsideClick({\n    enabled: visible,\n    element: ref.current,\n    onOutsideClick: hide,\n  });\n\n  const {\n    ref: listboxRef,\n    style,\n    callbacks,\n    updateStyle,\n  } = useFixedPositioning({\n    fixedTo: ref,\n    nodeRef,\n    anchor,\n    onScroll(_event, { visible }) {\n      if (closeOnScroll || !visible) {\n        hide();\n      }\n    },\n    onResize: closeOnResize ? hide : undefined,\n    width: listboxWidth,\n    xMargin,\n    yMargin,\n    vwMargin,\n    vhMargin,\n    transformOrigin,\n    preventOverlap,\n    disableSwapping,\n    disableVHBounds,\n  });\n\n  useEffect(() => {\n    if (!focused.current || autocompleted.current) {\n      return;\n    }\n\n    if (filteredData.length && !visible && value.length && isListAutocomplete) {\n      show();\n    } else if (!filteredData.length && visible) {\n      hide();\n    }\n\n    // this effect is just for toggling the visibility states as needed if the\n    // value or filter data list changes\n    // eslint-disable-next-line react-hooks/exhaustive-deps\n  }, [filteredData, value]);\n\n  useEffect(() => {\n    if (!visible) {\n      setFocusedIndex(-1);\n      return;\n    }\n\n    updateStyle();\n\n    // only want to trigger on data changes and setFocusedIndex shouldn't change\n    // anyways\n    // eslint-disable-next-line react-hooks/exhaustive-deps\n  }, [visible, filteredData]);\n\n  return {\n    ref: refHandler,\n    value,\n    match,\n    visible,\n    activeId,\n    itemRefs,\n    filteredData,\n    fixedStyle: { ...style, ...listboxStyle },\n    transitionHooks: callbacks,\n    listboxRef,\n    handleBlur,\n    handleFocus,\n    handleClick,\n    handleChange,\n    handleKeyDown,\n    handleAutoComplete,\n  };\n}\n"]},"metadata":{},"sourceType":"module"}