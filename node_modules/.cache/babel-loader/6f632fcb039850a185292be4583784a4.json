{"ast":null,"code":"var __read = this && this.__read || function (o, n) {\n  var m = typeof Symbol === \"function\" && o[Symbol.iterator];\n  if (!m) return o;\n  var i = m.call(o),\n      r,\n      ar = [],\n      e;\n\n  try {\n    while ((n === void 0 || n-- > 0) && !(r = i.next()).done) ar.push(r.value);\n  } catch (error) {\n    e = {\n      error: error\n    };\n  } finally {\n    try {\n      if (r && !r.done && (m = i[\"return\"])) m.call(i);\n    } finally {\n      if (e) throw e.error;\n    }\n  }\n\n  return ar;\n};\n\nimport { useCallback, useEffect, useRef, useState } from \"react\";\n/**\n * This hook is used to handle the different states for the text field based on\n * the current value and user interaction.\n *\n * @internal\n * @remarks \\@since 2.5.2\n */\n\nexport function useFieldStates(_a) {\n  var onBlur = _a.onBlur,\n      onFocus = _a.onFocus,\n      onChange = _a.onChange,\n      value = _a.value,\n      defaultValue = _a.defaultValue;\n\n  var _b = __read(useState(false), 2),\n      focused = _b[0],\n      setFocused = _b[1];\n\n  var _c = __read(useState(function () {\n    if (typeof value === \"undefined\") {\n      return typeof defaultValue !== \"undefined\" && defaultValue.length > 0;\n    }\n\n    return value.length > 0;\n  }), 2),\n      valued = _c[0],\n      setValued = _c[1];\n\n  var handleBlur = useCallback(function (event) {\n    if (onBlur) {\n      onBlur(event);\n    }\n\n    setFocused(false);\n    var input = event.currentTarget;\n\n    if (input.getAttribute(\"type\") === \"number\") {\n      input.checkValidity();\n      setValued(input.validity.badInput || (value !== null && value !== void 0 ? value : input.value).length > 0);\n    }\n  }, [onBlur, value]);\n  var handleFocus = useCallback(function (event) {\n    if (onFocus) {\n      onFocus(event);\n    }\n\n    setFocused(true);\n  }, [onFocus]);\n  var handleChange = useCallback(function (event) {\n    if (onChange) {\n      onChange(event);\n    }\n\n    var input = event.currentTarget;\n\n    if (input.getAttribute(\"type\") === \"number\") {\n      input.checkValidity();\n      /* istanbul ignore next */\n\n      if (input.validity.badInput) {\n        return;\n      }\n    }\n\n    setValued(input.value.length > 0);\n  }, [onChange]); // another way to handle this could be to just make the `valued` state derived\n  // based on the `value`, but it gets wonky for number fields. This technically\n  // still fails right now for number fields if you don't use the\n  // `useNumberField` hook since the `value` will be set back to the empty\n  // string on invalid numbers.\n\n  var prevValue = useRef(value);\n  useEffect(function () {\n    if (prevValue.current !== value && typeof value === \"string\") {\n      prevValue.current = value;\n      setValued(value.length > 0);\n    }\n  }, [value]);\n  return {\n    valued: valued,\n    focused: focused,\n    onBlur: handleBlur,\n    onFocus: handleFocus,\n    onChange: handleChange\n  };\n}","map":{"version":3,"mappings":";;;;;;;;;;;;;;;;;;;;;;;;;AAMA,SAASA,WAAT,EAAsBC,SAAtB,EAAiCC,MAAjC,EAAyCC,QAAzC,QAAyD,OAAzD;AA+CA;;;;;;;;AAOA,OAAM,SAAUC,cAAV,CAAgDC,EAAhD,EAMkB;MALtBC,MAAM;MACNC,OAAO;MACPC,QAAQ;MACRC,KAAK;MACLC,YAAY;;EAEN,gBAAwBP,QAAQ,CAAC,KAAD,CAAhC,EAAuC,CAAvC;EAAA,IAACQ,OAAO,QAAR;EAAA,IAAUC,UAAU,QAApB;;EACA,gBAAsBT,QAAQ,CAAC;IACnC,IAAI,OAAOM,KAAP,KAAiB,WAArB,EAAkC;MAChC,OAAO,OAAOC,YAAP,KAAwB,WAAxB,IAAuCA,YAAY,CAACG,MAAb,GAAsB,CAApE;IACD;;IAED,OAAOJ,KAAK,CAACI,MAAN,GAAe,CAAtB;EACD,CANmC,CAA9B,EAMJ,CANI;EAAA,IAACC,MAAM,QAAP;EAAA,IAASC,SAAS,QAAlB;;EAQN,IAAMC,UAAU,GAAGhB,WAAW,CAC5B,UAACiB,KAAD,EAAqB;IACnB,IAAIX,MAAJ,EAAY;MACVA,MAAM,CAACW,KAAD,CAAN;IACD;;IAEDL,UAAU,CAAC,KAAD,CAAV;IACA,IAAMM,KAAK,GAAGD,KAAK,CAACE,aAApB;;IACA,IAAID,KAAK,CAACE,YAAN,CAAmB,MAAnB,MAA+B,QAAnC,EAA6C;MAC3CF,KAAK,CAACG,aAAN;MACAN,SAAS,CAACG,KAAK,CAACI,QAAN,CAAeC,QAAf,IAA2B,CAACd,KAAK,SAAL,SAAK,WAAL,WAASS,KAAK,CAACT,KAAhB,EAAuBI,MAAvB,GAAgC,CAA5D,CAAT;IACD;EACF,CAZ2B,EAa5B,CAACP,MAAD,EAASG,KAAT,CAb4B,CAA9B;EAgBA,IAAMe,WAAW,GAAGxB,WAAW,CAC7B,UAACiB,KAAD,EAAqB;IACnB,IAAIV,OAAJ,EAAa;MACXA,OAAO,CAACU,KAAD,CAAP;IACD;;IAEDL,UAAU,CAAC,IAAD,CAAV;EACD,CAP4B,EAQ7B,CAACL,OAAD,CAR6B,CAA/B;EAWA,IAAMkB,YAAY,GAAGzB,WAAW,CAC9B,UAACiB,KAAD,EAAsB;IACpB,IAAIT,QAAJ,EAAc;MACZA,QAAQ,CAACS,KAAD,CAAR;IACD;;IAED,IAAMC,KAAK,GAAGD,KAAK,CAACE,aAApB;;IACA,IAAID,KAAK,CAACE,YAAN,CAAmB,MAAnB,MAA+B,QAAnC,EAA6C;MAC3CF,KAAK,CAACG,aAAN;MACA;;MACA,IAAIH,KAAK,CAACI,QAAN,CAAeC,QAAnB,EAA6B;QAC3B;MACD;IACF;;IAEDR,SAAS,CAACG,KAAK,CAACT,KAAN,CAAYI,MAAZ,GAAqB,CAAtB,CAAT;EACD,CAhB6B,EAiB9B,CAACL,QAAD,CAjB8B,CAAhC,CArCsB,CAyDtB;EACA;EACA;EACA;EACA;;EACA,IAAMkB,SAAS,GAAGxB,MAAM,CAACO,KAAD,CAAxB;EACAR,SAAS,CAAC;IACR,IAAIyB,SAAS,CAACC,OAAV,KAAsBlB,KAAtB,IAA+B,OAAOA,KAAP,KAAiB,QAApD,EAA8D;MAC5DiB,SAAS,CAACC,OAAV,GAAoBlB,KAApB;MACAM,SAAS,CAACN,KAAK,CAACI,MAAN,GAAe,CAAhB,CAAT;IACD;EACF,CALQ,EAKN,CAACJ,KAAD,CALM,CAAT;EAOA,OAAO;IACLK,MAAM,QADD;IAELH,OAAO,SAFF;IAGLL,MAAM,EAAEU,UAHH;IAILT,OAAO,EAAEiB,WAJJ;IAKLhB,QAAQ,EAAEiB;EALL,CAAP;AAOD","names":["useCallback","useEffect","useRef","useState","useFieldStates","_a","onBlur","onFocus","onChange","value","defaultValue","focused","setFocused","length","valued","setValued","handleBlur","event","input","currentTarget","getAttribute","checkValidity","validity","badInput","handleFocus","handleChange","prevValue","current"],"sources":["C:\\Users\\hungr\\Documents\\VS-CODE\\notes-react\\node_modules\\@react-md\\form\\src\\useFieldStates.ts"],"sourcesContent":["import type {\n  ChangeEvent,\n  ChangeEventHandler,\n  FocusEvent,\n  FocusEventHandler,\n} from \"react\";\nimport { useCallback, useEffect, useRef, useState } from \"react\";\n\n/**\n * @internal\n * @remarks \\@since 2.5.2\n */\ntype FormElement = HTMLInputElement | HTMLTextAreaElement | HTMLSelectElement;\n\n/**\n * @internal\n * @remarks \\@since 2.5.2\n */\ninterface EventHandlers<E extends FormElement> {\n  onBlur?: FocusEventHandler<E>;\n  onFocus?: FocusEventHandler<E>;\n  onChange?: ChangeEventHandler<E>;\n}\n\n/**\n * @internal\n * @remarks \\@since 2.5.2\n */\ninterface FieldStatesOptions<E extends FormElement> extends EventHandlers<E> {\n  value?: string | readonly string[];\n  defaultValue?: string | readonly string[];\n}\n\n/**\n * @internal\n * @remarks \\@since 2.5.2\n */\ninterface ReturnValue<E extends FormElement>\n  extends Required<EventHandlers<E>> {\n  /**\n   * Boolean if the TextField or TextArea current has a value with a `length > 0`\n   * so that any labels will correctly float above the text field. This will\n   * also make sure that number inputs will still be considered valued when\n   * there is a `badInput` validity error.\n   */\n  valued: boolean;\n\n  /**\n   * Boolean if the TextField or TextArea currently has focus.\n   */\n  focused: boolean;\n}\n\n/**\n * This hook is used to handle the different states for the text field based on\n * the current value and user interaction.\n *\n * @internal\n * @remarks \\@since 2.5.2\n */\nexport function useFieldStates<E extends FormElement>({\n  onBlur,\n  onFocus,\n  onChange,\n  value,\n  defaultValue,\n}: FieldStatesOptions<E>): ReturnValue<E> {\n  const [focused, setFocused] = useState(false);\n  const [valued, setValued] = useState(() => {\n    if (typeof value === \"undefined\") {\n      return typeof defaultValue !== \"undefined\" && defaultValue.length > 0;\n    }\n\n    return value.length > 0;\n  });\n\n  const handleBlur = useCallback(\n    (event: FocusEvent<E>) => {\n      if (onBlur) {\n        onBlur(event);\n      }\n\n      setFocused(false);\n      const input = event.currentTarget;\n      if (input.getAttribute(\"type\") === \"number\") {\n        input.checkValidity();\n        setValued(input.validity.badInput || (value ?? input.value).length > 0);\n      }\n    },\n    [onBlur, value]\n  );\n\n  const handleFocus = useCallback(\n    (event: FocusEvent<E>) => {\n      if (onFocus) {\n        onFocus(event);\n      }\n\n      setFocused(true);\n    },\n    [onFocus]\n  );\n\n  const handleChange = useCallback(\n    (event: ChangeEvent<E>) => {\n      if (onChange) {\n        onChange(event);\n      }\n\n      const input = event.currentTarget;\n      if (input.getAttribute(\"type\") === \"number\") {\n        input.checkValidity();\n        /* istanbul ignore next */\n        if (input.validity.badInput) {\n          return;\n        }\n      }\n\n      setValued(input.value.length > 0);\n    },\n    [onChange]\n  );\n\n  // another way to handle this could be to just make the `valued` state derived\n  // based on the `value`, but it gets wonky for number fields. This technically\n  // still fails right now for number fields if you don't use the\n  // `useNumberField` hook since the `value` will be set back to the empty\n  // string on invalid numbers.\n  const prevValue = useRef(value);\n  useEffect(() => {\n    if (prevValue.current !== value && typeof value === \"string\") {\n      prevValue.current = value;\n      setValued(value.length > 0);\n    }\n  }, [value]);\n\n  return {\n    valued,\n    focused,\n    onBlur: handleBlur,\n    onFocus: handleFocus,\n    onChange: handleChange,\n  };\n}\n"]},"metadata":{},"sourceType":"module"}