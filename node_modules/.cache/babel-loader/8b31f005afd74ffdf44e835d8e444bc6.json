{"ast":null,"code":"var __read = this && this.__read || function (o, n) {\n  var m = typeof Symbol === \"function\" && o[Symbol.iterator];\n  if (!m) return o;\n  var i = m.call(o),\n      r,\n      ar = [],\n      e;\n\n  try {\n    while ((n === void 0 || n-- > 0) && !(r = i.next()).done) ar.push(r.value);\n  } catch (error) {\n    e = {\n      error: error\n    };\n  } finally {\n    try {\n      if (r && !r.done && (m = i[\"return\"])) m.call(i);\n    } finally {\n      if (e) throw e.error;\n    }\n  }\n\n  return ar;\n};\n\nimport { hexToRGB } from \"./hexToRGB\";\nvar RED_MULTIPLIER = 0.2126;\nvar GREEN_MULTIPLIER = 0.7152;\nvar BLUE_MULTIPLIER = 0.0722;\n/**\n * I really couldn't figure out how to name these \"magic\" numbers since the\n * formula doesn't really describe it much:\n *\n * @see https://www.w3.org/TR/WCAG20-TECHS/G17.html#G17-tests\n * @internal\n */\n\nfunction get8BitColor(color) {\n  color /= 255;\n\n  if (color <= 0.03928) {\n    return color / 12.92;\n  }\n\n  return Math.pow((color + 0.055) / 1.055, 2.4);\n}\n/**\n * A number closest to 0 should be closest to black while a number closest to 1\n * should be closest to white.\n *\n * @see https://www.w3.org/TR/WCAG20-TECHS/G17.html#G17-tests\n * @internal\n */\n\n\nexport function getLuminance(color) {\n  var _a = __read(hexToRGB(color), 3),\n      r = _a[0],\n      g = _a[1],\n      b = _a[2];\n\n  var red = get8BitColor(r) * RED_MULTIPLIER;\n  var green = get8BitColor(g) * GREEN_MULTIPLIER;\n  var blue = get8BitColor(b) * BLUE_MULTIPLIER;\n  return red + green + blue;\n}","map":{"version":3,"mappings":";;;;;;;;;;;;;;;;;;;;;;;;;AACA,SAASA,QAAT,QAAyB,YAAzB;AAEA,IAAMC,cAAc,GAAG,MAAvB;AACA,IAAMC,gBAAgB,GAAG,MAAzB;AACA,IAAMC,eAAe,GAAG,MAAxB;AAEA;;;;;;;;AAOA,SAASC,YAAT,CAAsBC,KAAtB,EAAmC;EACjCA,KAAK,IAAI,GAAT;;EAEA,IAAIA,KAAK,IAAI,OAAb,EAAsB;IACpB,OAAOA,KAAK,GAAG,KAAf;EACD;;EAED,OAAOC,SAAC,CAACD,KAAK,GAAG,KAAT,IAAkB,KAAnB,EAA6B,GAA7B,CAAP;AACD;AAED;;;;;;;;;AAOA,OAAM,SAAUE,YAAV,CAAuBF,KAAvB,EAAuC;EACrC,gBAAYL,QAAQ,CAACK,KAAD,CAApB,EAA2B,CAA3B;EAAA,IAACG,CAAC,QAAF;EAAA,IAAIC,CAAC,QAAL;EAAA,IAAOC,CAAC,QAAR;;EAEN,IAAMC,GAAG,GAAGP,YAAY,CAACI,CAAD,CAAZ,GAAkBP,cAA9B;EACA,IAAMW,KAAK,GAAGR,YAAY,CAACK,CAAD,CAAZ,GAAkBP,gBAAhC;EACA,IAAMW,IAAI,GAAGT,YAAY,CAACM,CAAD,CAAZ,GAAkBP,eAA/B;EAEA,OAAOQ,GAAG,GAAGC,KAAN,GAAcC,IAArB;AACD","names":["hexToRGB","RED_MULTIPLIER","GREEN_MULTIPLIER","BLUE_MULTIPLIER","get8BitColor","color","Math","getLuminance","r","g","b","red","green","blue"],"sources":["C:\\Users\\hungr\\Documents\\VS-CODE\\notes-react\\node_modules\\@react-md\\utils\\src\\colors\\getLuminance.ts"],"sourcesContent":["import type { HexString } from \"./hexToRGB\";\nimport { hexToRGB } from \"./hexToRGB\";\n\nconst RED_MULTIPLIER = 0.2126;\nconst GREEN_MULTIPLIER = 0.7152;\nconst BLUE_MULTIPLIER = 0.0722;\n\n/**\n * I really couldn't figure out how to name these \"magic\" numbers since the\n * formula doesn't really describe it much:\n *\n * @see https://www.w3.org/TR/WCAG20-TECHS/G17.html#G17-tests\n * @internal\n */\nfunction get8BitColor(color: number): number {\n  color /= 255;\n\n  if (color <= 0.03928) {\n    return color / 12.92;\n  }\n\n  return ((color + 0.055) / 1.055) ** 2.4;\n}\n\n/**\n * A number closest to 0 should be closest to black while a number closest to 1\n * should be closest to white.\n *\n * @see https://www.w3.org/TR/WCAG20-TECHS/G17.html#G17-tests\n * @internal\n */\nexport function getLuminance(color: HexString): number {\n  const [r, g, b] = hexToRGB(color);\n\n  const red = get8BitColor(r) * RED_MULTIPLIER;\n  const green = get8BitColor(g) * GREEN_MULTIPLIER;\n  const blue = get8BitColor(b) * BLUE_MULTIPLIER;\n\n  return red + green + blue;\n}\n"]},"metadata":{},"sourceType":"module"}