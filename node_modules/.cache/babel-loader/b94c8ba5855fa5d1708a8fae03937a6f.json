{"ast":null,"code":"var __read = this && this.__read || function (o, n) {\n  var m = typeof Symbol === \"function\" && o[Symbol.iterator];\n  if (!m) return o;\n  var i = m.call(o),\n      r,\n      ar = [],\n      e;\n\n  try {\n    while ((n === void 0 || n-- > 0) && !(r = i.next()).done) ar.push(r.value);\n  } catch (error) {\n    e = {\n      error: error\n    };\n  } finally {\n    try {\n      if (r && !r.done && (m = i[\"return\"])) m.call(i);\n    } finally {\n      if (e) throw e.error;\n    }\n  }\n\n  return ar;\n};\n\nimport { useCallback, useEffect, useRef, useState } from \"react\";\nimport { useUserInteractionMode } from \"../mode\";\nimport { useOnUnmount } from \"../useOnUnmount\";\nimport { DEFAULT_HOVER_MODE_EXIT_TIME } from \"./constants\";\nimport { useHoverModeContext } from \"./useHoverModeContext\";\n/**\n * This hook is used to add the hover mode functionality to any component.\n *\n * @example\n * Displaying a Color Preview when hovering a Hex Code\n * ```tsx\n * import type { ReactElement } from \"react\";\n * import { CSSTransition } from \"@react-md/transition\";\n * import { useHoverMode } from \"@react-md/utils\";\n *\n * interface Props {\n *   value: string;\n * }\n *\n * export default function Color({ value }: Props): ReactElement {\n *   const { visible, onMouseEnter, onMouseLeave } =\n *     useHoverMode({ exitVisibilityDelay: 0 });\n *\n *   return (\n *     <>\n *       <span\n *         onMouseEnter={onMouseEnter}\n *         onMouseLeave={onMouseLeave}\n *         style={{\n *           // pretend styles\n *         }}\n *       >\n *         {value}\n *       </span>\n *       <CSSTransition\n *         transitionIn={visible}\n *         classNames=\"opacity-change\"\n *         timeout={150}\n *         temporary\n *       >\n *         <span\n *           style={{\n *             backgroundColor: value,\n *             // other styles\n *           }}\n *         />\n *      </CSSTransition>\n *     </>\n *   );\n * }\n * ```\n *\n * @example\n * Sticky Usage with a Fixed Dialog\n * ```tsx\n * const {\n *   stuck,\n *   active,\n *   visible,\n *   setVisible,\n *   handlers,\n *   hoverHandlers,\n * } = useHoverMode();\n * const buttonRef = useRef<HTMLButtonElement>(null);\n *\n * return (\n *   <>\n *     <Button {...handlers} ref={buttonRef}>\n *       Click Me\n *     </Button>\n *     <FixedDialog\n *       {...hoverHandlers}\n *       aria-labelledby=\"dialog-title-id\"\n *       id=\"dialog-id\"\n *       visible={visible}\n *       onRequestClose={() => setVisible(false)}\n *       fixedTo={buttonRef}\n *       anchor={BELOW_CENTER_ANCHOR}\n *       options={{ preventOverlap: true }}\n *       // this allows the close on outside click\"\" behavior\" to work\n *       overlay={!stuck && active ? false : undefined}\n *       disableScrollLock={active}\n *     >\n *       <YourDialogContent />\n *    </FixedDialog>\n *   </>\n * );\n * ```\n *\n * @remarks \\@since 2.8.0\n * @remarks \\@since 5.0.0 This hook no longer returns `handlers` or\n * `stickyHandlers` and does not hide when an element on the page is clicked.\n * @param options - An optional object of options to use. See\n * {@link HoverModeOptions} for more details.\n * @returns either the {@link HoverModeReturnValue} or {@link HoverModeReturnValue}\n */\n\nexport function useHoverMode(_a) {\n  var _b = _a === void 0 ? {} : _a,\n      _c = _b.disabled,\n      disabled = _c === void 0 ? false : _c,\n      _d = _b.defaultVisible,\n      defaultVisible = _d === void 0 ? false : _d,\n      _e = _b.exitVisibilityDelay,\n      exitVisibilityDelay = _e === void 0 ? DEFAULT_HOVER_MODE_EXIT_TIME : _e;\n\n  var mode = useUserInteractionMode();\n  var isTouch = mode === \"touch\";\n\n  var _f = __read(useState(defaultVisible), 2),\n      visible = _f[0],\n      setVisible = _f[1];\n\n  var _g = __read(useState(false), 2),\n      stuck = _g[0],\n      setStuck = _g[1];\n\n  var timeoutRef = useRef();\n\n  var _h = useHoverModeContext(),\n      visibleInTime = _h.visibleInTime,\n      enableHoverMode = _h.enableHoverMode,\n      disableHoverMode = _h.disableHoverMode,\n      startDisableTimer = _h.startDisableTimer;\n\n  var active = visibleInTime === 0;\n  useEffect(function () {\n    if (!visible) {\n      setStuck(false);\n    }\n  }, [visible]);\n  useOnUnmount(function () {\n    window.clearTimeout(timeoutRef.current);\n  });\n  var clearHoverTimeout = useCallback(function () {\n    window.clearTimeout(timeoutRef.current);\n  }, []);\n  var onMouseEnter = useCallback(function (event) {\n    if (stuck || disabled || isTouch || event.isPropagationStopped()) {\n      return;\n    }\n\n    clearHoverTimeout();\n\n    if (visibleInTime === 0) {\n      enableHoverMode();\n      setVisible(true);\n      return;\n    }\n\n    timeoutRef.current = window.setTimeout(function () {\n      enableHoverMode();\n      setVisible(true);\n    }, visibleInTime);\n  }, [clearHoverTimeout, disabled, enableHoverMode, isTouch, stuck, visibleInTime]);\n  var onMouseLeave = useCallback(function (event) {\n    if (stuck || disabled || isTouch || event.isPropagationStopped()) {\n      return;\n    }\n\n    startDisableTimer();\n    clearHoverTimeout();\n\n    if (exitVisibilityDelay === 0) {\n      setVisible(false);\n      return;\n    }\n\n    timeoutRef.current = window.setTimeout(function () {\n      setVisible(false);\n    }, exitVisibilityDelay);\n  }, [clearHoverTimeout, disabled, exitVisibilityDelay, isTouch, startDisableTimer, stuck]);\n  var onClick = useCallback(function (event) {\n    if (event.isPropagationStopped()) {\n      return;\n    } // If the hover mode functionality is disabled, just allow this to behave\n    // like a toggle visibility handler.\n\n\n    if (!stuck && !disabled) {\n      setStuck(true);\n      setVisible(true);\n    } else {\n      setStuck(false);\n      setVisible(function (prevVisible) {\n        return !prevVisible;\n      });\n    }\n  }, [disabled, stuck]);\n  return {\n    active: active,\n    stuck: stuck,\n    visible: visible,\n    setVisible: setVisible,\n    onClick: onClick,\n    onMouseEnter: onMouseEnter,\n    onMouseLeave: onMouseLeave,\n    enableHoverMode: enableHoverMode,\n    disableHoverMode: disableHoverMode,\n    startDisableTimer: startDisableTimer,\n    clearHoverTimeout: clearHoverTimeout,\n    handlers: {\n      onClick: onClick,\n      onMouseEnter: onMouseEnter,\n      onMouseLeave: onMouseLeave\n    },\n    hoverHandlers: {\n      onMouseEnter: onMouseEnter,\n      onMouseLeave: onMouseLeave\n    }\n  };\n}","map":{"version":3,"mappings":"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","names":["useCallback","useEffect","useRef","useState","useUserInteractionMode","useOnUnmount","DEFAULT_HOVER_MODE_EXIT_TIME","useHoverModeContext","useHoverMode","_a","_b","_c","disabled","_d","defaultVisible","_e","exitVisibilityDelay","mode","isTouch","visible","setVisible","stuck","setStuck","timeoutRef","visibleInTime","enableHoverMode","disableHoverMode","startDisableTimer","active","window","clearTimeout","current","clearHoverTimeout","onMouseEnter","event","isPropagationStopped","setTimeout","onMouseLeave","onClick","prevVisible","handlers","hoverHandlers"],"sources":["C:\\Users\\hungr\\Documents\\VS-CODE\\notes-react\\node_modules\\@react-md\\utils\\src\\hover\\useHoverMode.ts"],"sourcesContent":["import type { Dispatch, MouseEvent, SetStateAction } from \"react\";\nimport { useCallback, useEffect, useRef, useState } from \"react\";\n\nimport { useUserInteractionMode } from \"../mode\";\nimport { useOnUnmount } from \"../useOnUnmount\";\nimport { DEFAULT_HOVER_MODE_EXIT_TIME } from \"./constants\";\nimport type { HoverModeActions } from \"./useHoverModeContext\";\nimport { useHoverModeContext } from \"./useHoverModeContext\";\n\n/** @remarks \\@since 5.0.0 */\nexport interface HoverModeHoverEventHandlers {\n  /**\n   * An optional event handler to merge with the hover mode visibility handler.\n   * If this function calls `event.stopPropagation()`, the hover mode behavior\n   * will be disabled.\n   */\n  onMouseEnter<E extends HTMLElement>(event: MouseEvent<E>): void;\n\n  /**\n   * An optional event handler to merge with the hover mode visibility handler.\n   * If this function calls `event.stopPropagation()`, the hover mode behavior\n   * will be disabled.\n   */\n  onMouseLeave<E extends HTMLElement>(event: MouseEvent<E>): void;\n}\n\n/**\n * An object of event handlers that should be provided to a component to enable\n * and disable the visibility of a temporary element while hovering over that\n * component.\n *\n * @remarks \\@since 2.8.0\n * @remarks \\@since 5.0.0 The `HTMLElement` type will be correctly inferred when\n * using them on multiple components.\n */\nexport interface HoverModeEventHandlers extends HoverModeHoverEventHandlers {\n  /**\n   * An optional event handler to merge with the hover mode visibility handler.\n   * If this function calls `event.stopPropagation()`, the hover mode behavior\n   * will be disabled.\n   */\n  onClick<E extends HTMLElement>(event: MouseEvent<E>): void;\n}\n\n/**\n * @remarks \\@since 2.8.0\n * @remarks \\@since 5.0.0 No longer has event handlers or a separate \"sticky\" API.\n */\nexport interface HoverModeOptions {\n  /**\n   * Boolean if the hover mode functionality should be disabled.\n   *\n   * @defaultValue `false`\n   */\n  disabled?: boolean;\n\n  /**\n   * Boolean if the element should start visible.\n   *\n   * @defaultValue `false`\n   */\n  defaultVisible?: boolean;\n\n  /**\n   * The amount of time to wait once the mouse has left the element before\n   * setting the visibility to `false`.\n   *\n   * @defaultValue {@link DEFAULT_HOVER_MODE_EXIT_TIME}\n   */\n  exitVisibilityDelay?: number;\n}\n\n/**\n * @remarks \\@since 5.0.0\n */\nexport interface HoverModeHookReturnValue\n  extends HoverModeActions,\n    HoverModeEventHandlers {\n  /**\n   * Boolean if the hover mode is currently working.\n   */\n  active: boolean;\n\n  /**\n   * Boolean if the the `visible` state is `true` because the user clicked an\n   * element.\n   */\n  stuck: boolean;\n\n  /**\n   * Boolean if the temporary element should be visible.\n   */\n  visible: boolean;\n\n  /**\n   * A function to manually set the visibility state if you need even more\n   * custom behavior.\n   */\n  setVisible: Dispatch<SetStateAction<boolean>>;\n\n  /**\n   * A convenience prop that allows you to spread all the hover mode event\n   * handlers onto a single component if no custom functionality is required.\n   *\n   * @remarks \\@since 5.0.0\n   */\n  handlers: Readonly<HoverModeEventHandlers>;\n\n  /**\n   * A convenience prop that allows you to spread only the `onMouseEnter` and\n   * `onMouseLeave` the hover mode event handlers onto a single component if no\n   * custom functionality is required.\n   *\n   * @remarks \\@since 5.0.0\n   */\n  hoverHandlers: Readonly<HoverModeHoverEventHandlers>;\n\n  /**\n   * Clears the current `onMouseEnter` visibility timer.\n   *\n   * @remarks \\@since 5.0.0\n   */\n  clearHoverTimeout(): void;\n}\n\n/**\n * This hook is used to add the hover mode functionality to any component.\n *\n * @example\n * Displaying a Color Preview when hovering a Hex Code\n * ```tsx\n * import type { ReactElement } from \"react\";\n * import { CSSTransition } from \"@react-md/transition\";\n * import { useHoverMode } from \"@react-md/utils\";\n *\n * interface Props {\n *   value: string;\n * }\n *\n * export default function Color({ value }: Props): ReactElement {\n *   const { visible, onMouseEnter, onMouseLeave } =\n *     useHoverMode({ exitVisibilityDelay: 0 });\n *\n *   return (\n *     <>\n *       <span\n *         onMouseEnter={onMouseEnter}\n *         onMouseLeave={onMouseLeave}\n *         style={{\n *           // pretend styles\n *         }}\n *       >\n *         {value}\n *       </span>\n *       <CSSTransition\n *         transitionIn={visible}\n *         classNames=\"opacity-change\"\n *         timeout={150}\n *         temporary\n *       >\n *         <span\n *           style={{\n *             backgroundColor: value,\n *             // other styles\n *           }}\n *         />\n *      </CSSTransition>\n *     </>\n *   );\n * }\n * ```\n *\n * @example\n * Sticky Usage with a Fixed Dialog\n * ```tsx\n * const {\n *   stuck,\n *   active,\n *   visible,\n *   setVisible,\n *   handlers,\n *   hoverHandlers,\n * } = useHoverMode();\n * const buttonRef = useRef<HTMLButtonElement>(null);\n *\n * return (\n *   <>\n *     <Button {...handlers} ref={buttonRef}>\n *       Click Me\n *     </Button>\n *     <FixedDialog\n *       {...hoverHandlers}\n *       aria-labelledby=\"dialog-title-id\"\n *       id=\"dialog-id\"\n *       visible={visible}\n *       onRequestClose={() => setVisible(false)}\n *       fixedTo={buttonRef}\n *       anchor={BELOW_CENTER_ANCHOR}\n *       options={{ preventOverlap: true }}\n *       // this allows the close on outside click\"\" behavior\" to work\n *       overlay={!stuck && active ? false : undefined}\n *       disableScrollLock={active}\n *     >\n *       <YourDialogContent />\n *    </FixedDialog>\n *   </>\n * );\n * ```\n *\n * @remarks \\@since 2.8.0\n * @remarks \\@since 5.0.0 This hook no longer returns `handlers` or\n * `stickyHandlers` and does not hide when an element on the page is clicked.\n * @param options - An optional object of options to use. See\n * {@link HoverModeOptions} for more details.\n * @returns either the {@link HoverModeReturnValue} or {@link HoverModeReturnValue}\n */\nexport function useHoverMode({\n  disabled = false,\n  defaultVisible = false,\n  exitVisibilityDelay = DEFAULT_HOVER_MODE_EXIT_TIME,\n}: HoverModeOptions = {}): HoverModeHookReturnValue {\n  const mode = useUserInteractionMode();\n  const isTouch = mode === \"touch\";\n  const [visible, setVisible] = useState(defaultVisible);\n  const [stuck, setStuck] = useState(false);\n  const timeoutRef = useRef<number>();\n  const {\n    visibleInTime,\n    enableHoverMode,\n    disableHoverMode,\n    startDisableTimer,\n  } = useHoverModeContext();\n  const active = visibleInTime === 0;\n\n  useEffect(() => {\n    if (!visible) {\n      setStuck(false);\n    }\n  }, [visible]);\n\n  useOnUnmount(() => {\n    window.clearTimeout(timeoutRef.current);\n  });\n\n  const clearHoverTimeout = useCallback(() => {\n    window.clearTimeout(timeoutRef.current);\n  }, []);\n\n  const onMouseEnter = useCallback(\n    <E extends HTMLElement>(event: MouseEvent<E>) => {\n      if (stuck || disabled || isTouch || event.isPropagationStopped()) {\n        return;\n      }\n\n      clearHoverTimeout();\n      if (visibleInTime === 0) {\n        enableHoverMode();\n        setVisible(true);\n        return;\n      }\n\n      timeoutRef.current = window.setTimeout(() => {\n        enableHoverMode();\n        setVisible(true);\n      }, visibleInTime);\n    },\n    [\n      clearHoverTimeout,\n      disabled,\n      enableHoverMode,\n      isTouch,\n      stuck,\n      visibleInTime,\n    ]\n  );\n\n  const onMouseLeave = useCallback(\n    <E extends HTMLElement>(event: MouseEvent<E>) => {\n      if (stuck || disabled || isTouch || event.isPropagationStopped()) {\n        return;\n      }\n\n      startDisableTimer();\n      clearHoverTimeout();\n      if (exitVisibilityDelay === 0) {\n        setVisible(false);\n        return;\n      }\n\n      timeoutRef.current = window.setTimeout(() => {\n        setVisible(false);\n      }, exitVisibilityDelay);\n    },\n    [\n      clearHoverTimeout,\n      disabled,\n      exitVisibilityDelay,\n      isTouch,\n      startDisableTimer,\n      stuck,\n    ]\n  );\n\n  const onClick = useCallback(\n    <E extends HTMLElement>(event: MouseEvent<E>) => {\n      if (event.isPropagationStopped()) {\n        return;\n      }\n\n      // If the hover mode functionality is disabled, just allow this to behave\n      // like a toggle visibility handler.\n      if (!stuck && !disabled) {\n        setStuck(true);\n        setVisible(true);\n      } else {\n        setStuck(false);\n        setVisible((prevVisible) => !prevVisible);\n      }\n    },\n    [disabled, stuck]\n  );\n\n  return {\n    active,\n    stuck,\n    visible,\n    setVisible,\n    onClick,\n    onMouseEnter,\n    onMouseLeave,\n    enableHoverMode,\n    disableHoverMode,\n    startDisableTimer,\n    clearHoverTimeout,\n    handlers: {\n      onClick,\n      onMouseEnter,\n      onMouseLeave,\n    },\n    hoverHandlers: {\n      onMouseEnter,\n      onMouseLeave,\n    },\n  };\n}\n"]},"metadata":{},"sourceType":"module"}