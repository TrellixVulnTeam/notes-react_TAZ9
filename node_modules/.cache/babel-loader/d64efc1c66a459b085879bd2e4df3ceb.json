{"ast":null,"code":"/**\n * Creates the `left` style value for an element that should be fixed to the\n * (outer) left of the container element. So the right bounds of the fixed\n * element will be equal to the left bounds of the container element (before the\n * xMargin is applied).\n * @internal\n */\nexport function getLeftCoord(_a) {\n  var xMargin = _a.xMargin,\n      elWidth = _a.elWidth,\n      initialX = _a.initialX,\n      containerRect = _a.containerRect;\n  return (initialX !== null && initialX !== void 0 ? initialX : containerRect.left) - elWidth - xMargin;\n}\n/**\n * Creates the `left` style value for an element that should be fixed to the\n * inner-left of the container element. So the left bounds of both the container\n * and fixed elements will overlap (before the xMargin is applied)\n * @internal\n */\n\nexport function getInnerLeftCoord(_a) {\n  var xMargin = _a.xMargin,\n      initialX = _a.initialX,\n      containerRect = _a.containerRect;\n  return (initialX !== null && initialX !== void 0 ? initialX : containerRect.left) + xMargin;\n}\n/**\n * Creates the `left` style value for an element that should be fixed to the\n * center of the container element. So the center point of the fixed element\n * should be the center point of the container element.\n *\n * Note: Unlike all the other horizontal positioning logic, the center position\n * does not use the xMargin.\n * @internal\n */\n\nexport function getCenterXCoord(_a) {\n  var elWidth = _a.elWidth,\n      initialX = _a.initialX,\n      containerRect = _a.containerRect;\n  var containerCenter = containerRect.width / 2;\n  var elementCenter = elWidth / 2;\n  return (initialX !== null && initialX !== void 0 ? initialX : containerRect.left + containerCenter) - elementCenter;\n}\n/**\n * Creates the `left` style value for an element that should be fixed to the\n * inner-right of the container element. So the right bounds for both the\n * container and fixed elements will overlap (before the xMargin is applied).\n * @internal\n */\n\nexport function getInnerRightCoord(_a) {\n  var xMargin = _a.xMargin,\n      elWidth = _a.elWidth,\n      initialX = _a.initialX,\n      containerRect = _a.containerRect;\n  return (initialX !== null && initialX !== void 0 ? initialX : containerRect.left + containerRect.width) - elWidth - xMargin;\n}\n/**\n * Creates the `left` style value for an element that should be fixed to the\n * (outer) right of the container element. So the left bounds of the fixed\n * element will overlap with the right bounds of the container element (before\n * the xMargin is applied).\n * @internal\n */\n\nexport function getRightCoord(_a) {\n  var xMargin = _a.xMargin,\n      initialX = _a.initialX,\n      containerRect = _a.containerRect;\n  return (initialX !== null && initialX !== void 0 ? initialX : containerRect.left + containerRect.width) + xMargin;\n}\n/**\n * Creates the `top` style value for an element that should be fixed above the\n * container element. So the bottom bounds of the fixed element will overlap\n * with the top bounds of the container element (before the yMargin is applied).\n * @internal\n */\n\nexport function getAboveCoord(_a) {\n  var yMargin = _a.yMargin,\n      initialY = _a.initialY,\n      elHeight = _a.elHeight,\n      containerRect = _a.containerRect;\n  return (initialY !== null && initialY !== void 0 ? initialY : containerRect.top) - elHeight - yMargin;\n}\n/**\n * Creates the `top` style value for an element that should be fixed to the top\n * of the container element. So the top bounds for both the container and fixed\n * elements will overlap (before the yMargin is applied).\n * @internal\n */\n\nexport function getTopCoord(_a) {\n  var yMargin = _a.yMargin,\n      initialY = _a.initialY,\n      containerRect = _a.containerRect;\n  return (initialY !== null && initialY !== void 0 ? initialY : containerRect.top) + yMargin;\n}\n/**\n * Creates the `top` style value for an element that should be fixed vertically\n * centered relative to the container element. So the vertical center point for\n * the fixed element should overlap the vertical center point of the container\n * element.\n *\n * Note: Unlike all the other vertical positioning logic, the center position\n * does not use the yMargin.\n */\n\nexport function getCenterYCoord(_a) {\n  var elHeight = _a.elHeight,\n      initialY = _a.initialY,\n      containerRect = _a.containerRect;\n  var containerCenter = containerRect.height / 2;\n  var elementCenter = elHeight / 2;\n  return (initialY !== null && initialY !== void 0 ? initialY : containerRect.top + containerCenter) - elementCenter;\n}\n/**\n * Creates the `top` style value for an element that should be fixed to the\n * bottom of the container element. So the top bounds of the fixed element\n * should overlap the bottom bounds of the container element (before the yMargin\n * is applied).\n * @internal\n */\n\nexport function getBottomCoord(_a) {\n  var yMargin = _a.yMargin,\n      initialY = _a.initialY,\n      elHeight = _a.elHeight,\n      containerRect = _a.containerRect;\n  return (initialY !== null && initialY !== void 0 ? initialY : containerRect.top + containerRect.height) - elHeight - yMargin;\n}\n/**\n * Creates the `top` style value for an element that should be fixed to the\n * bottom of the container element. So the bottom bounds of both the container\n * and fixed elements should overlap (before the yMargin is applied).\n * @internal\n */\n\nexport function getBelowCoord(_a) {\n  var yMargin = _a.yMargin,\n      initialY = _a.initialY,\n      containerRect = _a.containerRect;\n  return (initialY !== null && initialY !== void 0 ? initialY : containerRect.top + containerRect.height) + yMargin;\n}","map":{"version":3,"mappings":"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","names":["getLeftCoord","_a","xMargin","elWidth","initialX","containerRect","left","getInnerLeftCoord","getCenterXCoord","containerCenter","width","elementCenter","getInnerRightCoord","getRightCoord","getAboveCoord","yMargin","initialY","elHeight","top","getTopCoord","getCenterYCoord","height","getBottomCoord","getBelowCoord"],"sources":["C:\\Users\\hungr\\Documents\\VS-CODE\\notes-react\\node_modules\\@react-md\\utils\\src\\positioning\\getCoord.ts"],"sourcesContent":["export interface XCoordConfig {\n  xMargin: number;\n  elWidth: number;\n  initialX?: number;\n  containerRect: DOMRect;\n}\n\nexport interface YCoordConfig {\n  yMargin: number;\n  elHeight: number;\n  initialY?: number;\n  containerRect: DOMRect;\n}\n\ntype Left = number;\ntype Top = number;\n\n/**\n * Creates the `left` style value for an element that should be fixed to the\n * (outer) left of the container element. So the right bounds of the fixed\n * element will be equal to the left bounds of the container element (before the\n * xMargin is applied).\n * @internal\n */\nexport function getLeftCoord({\n  xMargin,\n  elWidth,\n  initialX,\n  containerRect,\n}: XCoordConfig): Left {\n  return (initialX ?? containerRect.left) - elWidth - xMargin;\n}\n\n/**\n * Creates the `left` style value for an element that should be fixed to the\n * inner-left of the container element. So the left bounds of both the container\n * and fixed elements will overlap (before the xMargin is applied)\n * @internal\n */\nexport function getInnerLeftCoord({\n  xMargin,\n  initialX,\n  containerRect,\n}: XCoordConfig): Left {\n  return (initialX ?? containerRect.left) + xMargin;\n}\n\n/**\n * Creates the `left` style value for an element that should be fixed to the\n * center of the container element. So the center point of the fixed element\n * should be the center point of the container element.\n *\n * Note: Unlike all the other horizontal positioning logic, the center position\n * does not use the xMargin.\n * @internal\n */\nexport function getCenterXCoord({\n  elWidth,\n  initialX,\n  containerRect,\n}: XCoordConfig): Left {\n  const containerCenter = containerRect.width / 2;\n  const elementCenter = elWidth / 2;\n  return (initialX ?? containerRect.left + containerCenter) - elementCenter;\n}\n\n/**\n * Creates the `left` style value for an element that should be fixed to the\n * inner-right of the container element. So the right bounds for both the\n * container and fixed elements will overlap (before the xMargin is applied).\n * @internal\n */\nexport function getInnerRightCoord({\n  xMargin,\n  elWidth,\n  initialX,\n  containerRect,\n}: XCoordConfig): Left {\n  return (\n    (initialX ?? containerRect.left + containerRect.width) - elWidth - xMargin\n  );\n}\n\n/**\n * Creates the `left` style value for an element that should be fixed to the\n * (outer) right of the container element. So the left bounds of the fixed\n * element will overlap with the right bounds of the container element (before\n * the xMargin is applied).\n * @internal\n */\nexport function getRightCoord({\n  xMargin,\n  initialX,\n  containerRect,\n}: XCoordConfig): Left {\n  return (initialX ?? containerRect.left + containerRect.width) + xMargin;\n}\n\n/**\n * Creates the `top` style value for an element that should be fixed above the\n * container element. So the bottom bounds of the fixed element will overlap\n * with the top bounds of the container element (before the yMargin is applied).\n * @internal\n */\nexport function getAboveCoord({\n  yMargin,\n  initialY,\n  elHeight,\n  containerRect,\n}: YCoordConfig): Top {\n  return (initialY ?? containerRect.top) - elHeight - yMargin;\n}\n\n/**\n * Creates the `top` style value for an element that should be fixed to the top\n * of the container element. So the top bounds for both the container and fixed\n * elements will overlap (before the yMargin is applied).\n * @internal\n */\nexport function getTopCoord({\n  yMargin,\n  initialY,\n  containerRect,\n}: YCoordConfig): Top {\n  return (initialY ?? containerRect.top) + yMargin;\n}\n\n/**\n * Creates the `top` style value for an element that should be fixed vertically\n * centered relative to the container element. So the vertical center point for\n * the fixed element should overlap the vertical center point of the container\n * element.\n *\n * Note: Unlike all the other vertical positioning logic, the center position\n * does not use the yMargin.\n */\nexport function getCenterYCoord({\n  elHeight,\n  initialY,\n  containerRect,\n}: YCoordConfig): Top {\n  const containerCenter = containerRect.height / 2;\n  const elementCenter = elHeight / 2;\n  return (initialY ?? containerRect.top + containerCenter) - elementCenter;\n}\n\n/**\n * Creates the `top` style value for an element that should be fixed to the\n * bottom of the container element. So the top bounds of the fixed element\n * should overlap the bottom bounds of the container element (before the yMargin\n * is applied).\n * @internal\n */\nexport function getBottomCoord({\n  yMargin,\n  initialY,\n  elHeight,\n  containerRect,\n}: YCoordConfig): Top {\n  return (\n    (initialY ?? containerRect.top + containerRect.height) - elHeight - yMargin\n  );\n}\n\n/**\n * Creates the `top` style value for an element that should be fixed to the\n * bottom of the container element. So the bottom bounds of both the container\n * and fixed elements should overlap (before the yMargin is applied).\n * @internal\n */\nexport function getBelowCoord({\n  yMargin,\n  initialY,\n  containerRect,\n}: YCoordConfig): Top {\n  return (initialY ?? containerRect.top + containerRect.height) + yMargin;\n}\n"]},"metadata":{},"sourceType":"module"}