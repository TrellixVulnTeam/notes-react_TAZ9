{"ast":null,"code":"var __assign = this && this.__assign || function () {\n  __assign = Object.assign || function (t) {\n    for (var s, i = 1, n = arguments.length; i < n; i++) {\n      s = arguments[i];\n\n      for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p)) t[p] = s[p];\n    }\n\n    return t;\n  };\n\n  return __assign.apply(this, arguments);\n};\n\nvar __read = this && this.__read || function (o, n) {\n  var m = typeof Symbol === \"function\" && o[Symbol.iterator];\n  if (!m) return o;\n  var i = m.call(o),\n      r,\n      ar = [],\n      e;\n\n  try {\n    while ((n === void 0 || n-- > 0) && !(r = i.next()).done) ar.push(r.value);\n  } catch (error) {\n    e = {\n      error: error\n    };\n  } finally {\n    try {\n      if (r && !r.done && (m = i[\"return\"])) m.call(i);\n    } finally {\n      if (e) throw e.error;\n    }\n  }\n\n  return ar;\n};\n\nimport { useCallback, useState } from \"react\";\nimport { useRefCache } from \"@react-md/utils\";\nimport { isBubbled } from \"./ripples/utils\";\n/**\n * This is a different version of the useRippleStates that will allow you to\n * know when a component is being pressed by the user. This is really just a\n * fallback for when the ripples are disabled.\n *\n * This will return an object containing the current pressed state of the\n * element as well as all the merged eventHandlers required to trigger the\n * different states.\n *\n * NOTE: Unlike the ripple effect, this pressed states will not be triggered\n * from a programmatic click event.\n */\n\nexport function usePressedStates(_a) {\n  var _b = _a === void 0 ? {} : _a,\n      _c = _b.handlers,\n      handlers = _c === void 0 ? {} : _c,\n      _d = _b.disableSpacebarClick,\n      disableSpacebarClick = _d === void 0 ? false : _d;\n\n  var _e = __read(useState(false), 2),\n      pressed = _e[0],\n      setPressed = _e[1];\n\n  var ref = useRefCache(__assign(__assign({}, handlers), {\n    pressed: pressed\n  }));\n  var handleKeyDown = useCallback(function (event) {\n    var _a = ref.current,\n        onKeyDown = _a.onKeyDown,\n        pressed = _a.pressed;\n\n    if (onKeyDown) {\n      onKeyDown(event);\n    }\n\n    var key = event.key;\n\n    if (!pressed && (key === \"Enter\" || !disableSpacebarClick && key === \" \")) {\n      setPressed(true);\n    }\n  }, // disabled since useRefCache for ref\n  // eslint-disable-next-line react-hooks/exhaustive-deps\n  [disableSpacebarClick]);\n  var handleKeyUp = useCallback(function (event) {\n    var _a = ref.current,\n        onKeyUp = _a.onKeyUp,\n        pressed = _a.pressed;\n\n    if (onKeyUp) {\n      onKeyUp(event);\n    }\n\n    if (pressed) {\n      setPressed(false);\n    } // disabled since useRefCache for ref\n    // eslint-disable-next-line react-hooks/exhaustive-deps\n\n  }, []);\n  var handleMouseDown = useCallback(function (event) {\n    var _a = ref.current,\n        onMouseDown = _a.onMouseDown,\n        pressed = _a.pressed;\n\n    if (onMouseDown) {\n      onMouseDown(event);\n    }\n\n    if (!pressed && event.button === 0 && !isBubbled(event)) {\n      setPressed(true);\n    } // disabled since useRefCache for ref\n    // eslint-disable-next-line react-hooks/exhaustive-deps\n\n  }, []);\n  var handleMouseUp = useCallback(function (event) {\n    var _a = ref.current,\n        onMouseUp = _a.onMouseUp,\n        pressed = _a.pressed;\n\n    if (onMouseUp) {\n      onMouseUp(event);\n    }\n\n    if (pressed) {\n      setPressed(false);\n    } // disabled since useRefCache for ref\n    // eslint-disable-next-line react-hooks/exhaustive-deps\n\n  }, []);\n  var handleMouseLeave = useCallback(function (event) {\n    var _a = ref.current,\n        onMouseLeave = _a.onMouseLeave,\n        pressed = _a.pressed;\n\n    if (onMouseLeave) {\n      onMouseLeave(event);\n    }\n\n    if (pressed) {\n      setPressed(false);\n    } // disabled since useRefCache for ref\n    // eslint-disable-next-line react-hooks/exhaustive-deps\n\n  }, []);\n  var handleTouchStart = useCallback(function (event) {\n    var _a = ref.current,\n        onTouchStart = _a.onTouchStart,\n        pressed = _a.pressed;\n\n    if (onTouchStart) {\n      onTouchStart(event);\n    }\n\n    if (!pressed && !isBubbled(event)) {\n      setPressed(true);\n    } // disabled since useRefCache for ref\n    // eslint-disable-next-line react-hooks/exhaustive-deps\n\n  }, []);\n  var handleTouchMove = useCallback(function (event) {\n    var _a = ref.current,\n        onTouchMove = _a.onTouchMove,\n        pressed = _a.pressed;\n\n    if (onTouchMove) {\n      onTouchMove(event);\n    }\n\n    if (pressed) {\n      setPressed(false);\n    } // disabled since useRefCache for ref\n    // eslint-disable-next-line react-hooks/exhaustive-deps\n\n  }, []);\n  var handleTouchEnd = useCallback(function (event) {\n    var _a = ref.current,\n        onTouchEnd = _a.onTouchEnd,\n        pressed = _a.pressed;\n\n    if (onTouchEnd) {\n      onTouchEnd(event);\n    }\n\n    if (pressed) {\n      setPressed(false);\n    } // disabled since useRefCache for ref\n    // eslint-disable-next-line react-hooks/exhaustive-deps\n\n  }, []);\n  return {\n    pressed: pressed,\n    handlers: {\n      onClick: handlers.onClick,\n      onKeyDown: handleKeyDown,\n      onKeyUp: handleKeyUp,\n      onMouseDown: handleMouseDown,\n      onMouseUp: handleMouseUp,\n      onMouseLeave: handleMouseLeave,\n      onTouchStart: handleTouchStart,\n      onTouchMove: handleTouchMove,\n      onTouchEnd: handleTouchEnd\n    }\n  };\n}","map":{"version":3,"mappings":"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","names":["useCallback","useState","useRefCache","isBubbled","usePressedStates","_a","_b","_c","handlers","_d","disableSpacebarClick","pressed","setPressed","ref","handleKeyDown","event","current","onKeyDown","key","handleKeyUp","onKeyUp","handleMouseDown","onMouseDown","button","handleMouseUp","onMouseUp","handleMouseLeave","onMouseLeave","handleTouchStart","onTouchStart","handleTouchMove","onTouchMove","handleTouchEnd","onTouchEnd","onClick"],"sources":["C:\\Users\\hungr\\Documents\\VS-CODE\\notes-react\\node_modules\\@react-md\\states\\src\\usePressedStates.ts"],"sourcesContent":["import { useCallback, useState } from \"react\";\nimport { useRefCache } from \"@react-md/utils\";\n\nimport type { MergableRippleHandlers } from \"./ripples/types\";\nimport { isBubbled } from \"./ripples/utils\";\n\ninterface PressedStatesOptions<E extends HTMLElement = HTMLElement> {\n  handlers?: MergableRippleHandlers<E>;\n  disableSpacebarClick?: boolean;\n}\n\ninterface ReturnValue<E extends HTMLElement> {\n  pressed: boolean;\n  handlers: MergableRippleHandlers<E>;\n}\n\n/**\n * This is a different version of the useRippleStates that will allow you to\n * know when a component is being pressed by the user. This is really just a\n * fallback for when the ripples are disabled.\n *\n * This will return an object containing the current pressed state of the\n * element as well as all the merged eventHandlers required to trigger the\n * different states.\n *\n * NOTE: Unlike the ripple effect, this pressed states will not be triggered\n * from a programmatic click event.\n */\nexport function usePressedStates<E extends HTMLElement = HTMLElement>({\n  handlers = {},\n  disableSpacebarClick = false,\n}: PressedStatesOptions<E> = {}): ReturnValue<E> {\n  const [pressed, setPressed] = useState(false);\n  const ref = useRefCache({ ...handlers, pressed });\n\n  const handleKeyDown = useCallback(\n    (event: React.KeyboardEvent<E>) => {\n      const { onKeyDown, pressed } = ref.current;\n      if (onKeyDown) {\n        onKeyDown(event);\n      }\n\n      const { key } = event;\n      if (\n        !pressed &&\n        (key === \"Enter\" || (!disableSpacebarClick && key === \" \"))\n      ) {\n        setPressed(true);\n      }\n    },\n    // disabled since useRefCache for ref\n    // eslint-disable-next-line react-hooks/exhaustive-deps\n    [disableSpacebarClick]\n  );\n\n  const handleKeyUp = useCallback((event: React.KeyboardEvent<E>) => {\n    const { onKeyUp, pressed } = ref.current;\n    if (onKeyUp) {\n      onKeyUp(event);\n    }\n\n    if (pressed) {\n      setPressed(false);\n    }\n    // disabled since useRefCache for ref\n    // eslint-disable-next-line react-hooks/exhaustive-deps\n  }, []);\n\n  const handleMouseDown = useCallback((event: React.MouseEvent<E>) => {\n    const { onMouseDown, pressed } = ref.current;\n    if (onMouseDown) {\n      onMouseDown(event);\n    }\n\n    if (!pressed && event.button === 0 && !isBubbled(event)) {\n      setPressed(true);\n    }\n    // disabled since useRefCache for ref\n    // eslint-disable-next-line react-hooks/exhaustive-deps\n  }, []);\n\n  const handleMouseUp = useCallback((event: React.MouseEvent<E>) => {\n    const { onMouseUp, pressed } = ref.current;\n    if (onMouseUp) {\n      onMouseUp(event);\n    }\n\n    if (pressed) {\n      setPressed(false);\n    }\n    // disabled since useRefCache for ref\n    // eslint-disable-next-line react-hooks/exhaustive-deps\n  }, []);\n\n  const handleMouseLeave = useCallback((event: React.MouseEvent<E>) => {\n    const { onMouseLeave, pressed } = ref.current;\n    if (onMouseLeave) {\n      onMouseLeave(event);\n    }\n\n    if (pressed) {\n      setPressed(false);\n    }\n    // disabled since useRefCache for ref\n    // eslint-disable-next-line react-hooks/exhaustive-deps\n  }, []);\n\n  const handleTouchStart = useCallback((event: React.TouchEvent<E>) => {\n    const { onTouchStart, pressed } = ref.current;\n    if (onTouchStart) {\n      onTouchStart(event);\n    }\n\n    if (!pressed && !isBubbled(event)) {\n      setPressed(true);\n    }\n    // disabled since useRefCache for ref\n    // eslint-disable-next-line react-hooks/exhaustive-deps\n  }, []);\n\n  const handleTouchMove = useCallback((event: React.TouchEvent<E>) => {\n    const { onTouchMove, pressed } = ref.current;\n    if (onTouchMove) {\n      onTouchMove(event);\n    }\n\n    if (pressed) {\n      setPressed(false);\n    }\n    // disabled since useRefCache for ref\n    // eslint-disable-next-line react-hooks/exhaustive-deps\n  }, []);\n\n  const handleTouchEnd = useCallback((event: React.TouchEvent<E>) => {\n    const { onTouchEnd, pressed } = ref.current;\n    if (onTouchEnd) {\n      onTouchEnd(event);\n    }\n\n    if (pressed) {\n      setPressed(false);\n    }\n    // disabled since useRefCache for ref\n    // eslint-disable-next-line react-hooks/exhaustive-deps\n  }, []);\n\n  return {\n    pressed,\n    handlers: {\n      onClick: handlers.onClick,\n      onKeyDown: handleKeyDown,\n      onKeyUp: handleKeyUp,\n      onMouseDown: handleMouseDown,\n      onMouseUp: handleMouseUp,\n      onMouseLeave: handleMouseLeave,\n      onTouchStart: handleTouchStart,\n      onTouchMove: handleTouchMove,\n      onTouchEnd: handleTouchEnd,\n    },\n  };\n}\n"]},"metadata":{},"sourceType":"module"}