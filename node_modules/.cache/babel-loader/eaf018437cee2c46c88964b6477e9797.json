{"ast":null,"code":"var __assign = this && this.__assign || function () {\n  __assign = Object.assign || function (t) {\n    for (var s, i = 1, n = arguments.length; i < n; i++) {\n      s = arguments[i];\n\n      for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p)) t[p] = s[p];\n    }\n\n    return t;\n  };\n\n  return __assign.apply(this, arguments);\n};\n\nimport { jsx as _jsx } from \"react/jsx-runtime\";\nimport { useEffect, useMemo, useRef } from \"react\";\nimport { DEFAULT_DESKTOP_LARGE_MIN_WIDTH, DEFAULT_DESKTOP_MIN_WIDTH, DEFAULT_PHONE_MAX_WIDTH, DEFAULT_TABLET_MAX_WIDTH, DEFAULT_TABLET_MIN_WIDTH } from \"./constants\";\nimport { AppSizeContext } from \"./useAppSize\";\nimport { DEFAULT_APP_SIZE, useAppSizeMedia } from \"./useAppSizeMedia\";\n/**\n * This component should be mounted near the top of your app as it will keep\n * track of the current app size based on the provided breakpoint widths.\n */\n\nexport function AppSizeListener(_a) {\n  var children = _a.children,\n      onChange = _a.onChange,\n      _b = _a.phoneMaxWidth,\n      phoneMaxWidth = _b === void 0 ? DEFAULT_PHONE_MAX_WIDTH : _b,\n      _c = _a.tabletMinWidth,\n      tabletMinWidth = _c === void 0 ? DEFAULT_TABLET_MIN_WIDTH : _c,\n      _d = _a.tabletMaxWidth,\n      tabletMaxWidth = _d === void 0 ? DEFAULT_TABLET_MAX_WIDTH : _d,\n      _e = _a.desktopMinWidth,\n      desktopMinWidth = _e === void 0 ? DEFAULT_DESKTOP_MIN_WIDTH : _e,\n      _f = _a.desktopLargeMinWidth,\n      desktopLargeMinWidth = _f === void 0 ? DEFAULT_DESKTOP_LARGE_MIN_WIDTH : _f,\n      _g = _a.defaultSize,\n      defaultSize = _g === void 0 ? DEFAULT_APP_SIZE : _g;\n  var appSize = useAppSizeMedia({\n    phoneMaxWidth: phoneMaxWidth,\n    tabletMaxWidth: tabletMaxWidth,\n    tabletMinWidth: tabletMinWidth,\n    desktopMinWidth: desktopMinWidth,\n    desktopLargeMinWidth: desktopLargeMinWidth,\n    defaultSize: defaultSize\n  });\n  var lastValue = useRef(appSize);\n  useEffect(function () {\n    // trigger the onChange prop on mount only if there is a difference between\n    // the defaultSize and the mounted size.\n    if (onChange && (defaultSize.isPhone !== appSize.isPhone || defaultSize.isTablet !== appSize.isTablet || defaultSize.isDesktop !== appSize.isDesktop || defaultSize.isLargeDesktop !== appSize.isLargeDesktop || defaultSize.isLandscape !== appSize.isLandscape)) {\n      onChange(appSize, defaultSize);\n    } // eslint-disable-next-line react-hooks/exhaustive-deps\n\n  }, []);\n  useEffect(function () {\n    if (lastValue.current !== appSize) {\n      if (onChange) {\n        onChange(appSize, lastValue.current);\n      }\n\n      lastValue.current = appSize;\n    }\n  });\n  var value = useMemo(function () {\n    return __assign(__assign({}, appSize), {\n      __initialized: true\n    });\n  }, [appSize]);\n  return _jsx(AppSizeContext.Provider, __assign({\n    value: value\n  }, {\n    children: children\n  }));\n}","map":{"version":3,"mappings":";;;;;;;;;;;;;;;AACA,SAASA,SAAT,EAAoBC,OAApB,EAA6BC,MAA7B,QAA2C,OAA3C;AAEA,SACEC,+BADF,EAEEC,yBAFF,EAGEC,uBAHF,EAIEC,wBAJF,EAKEC,wBALF,QAMO,aANP;AAOA,SAASC,cAAT,QAA+B,cAA/B;AAEA,SAASC,gBAAT,EAA2BC,eAA3B,QAAkD,mBAAlD;AAaA;;;;;AAIA,OAAM,SAAUC,eAAV,CAA0BC,EAA1B,EASiB;MARrBC,QAAQ;MACRC,QAAQ;MACRC;MAAAC,aAAa,mBAAGX,uBAAH,GAA0BU;MACvCE;MAAAC,cAAc,mBAAGX,wBAAH,GAA2BU;MACzCE;MAAAC,cAAc,mBAAGd,wBAAH,GAA2Ba;MACzCE;MAAAC,eAAe,mBAAGlB,yBAAH,GAA4BiB;MAC3CE;MAAAC,oBAAoB,mBAAGrB,+BAAH,GAAkCoB;MACtDE;MAAAC,WAAW,mBAAGjB,gBAAH,GAAmBgB;EAE9B,IAAME,OAAO,GAAGjB,eAAe,CAAC;IAC9BM,aAAa,eADiB;IAE9BI,cAAc,gBAFgB;IAG9BF,cAAc,gBAHgB;IAI9BI,eAAe,iBAJe;IAK9BE,oBAAoB,sBALU;IAM9BE,WAAW;EANmB,CAAD,CAA/B;EAQA,IAAME,SAAS,GAAG1B,MAAM,CAACyB,OAAD,CAAxB;EAEA3B,SAAS,CAAC;IACR;IACA;IACA,IACEc,QAAQ,KACPY,WAAW,CAACG,OAAZ,KAAwBF,OAAO,CAACE,OAAhC,IACCH,WAAW,CAACI,QAAZ,KAAyBH,OAAO,CAACG,QADlC,IAECJ,WAAW,CAACK,SAAZ,KAA0BJ,OAAO,CAACI,SAFnC,IAGCL,WAAW,CAACM,cAAZ,KAA+BL,OAAO,CAACK,cAHxC,IAICN,WAAW,CAACO,WAAZ,KAA4BN,OAAO,CAACM,WAL9B,CADV,EAOE;MACAnB,QAAQ,CAACa,OAAD,EAAUD,WAAV,CAAR;IACD,CAZO,CAcR;;EACD,CAfQ,EAeN,EAfM,CAAT;EAiBA1B,SAAS,CAAC;IACR,IAAI4B,SAAS,CAACM,OAAV,KAAsBP,OAA1B,EAAmC;MACjC,IAAIb,QAAJ,EAAc;QACZA,QAAQ,CAACa,OAAD,EAAUC,SAAS,CAACM,OAApB,CAAR;MACD;;MAEDN,SAAS,CAACM,OAAV,GAAoBP,OAApB;IACD;EACF,CARQ,CAAT;EAUA,IAAMQ,KAAK,GAAGlC,OAAO,CACnB;IAAM,6BACD0B,OADC,GACM;MACVS,aAAa,EAAE;IADL,CADN;EAGJ,CAJiB,EAKnB,CAACT,OAAD,CALmB,CAArB;EAOA,OACEU,KAAC7B,cAAc,CAAC8B,QAAhB,EAAwBC;IAACJ,KAAK,EAAEA;EAAR,GAAa;IAAAtB,UAAGA;EAAH,CAAb,CAAxB,CADF;AAGD","names":["useEffect","useMemo","useRef","DEFAULT_DESKTOP_LARGE_MIN_WIDTH","DEFAULT_DESKTOP_MIN_WIDTH","DEFAULT_PHONE_MAX_WIDTH","DEFAULT_TABLET_MAX_WIDTH","DEFAULT_TABLET_MIN_WIDTH","AppSizeContext","DEFAULT_APP_SIZE","useAppSizeMedia","AppSizeListener","_a","children","onChange","_b","phoneMaxWidth","_c","tabletMinWidth","_d","tabletMaxWidth","_e","desktopMinWidth","_f","desktopLargeMinWidth","_g","defaultSize","appSize","lastValue","isPhone","isTablet","isDesktop","isLargeDesktop","isLandscape","current","value","__initialized","_jsx","Provider","__assign"],"sources":["C:\\Users\\hungr\\Documents\\VS-CODE\\notes-react\\node_modules\\@react-md\\utils\\src\\sizing\\AppSizeListener.tsx"],"sourcesContent":["import type { ReactElement, ReactNode } from \"react\";\nimport { useEffect, useMemo, useRef } from \"react\";\n\nimport {\n  DEFAULT_DESKTOP_LARGE_MIN_WIDTH,\n  DEFAULT_DESKTOP_MIN_WIDTH,\n  DEFAULT_PHONE_MAX_WIDTH,\n  DEFAULT_TABLET_MAX_WIDTH,\n  DEFAULT_TABLET_MIN_WIDTH,\n} from \"./constants\";\nimport { AppSizeContext } from \"./useAppSize\";\nimport type { AppSize, AppSizeOptions } from \"./useAppSizeMedia\";\nimport { DEFAULT_APP_SIZE, useAppSizeMedia } from \"./useAppSizeMedia\";\n\nexport interface AppSizeListenerProps extends AppSizeOptions {\n  children: ReactNode;\n\n  /**\n   * An change handler for the app size. This will be called each time the app\n   * size changes based on a window resize event and will be provided the next\n   * size and the previous size.\n   */\n  onChange?: (nextSize: AppSize, lastSize: AppSize) => void;\n}\n\n/**\n * This component should be mounted near the top of your app as it will keep\n * track of the current app size based on the provided breakpoint widths.\n */\nexport function AppSizeListener({\n  children,\n  onChange,\n  phoneMaxWidth = DEFAULT_PHONE_MAX_WIDTH,\n  tabletMinWidth = DEFAULT_TABLET_MIN_WIDTH,\n  tabletMaxWidth = DEFAULT_TABLET_MAX_WIDTH,\n  desktopMinWidth = DEFAULT_DESKTOP_MIN_WIDTH,\n  desktopLargeMinWidth = DEFAULT_DESKTOP_LARGE_MIN_WIDTH,\n  defaultSize = DEFAULT_APP_SIZE,\n}: AppSizeListenerProps): ReactElement {\n  const appSize = useAppSizeMedia({\n    phoneMaxWidth,\n    tabletMaxWidth,\n    tabletMinWidth,\n    desktopMinWidth,\n    desktopLargeMinWidth,\n    defaultSize,\n  });\n  const lastValue = useRef(appSize);\n\n  useEffect(() => {\n    // trigger the onChange prop on mount only if there is a difference between\n    // the defaultSize and the mounted size.\n    if (\n      onChange &&\n      (defaultSize.isPhone !== appSize.isPhone ||\n        defaultSize.isTablet !== appSize.isTablet ||\n        defaultSize.isDesktop !== appSize.isDesktop ||\n        defaultSize.isLargeDesktop !== appSize.isLargeDesktop ||\n        defaultSize.isLandscape !== appSize.isLandscape)\n    ) {\n      onChange(appSize, defaultSize);\n    }\n\n    // eslint-disable-next-line react-hooks/exhaustive-deps\n  }, []);\n\n  useEffect(() => {\n    if (lastValue.current !== appSize) {\n      if (onChange) {\n        onChange(appSize, lastValue.current);\n      }\n\n      lastValue.current = appSize;\n    }\n  });\n\n  const value = useMemo(\n    () => ({\n      ...appSize,\n      __initialized: true,\n    }),\n    [appSize]\n  );\n  return (\n    <AppSizeContext.Provider value={value}>{children}</AppSizeContext.Provider>\n  );\n}\n"]},"metadata":{},"sourceType":"module"}