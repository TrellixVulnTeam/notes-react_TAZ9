{"ast":null,"code":"var __assign = this && this.__assign || function () {\n  __assign = Object.assign || function (t) {\n    for (var s, i = 1, n = arguments.length; i < n; i++) {\n      s = arguments[i];\n\n      for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p)) t[p] = s[p];\n    }\n\n    return t;\n  };\n\n  return __assign.apply(this, arguments);\n};\n\nvar __read = this && this.__read || function (o, n) {\n  var m = typeof Symbol === \"function\" && o[Symbol.iterator];\n  if (!m) return o;\n  var i = m.call(o),\n      r,\n      ar = [],\n      e;\n\n  try {\n    while ((n === void 0 || n-- > 0) && !(r = i.next()).done) ar.push(r.value);\n  } catch (error) {\n    e = {\n      error: error\n    };\n  } finally {\n    try {\n      if (r && !r.done && (m = i[\"return\"])) m.call(i);\n    } finally {\n      if (e) throw e.error;\n    }\n  }\n\n  return ar;\n};\n\nvar __spreadArray = this && this.__spreadArray || function (to, from, pack) {\n  if (pack || arguments.length === 2) for (var i = 0, l = from.length, ar; i < l; i++) {\n    if (ar || !(i in from)) {\n      if (!ar) ar = Array.prototype.slice.call(from, 0, i);\n      ar[i] = from[i];\n    }\n  }\n  return to.concat(ar || Array.prototype.slice.call(from));\n};\n\nimport { useCallback, useRef } from \"react\";\nimport { JumpMovementKey, MovementPresets, scrollIntoView, useActiveDescendantMovement, useIsUserInteractionMode } from \"@react-md/utils\";\nimport { useFlattenedTreeList } from \"./useFlattenedTreeList\";\nimport { useNestedTreeList } from \"./useNestedTreeList\";\n/**\n * This is a temporary workaround for allowing the navigation tree to scroll\n * correctly with keyboard movement since it manually sets the\n * `overflow: visible` which prevents scrolling. I'll need to think of a better\n * way to find/get the scrollable element (if any). It might also just go into\n * the `scrollIntoView` util.\n *\n * @remarks \\@since 2.5.3\n * @internal\n */\n\nvar getScrollContainer = function (target) {\n  if (target.classList.contains(\"rmd-layout-tree\")) {\n    return target.parentElement;\n  }\n\n  return target;\n};\n/**\n * This hook handles all the complex and \"fun\" stuff for selecting keyboard\n * accessibility within a tree and enabling keyboard movement, selection, and\n * expansion.\n *\n * @internal\n */\n\n\nexport function useTreeMovement(_a) {\n  var id = _a.id,\n      data = _a.data,\n      rootId = _a.rootId,\n      sort = _a.sort,\n      onBlur = _a.onBlur,\n      onFocus = _a.onFocus,\n      onKeyDown = _a.onKeyDown,\n      multiSelect = _a.multiSelect,\n      selectedIds = _a.selectedIds,\n      onItemSelect = _a.onItemSelect,\n      onMultiItemSelect = _a.onMultiItemSelect,\n      expandedIds = _a.expandedIds,\n      onItemExpansion = _a.onItemExpansion,\n      onMultiItemExpansion = _a.onMultiItemExpansion,\n      valueKey = _a.valueKey,\n      getItemValue = _a.getItemValue;\n  var items = useNestedTreeList(data, sort, rootId);\n\n  var _b = __read(useFlattenedTreeList({\n    id: id,\n    items: items,\n    expandedIds: expandedIds,\n    rootId: rootId,\n    valueKey: valueKey,\n    getItemValue: getItemValue\n  }), 3),\n      visibleItems = _b[0],\n      itemIdRefs = _b[1],\n      flattenedItems = _b[2];\n\n  var isKeyboard = useIsUserInteractionMode(\"keyboard\");\n\n  var _c = useActiveDescendantMovement(__assign(__assign({}, MovementPresets.VERTICAL_TREE), {\n    items: visibleItems,\n    baseId: id,\n    getId: function (_baseId, index) {\n      return (visibleItems[index] || {\n        id: \"\"\n      }).id;\n    },\n    onSpace: function (focusedIndex) {\n      var item = visibleItems[focusedIndex];\n\n      if (!item) {\n        return;\n      }\n\n      var itemId = item.itemId;\n      onItemSelect(itemId);\n    },\n    onChange: function (data) {\n      var index = data.index,\n          target = data.target,\n          query = data.query;\n      var itemId = visibleItems[index].itemId; // Note: have to do a custom `scrollIntoView` here instead of relying on\n      // the `useActiveDescendantMovement`'s `scrollIntoView` because of how the\n      // tree renders with the ref behavior.\n\n      var item = itemIdRefs[itemId].ref.current;\n      var container = getScrollContainer(target);\n\n      if (item && container && container.scrollHeight > container.offsetHeight) {\n        scrollIntoView(container, item);\n      }\n\n      if (!multiSelect) {\n        return;\n      }\n\n      var isToStart = query.endsWith(JumpMovementKey.ControlShiftHome);\n      var isToEnd = query.endsWith(JumpMovementKey.ControlShiftEnd);\n\n      if (!isToStart && !isToEnd) {\n        return;\n      }\n\n      var start = isToStart ? 0 : focusedIndex;\n      var end = isToStart ? focusedIndex + 1 : undefined;\n      var jumpSelectedIds = visibleItems.slice(start, end).map(function (_a) {\n        var itemId = _a.itemId;\n        return itemId;\n      });\n      var uniqueSelectedIds = Array.from(new Set(__spreadArray(__spreadArray([], __read(selectedIds), false), __read(jumpSelectedIds), false)));\n\n      if (selectedIds.length !== uniqueSelectedIds.length) {\n        onMultiItemSelect(uniqueSelectedIds);\n      }\n    },\n    onKeyDown: function (event) {\n      var _a, _b, _c, _d;\n\n      if (onKeyDown) {\n        onKeyDown(event);\n      }\n\n      var item = visibleItems[focusedIndex];\n\n      if (!item) {\n        return;\n      }\n\n      var itemId = item.itemId,\n          parentId = item.parentId,\n          isParent = item.isParent;\n\n      switch (event.key) {\n        case \"Enter\":\n          {\n            if (isParent) {\n              onItemExpansion(itemId, !expandedIds.includes(itemId));\n              return;\n            }\n\n            var node = itemIdRefs[itemId].ref.current;\n            var anchor = node && node.getAttribute(\"role\") === \"none\" && node.querySelector(\"a[href]\");\n\n            if (!anchor) {\n              onItemSelect(itemId);\n              return;\n            } // if a user is navigating through the app with a keyboard and presses\n            // cmd+shift+enter (Mac) or ctrl+shift+enter (Windows), the link will\n            // be forcefully opened in a new tab irregardless of the target\n            // attribute on the anchor tag. Since a tree doesn't actually focus\n            // the link in this case, need to \"polyfill\" it with this workaround.\n            // the `meta` key is for Mac and `ctrlKey` for Windows\n\n\n            var forceNewTab = event.shiftKey && (event.metaKey || event.ctrlKey);\n            var prevTarget = anchor.target;\n\n            if (forceNewTab) {\n              anchor.target = \"_blank\";\n            }\n\n            anchor.click();\n\n            if (forceNewTab) {\n              anchor.target = prevTarget;\n            }\n\n            break;\n          }\n\n        case \"ArrowRight\":\n          if (!isParent) {\n            return;\n          }\n\n          if (!expandedIds.includes(itemId)) {\n            onItemExpansion(itemId, true);\n          } else {\n            var nextIndex = focusedIndex + 1;\n            var nextItem = (_b = itemIdRefs[(_a = visibleItems[nextIndex]) === null || _a === void 0 ? void 0 : _a.itemId]) === null || _b === void 0 ? void 0 : _b.ref.current;\n            setFocusedIndex(nextIndex);\n            scrollIntoView(event.currentTarget, nextItem);\n          }\n\n          break;\n\n        case \"ArrowLeft\":\n          if (isParent && expandedIds.includes(itemId)) {\n            onItemExpansion(itemId, false);\n          } else if (parentId !== rootId) {\n            var parentIndex = visibleItems.findIndex(function (item) {\n              return item.itemId === parentId;\n            });\n            var parentItem = (_d = itemIdRefs[(_c = visibleItems[parentIndex]) === null || _c === void 0 ? void 0 : _c.itemId]) === null || _d === void 0 ? void 0 : _d.ref.current;\n            setFocusedIndex(parentIndex);\n            scrollIntoView(event.currentTarget, parentItem);\n          }\n\n          break;\n\n        case \"a\":\n          {\n            if (!multiSelect || !event.ctrlKey) {\n              return;\n            }\n\n            event.preventDefault();\n            var allItemIds = visibleItems.map(function (_a) {\n              var itemId = _a.itemId;\n              return itemId;\n            });\n\n            if (selectedIds.length === allItemIds.length) {\n              onMultiItemSelect([]);\n            } else {\n              onMultiItemSelect(allItemIds);\n            }\n\n            break;\n          }\n\n        case \"*\":\n          {\n            var item_1 = visibleItems[focusedIndex];\n\n            if (!item_1) {\n              return;\n            }\n\n            var expectedExpandedIds = visibleItems.filter(function (_a) {\n              var isParent = _a.isParent,\n                  parentId = _a.parentId;\n              return isParent && parentId === item_1.parentId;\n            }).map(function (_a) {\n              var itemId = _a.itemId;\n              return itemId;\n            });\n            var nextIds = Array.from(new Set(__spreadArray(__spreadArray([], __read(expandedIds), false), __read(expectedExpandedIds), false)));\n\n            if (nextIds.length !== expandedIds.length) {\n              onMultiItemExpansion(nextIds); // since new items will be rendered, need to also update the focused\n              // index so the currently active item is still the \"focused\" item\n              //\n              // TODO: Look into a much better way to handle this sort of stuff..\n              // This still doesn't correctly scroll the active element into view.\n              // I should probably move all the scroll behavior into a useEffect\n              // for whenever the focusedIndex changes.\n\n              var visibleCount = 0;\n              var lookup = {};\n\n              for (var i = 0; i < flattenedItems.length; i += 1) {\n                var item_2 = flattenedItems[i];\n                var isVisible = item_2.parentId === rootId;\n\n                if (item_2.parentId !== null && nextIds.includes(item_2.parentId)) {\n                  isVisible = !!lookup[item_2.parentId];\n                }\n\n                lookup[item_2.itemId] = isVisible;\n\n                if (itemId === item_2.itemId) {\n                  setFocusedIndex(visibleCount);\n                  return;\n                }\n\n                if (isVisible) {\n                  visibleCount += 1;\n                }\n              }\n            }\n          }\n        // no default\n      }\n    }\n  })),\n      activeId = _c.activeId,\n      handleKeyDown = _c.onKeyDown,\n      focusedIndex = _c.focusedIndex,\n      setFocusedIndex = _c.setFocusedIndex;\n\n  var lastFocus = useRef(0);\n  var handleBlur = useCallback(function (event) {\n    if (onBlur) {\n      onBlur(event);\n    }\n\n    if (document.activeElement && event.currentTarget.contains(document.activeElement)) {\n      return;\n    }\n\n    lastFocus.current = focusedIndex;\n    setFocusedIndex(-1);\n  }, [focusedIndex, onBlur, setFocusedIndex]);\n  var handleFocus = useCallback(function (event) {\n    var _a, _b;\n\n    if (onFocus) {\n      onFocus(event);\n    }\n\n    if (focusedIndex !== -1) {\n      // this happens when a tree item is clicked with the mouse or touch\n      return;\n    }\n\n    var index = -1; // try to \"focus\" the first selected itemId if there is a selection.\n\n    if (selectedIds.length) {\n      index = visibleItems.findIndex(function (item) {\n        return selectedIds.includes(item.itemId);\n      });\n    } // fallback to the first visible tree item if there were no selected ids\n\n\n    if (index === -1) {\n      index = Math.max(0, Math.min(lastFocus.current, visibleItems.length));\n    }\n\n    var currentItem = (_b = itemIdRefs[(_a = visibleItems[index]) === null || _a === void 0 ? void 0 : _a.itemId]) === null || _b === void 0 ? void 0 : _b.ref.current;\n\n    if (currentItem && isKeyboard) {\n      scrollIntoView(getScrollContainer(event.currentTarget), currentItem);\n    }\n\n    setFocusedIndex(index);\n  }, [focusedIndex, isKeyboard, itemIdRefs, onFocus, selectedIds, setFocusedIndex, visibleItems]);\n  var setActiveId = useCallback(function (itemId) {\n    var index = visibleItems.findIndex(function (item) {\n      return item.itemId === itemId;\n    });\n\n    if (index !== -1) {\n      setFocusedIndex(index);\n    }\n  }, [setFocusedIndex, visibleItems]);\n  return {\n    items: items,\n    activeId: activeId,\n    setActiveId: setActiveId,\n    itemIdRefs: itemIdRefs,\n    handleBlur: handleBlur,\n    handleFocus: handleFocus,\n    handleKeyDown: handleKeyDown\n  };\n}","map":{"version":3,"mappings":"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","names":["useCallback","useRef","JumpMovementKey","MovementPresets","scrollIntoView","useActiveDescendantMovement","useIsUserInteractionMode","useFlattenedTreeList","useNestedTreeList","getScrollContainer","target","classList","contains","parentElement","useTreeMovement","_a","id","data","rootId","sort","onBlur","onFocus","onKeyDown","multiSelect","selectedIds","onItemSelect","onMultiItemSelect","expandedIds","onItemExpansion","onMultiItemExpansion","valueKey","getItemValue","items","visibleItems","itemIdRefs","flattenedItems","isKeyboard","VERTICAL_TREE","baseId","getId","_baseId","index","onSpace","focusedIndex","item","itemId","onChange","query","ref","current","container","scrollHeight","offsetHeight","isToStart","endsWith","ControlShiftHome","isToEnd","ControlShiftEnd","start","end","undefined","jumpSelectedIds","slice","map","uniqueSelectedIds","Array","from","Set","__spreadArray","__read","length","event","parentId","isParent","key","includes","node","anchor","getAttribute","querySelector","forceNewTab","shiftKey","metaKey","ctrlKey","prevTarget","click","nextIndex","nextItem","_b","setFocusedIndex","currentTarget","parentIndex","findIndex","parentItem","_c","_d","preventDefault","allItemIds","item_1","expectedExpandedIds","filter","nextIds","visibleCount","lookup","i","item_2","isVisible","activeId","handleKeyDown","lastFocus","handleBlur","document","activeElement","handleFocus","Math","max","min","currentItem","setActiveId"],"sources":["C:\\Users\\hungr\\Documents\\VS-CODE\\notes-react\\node_modules\\@react-md\\tree\\src\\useTreeMovement.ts"],"sourcesContent":["import type { FocusEventHandler, KeyboardEventHandler } from \"react\";\nimport { useCallback, useRef } from \"react\";\nimport type { ListElement } from \"@react-md/list\";\nimport {\n  JumpMovementKey,\n  MovementPresets,\n  scrollIntoView,\n  useActiveDescendantMovement,\n  useIsUserInteractionMode,\n} from \"@react-md/utils\";\n\nimport type { TreeItemId, TreeProps, UnknownTreeItem } from \"./types\";\nimport type {\n  MetadataRecord,\n  SearchableTreeItem,\n} from \"./useFlattenedTreeList\";\nimport { useFlattenedTreeList } from \"./useFlattenedTreeList\";\nimport type { NestedTreeItem } from \"./useNestedTreeList\";\nimport { useNestedTreeList } from \"./useNestedTreeList\";\n\ntype Options = Pick<\n  TreeProps<UnknownTreeItem>,\n  | \"id\"\n  | \"data\"\n  | \"sort\"\n  | \"onBlur\"\n  | \"onFocus\"\n  | \"onKeyDown\"\n  | \"multiSelect\"\n  | \"selectedIds\"\n  | \"onItemSelect\"\n  | \"onMultiItemSelect\"\n  | \"expandedIds\"\n  | \"onItemExpansion\"\n  | \"onMultiItemExpansion\"\n> &\n  Required<\n    Pick<TreeProps<UnknownTreeItem>, \"valueKey\" | \"getItemValue\" | \"rootId\">\n  >;\n\ninterface ReturnValue {\n  /**\n   * A nested list representation of the provided tree data. This is used for\n   * rendering all the treeitem nodes.\n   */\n  items: readonly NestedTreeItem<UnknownTreeItem>[];\n\n  /**\n   * The current treeitem's DOM id that is currently keyboard focused.\n   */\n  activeId: string;\n\n  /**\n   * A function that updates the `activeId` based on the provided `itemId`. This\n   * should really only be used whenever an item is clicked with a mouse or\n   * touch since the `activeId` will be updated automatically for all the other\n   * flows.\n   */\n  setActiveId(itemId: TreeItemId): void;\n\n  /**\n   * A record containing the DOM ids for each tree item along with a ref object\n   * to provide to the itemRenderer for that item. This is just for a quick\n   * lookup to help with all the tree traversal and keyboard movement.\n   */\n  itemIdRefs: MetadataRecord;\n\n  /**\n   * A blur handler that should be passed to the tree list element that handles\n   * removing the `aria-activedescendant` when the tree is no longer within\n   * focus. This will also call the optional `onBlur` prop.\n   */\n  handleBlur: FocusEventHandler<ListElement>;\n\n  /**\n   * A focus handler that should be passed to the tree element that handles\n   * conditionally setting the default `aria-activedescendant` id on first\n   * focus. This will also call the optional `onFocus` prop.\n   */\n  handleFocus: FocusEventHandler<ListElement>;\n\n  /**\n   * The keydown handler that should be passed to the tree list element that\n   * handles all the keyboard functionality and movement.\n   *\n   * This will also call the optional `onKeyDown` prop.\n   */\n  handleKeyDown: KeyboardEventHandler<ListElement>;\n}\n\n/**\n * This is a temporary workaround for allowing the navigation tree to scroll\n * correctly with keyboard movement since it manually sets the\n * `overflow: visible` which prevents scrolling. I'll need to think of a better\n * way to find/get the scrollable element (if any). It might also just go into\n * the `scrollIntoView` util.\n *\n * @remarks \\@since 2.5.3\n * @internal\n */\nconst getScrollContainer = (target: HTMLElement): HTMLElement | null => {\n  if (target.classList.contains(\"rmd-layout-tree\")) {\n    return target.parentElement;\n  }\n\n  return target;\n};\n\n/**\n * This hook handles all the complex and \"fun\" stuff for selecting keyboard\n * accessibility within a tree and enabling keyboard movement, selection, and\n * expansion.\n *\n * @internal\n */\nexport function useTreeMovement({\n  id,\n  data,\n  rootId,\n  sort,\n  onBlur,\n  onFocus,\n  onKeyDown,\n  multiSelect,\n  selectedIds,\n  onItemSelect,\n  onMultiItemSelect,\n  expandedIds,\n  onItemExpansion,\n  onMultiItemExpansion,\n  valueKey,\n  getItemValue,\n}: Options): ReturnValue {\n  const items = useNestedTreeList(data, sort, rootId);\n  const [visibleItems, itemIdRefs, flattenedItems] = useFlattenedTreeList({\n    id,\n    items,\n    expandedIds,\n    rootId,\n    valueKey,\n    getItemValue,\n  });\n\n  const isKeyboard = useIsUserInteractionMode(\"keyboard\");\n\n  const {\n    activeId,\n    onKeyDown: handleKeyDown,\n    focusedIndex,\n    setFocusedIndex,\n  } = useActiveDescendantMovement<\n    SearchableTreeItem,\n    ListElement,\n    HTMLLIElement\n  >({\n    ...MovementPresets.VERTICAL_TREE,\n    items: visibleItems,\n    baseId: id,\n    getId(_baseId, index) {\n      return (visibleItems[index] || { id: \"\" }).id;\n    },\n    onSpace(focusedIndex) {\n      const item = visibleItems[focusedIndex];\n      if (!item) {\n        return;\n      }\n\n      const { itemId } = item;\n      onItemSelect(itemId);\n    },\n    onChange(data) {\n      const { index, target, query } = data;\n      const { itemId } = visibleItems[index];\n      // Note: have to do a custom `scrollIntoView` here instead of relying on\n      // the `useActiveDescendantMovement`'s `scrollIntoView` because of how the\n      // tree renders with the ref behavior.\n      const item = itemIdRefs[itemId].ref.current;\n      const container = getScrollContainer(target);\n      if (\n        item &&\n        container &&\n        container.scrollHeight > container.offsetHeight\n      ) {\n        scrollIntoView(container, item);\n      }\n\n      if (!multiSelect) {\n        return;\n      }\n\n      const isToStart = query.endsWith(JumpMovementKey.ControlShiftHome);\n      const isToEnd = query.endsWith(JumpMovementKey.ControlShiftEnd);\n      if (!isToStart && !isToEnd) {\n        return;\n      }\n\n      const start = isToStart ? 0 : focusedIndex;\n      const end = isToStart ? focusedIndex + 1 : undefined;\n      const jumpSelectedIds = visibleItems\n        .slice(start, end)\n        .map(({ itemId }) => itemId);\n      const uniqueSelectedIds = Array.from(\n        new Set([...selectedIds, ...jumpSelectedIds])\n      );\n      if (selectedIds.length !== uniqueSelectedIds.length) {\n        onMultiItemSelect(uniqueSelectedIds);\n      }\n    },\n    onKeyDown(event) {\n      if (onKeyDown) {\n        onKeyDown(event);\n      }\n\n      const item = visibleItems[focusedIndex];\n      if (!item) {\n        return;\n      }\n\n      const { itemId, parentId, isParent } = item;\n      switch (event.key) {\n        case \"Enter\": {\n          if (isParent) {\n            onItemExpansion(itemId, !expandedIds.includes(itemId));\n            return;\n          }\n\n          const node = itemIdRefs[itemId].ref.current;\n          const anchor =\n            node &&\n            node.getAttribute(\"role\") === \"none\" &&\n            node.querySelector<HTMLAnchorElement>(\"a[href]\");\n          if (!anchor) {\n            onItemSelect(itemId);\n            return;\n          }\n\n          // if a user is navigating through the app with a keyboard and presses\n          // cmd+shift+enter (Mac) or ctrl+shift+enter (Windows), the link will\n          // be forcefully opened in a new tab irregardless of the target\n          // attribute on the anchor tag. Since a tree doesn't actually focus\n          // the link in this case, need to \"polyfill\" it with this workaround.\n          // the `meta` key is for Mac and `ctrlKey` for Windows\n          const forceNewTab =\n            event.shiftKey && (event.metaKey || event.ctrlKey);\n\n          const prevTarget = anchor.target;\n          if (forceNewTab) {\n            anchor.target = \"_blank\";\n          }\n          anchor.click();\n          if (forceNewTab) {\n            anchor.target = prevTarget;\n          }\n\n          break;\n        }\n        case \"ArrowRight\":\n          if (!isParent) {\n            return;\n          }\n\n          if (!expandedIds.includes(itemId)) {\n            onItemExpansion(itemId, true);\n          } else {\n            const nextIndex = focusedIndex + 1;\n            const nextItem =\n              itemIdRefs[visibleItems[nextIndex]?.itemId]?.ref.current;\n\n            setFocusedIndex(nextIndex);\n            scrollIntoView(event.currentTarget, nextItem);\n          }\n          break;\n        case \"ArrowLeft\":\n          if (isParent && expandedIds.includes(itemId)) {\n            onItemExpansion(itemId, false);\n          } else if (parentId !== rootId) {\n            const parentIndex = visibleItems.findIndex(\n              (item) => item.itemId === parentId\n            );\n            const parentItem =\n              itemIdRefs[visibleItems[parentIndex]?.itemId]?.ref.current;\n\n            setFocusedIndex(parentIndex);\n            scrollIntoView(event.currentTarget, parentItem);\n          }\n          break;\n        case \"a\": {\n          if (!multiSelect || !event.ctrlKey) {\n            return;\n          }\n\n          event.preventDefault();\n          const allItemIds = visibleItems.map(({ itemId }) => itemId);\n          if (selectedIds.length === allItemIds.length) {\n            onMultiItemSelect([]);\n          } else {\n            onMultiItemSelect(allItemIds);\n          }\n          break;\n        }\n        case \"*\": {\n          const item = visibleItems[focusedIndex];\n          if (!item) {\n            return;\n          }\n\n          const expectedExpandedIds = visibleItems\n            .filter(\n              ({ isParent, parentId }) => isParent && parentId === item.parentId\n            )\n            .map(({ itemId }) => itemId);\n          const nextIds = Array.from(\n            new Set([...expandedIds, ...expectedExpandedIds])\n          );\n          if (nextIds.length !== expandedIds.length) {\n            onMultiItemExpansion(nextIds);\n\n            // since new items will be rendered, need to also update the focused\n            // index so the currently active item is still the \"focused\" item\n            //\n            // TODO: Look into a much better way to handle this sort of stuff..\n            // This still doesn't correctly scroll the active element into view.\n            // I should probably move all the scroll behavior into a useEffect\n            // for whenever the focusedIndex changes.\n            let visibleCount = 0;\n            const lookup: Record<TreeItemId, boolean> = {};\n            for (let i = 0; i < flattenedItems.length; i += 1) {\n              const item = flattenedItems[i];\n              let isVisible = item.parentId === rootId;\n              if (item.parentId !== null && nextIds.includes(item.parentId)) {\n                isVisible = !!lookup[item.parentId];\n              }\n\n              lookup[item.itemId] = isVisible;\n\n              if (itemId === item.itemId) {\n                setFocusedIndex(visibleCount);\n                return;\n              }\n\n              if (isVisible) {\n                visibleCount += 1;\n              }\n            }\n          }\n        }\n        // no default\n      }\n    },\n  });\n\n  const lastFocus = useRef(0);\n  const handleBlur = useCallback(\n    (event: React.FocusEvent<ListElement>) => {\n      if (onBlur) {\n        onBlur(event);\n      }\n\n      if (\n        document.activeElement &&\n        event.currentTarget.contains(document.activeElement)\n      ) {\n        return;\n      }\n\n      lastFocus.current = focusedIndex;\n      setFocusedIndex(-1);\n    },\n    [focusedIndex, onBlur, setFocusedIndex]\n  );\n\n  const handleFocus = useCallback(\n    (event: React.FocusEvent<ListElement>) => {\n      if (onFocus) {\n        onFocus(event);\n      }\n\n      if (focusedIndex !== -1) {\n        // this happens when a tree item is clicked with the mouse or touch\n        return;\n      }\n\n      let index = -1;\n      // try to \"focus\" the first selected itemId if there is a selection.\n      if (selectedIds.length) {\n        index = visibleItems.findIndex((item) =>\n          selectedIds.includes(item.itemId)\n        );\n      }\n\n      // fallback to the first visible tree item if there were no selected ids\n      if (index === -1) {\n        index = Math.max(0, Math.min(lastFocus.current, visibleItems.length));\n      }\n\n      const currentItem = itemIdRefs[visibleItems[index]?.itemId]?.ref.current;\n      if (currentItem && isKeyboard) {\n        scrollIntoView(getScrollContainer(event.currentTarget), currentItem);\n      }\n      setFocusedIndex(index);\n    },\n    [\n      focusedIndex,\n      isKeyboard,\n      itemIdRefs,\n      onFocus,\n      selectedIds,\n      setFocusedIndex,\n      visibleItems,\n    ]\n  );\n\n  const setActiveId = useCallback(\n    (itemId: TreeItemId) => {\n      const index = visibleItems.findIndex((item) => item.itemId === itemId);\n      if (index !== -1) {\n        setFocusedIndex(index);\n      }\n    },\n    [setFocusedIndex, visibleItems]\n  );\n\n  return {\n    items,\n    activeId,\n    setActiveId,\n    itemIdRefs,\n    handleBlur,\n    handleFocus,\n    handleKeyDown,\n  };\n}\n"]},"metadata":{},"sourceType":"module"}