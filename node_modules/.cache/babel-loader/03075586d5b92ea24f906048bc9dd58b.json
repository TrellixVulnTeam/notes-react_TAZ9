{"ast":null,"code":"var __read = this && this.__read || function (o, n) {\n  var m = typeof Symbol === \"function\" && o[Symbol.iterator];\n  if (!m) return o;\n  var i = m.call(o),\n      r,\n      ar = [],\n      e;\n\n  try {\n    while ((n === void 0 || n-- > 0) && !(r = i.next()).done) ar.push(r.value);\n  } catch (error) {\n    e = {\n      error: error\n    };\n  } finally {\n    try {\n      if (r && !r.done && (m = i[\"return\"])) m.call(i);\n    } finally {\n      if (e) throw e.error;\n    }\n  }\n\n  return ar;\n};\n\nvar __spreadArray = this && this.__spreadArray || function (to, from, pack) {\n  if (pack || arguments.length === 2) for (var i = 0, l = from.length, ar; i < l; i++) {\n    if (ar || !(i in from)) {\n      if (!ar) ar = Array.prototype.slice.call(from, 0, i);\n      ar[i] = from[i];\n    }\n  }\n  return to.concat(ar || Array.prototype.slice.call(from));\n};\n\nimport { useCallback, useEffect, useReducer, useRef } from \"react\";\nimport { useTimeout, useToggle } from \"@react-md/utils\";\nimport { DEFAULT_MESSAGE_QUEUE_TIMEOUT } from \"./MessageQueueContext\";\nimport { useWindowBlurPause } from \"./useWindowBlurPause\";\nexport var ADD_MESSAGE = \"ADD_MESSAGE\";\nexport var POP_MESSAGE = \"POP_MESSAGE\";\nexport var RESET_QUEUE = \"RESET_QUEUE\";\n/**\n * @internal\n */\n\nexport function addMessage(message, duplicates) {\n  return {\n    type: ADD_MESSAGE,\n    message: message,\n    duplicates: duplicates\n  };\n}\n/**\n * @internal\n */\n\nexport var popMessage = function () {\n  return {\n    type: POP_MESSAGE\n  };\n};\n/**\n * @internal\n */\n\nexport var resetQueue = function () {\n  return {\n    type: RESET_QUEUE\n  };\n};\n/**\n * This function is used to update the message queue state by adding a new\n * message when needed.\n *\n * @internal\n */\n\nexport function handleAddMessage(state, message, duplicates) {\n  if (state.length === 0) {\n    return [message];\n  }\n\n  var messageId = message.messageId,\n      _a = message.messagePriority,\n      messagePriority = _a === void 0 ? \"normal\" : _a;\n  var i = state.findIndex(function (mes) {\n    return mes.messageId === messageId;\n  });\n  var isNext = messagePriority === \"next\";\n  var isNormal = messagePriority === \"normal\";\n  var isReplace = messagePriority === \"replace\";\n  var isImmediate = messagePriority === \"immediate\";\n  var isDuplicable = duplicates === \"allow\";\n  var isRestart = duplicates === \"restart\";\n\n  if (isNext || isImmediate) {\n    var nextState = state.slice(); // remove the existing message if duplicated messages aren't allowed. This\n    // will kind of act like a replace + next behavior\n\n    if (!isDuplicable && i > 0) {\n      nextState.splice(i, 1);\n    }\n\n    var _b = __read(nextState),\n        current = _b[0],\n        remaining = _b.slice(1);\n\n    if (isImmediate && current.messagePriority !== \"immediate\") {\n      return __spreadArray([current, message, current], __read(remaining), false);\n    }\n\n    return __spreadArray([current, message], __read(remaining), false);\n  }\n\n  if (i === -1 || isDuplicable && isNormal) {\n    return __spreadArray(__spreadArray([], __read(state), false), [message], false);\n  }\n\n  if (isNormal) {\n    if (isRestart) {\n      // creating a new state so that the queue visibility hook can still be\n      // triggered which will restart the timer\n      return state.slice();\n    }\n\n    return state;\n  }\n\n  if (isReplace) {\n    var nextState = state.slice();\n    nextState[i] = message;\n    return nextState;\n  }\n\n  return __spreadArray(__spreadArray([], __read(state), false), [message], false);\n}\n/**\n * @internal\n */\n\nexport function reducer(state, action) {\n  switch (action.type) {\n    case ADD_MESSAGE:\n      return handleAddMessage(state, action.message, action.duplicates);\n\n    case POP_MESSAGE:\n      return state.length ? state.slice(1) : state;\n\n    case RESET_QUEUE:\n      return state.length ? [] : state;\n\n    default:\n      return state;\n  }\n}\n/**\n * This is the main logic for the message queue behavior that will handle:\n *\n * - creating timeouts as needed to show/hide toasts within the `SnackbarQueue`\n *   component\n * - create a way to push messages with optional priority onto the queue\n *\n * @internal\n */\n\nexport function useMessageQueue(_a) {\n  var _b = _a.timeout,\n      timeout = _b === void 0 ? DEFAULT_MESSAGE_QUEUE_TIMEOUT : _b,\n      _c = _a.duplicates,\n      duplicates = _c === void 0 ? \"allow\" : _c,\n      _d = _a.defaultQueue,\n      defaultQueue = _d === void 0 ? [] : _d;\n\n  var _e = __read(useReducer(function (state, action) {\n    return reducer(state, action);\n  }, defaultQueue), 2),\n      queue = _e[0],\n      dispatch = _e[1];\n\n  var queueRef = useRef(queue);\n  var addMessageDispatch = useCallback(function (message) {\n    if (duplicates !== \"allow\" && !message.messageId) {\n      throw new Error(\"A messageId is required when the \\\"\".concat(duplicates, \"\\\" duplicate behavior is enabled but it was not provided in the current message.\"));\n    }\n\n    dispatch({\n      type: ADD_MESSAGE,\n      message: message,\n      duplicates: duplicates\n    });\n  }, [duplicates]);\n  var popMessageDispatch = useCallback(function () {\n    dispatch(popMessage());\n  }, []);\n  var resetQueueDispatch = useCallback(function () {\n    dispatch(resetQueue());\n    return queueRef.current;\n  }, []);\n\n  var _f = __read(useToggle(defaultQueue.length > 0), 3),\n      visible = _f[0],\n      showMessage = _f[1],\n      hideMessage = _f[2];\n\n  var _g = __read(useTimeout(hideMessage, timeout), 3),\n      startTimer = _g[0],\n      stopTimer = _g[1],\n      restartTimer = _g[2];\n\n  useEffect(function () {\n    // this effect will handle all the \"logic\" for transitioning between each\n    // message along with the message priority updates.\n    var _a = __read(queue, 2),\n        message = _a[0],\n        nextMessage = _a[1];\n\n    if (!message) {\n      return;\n    }\n\n    var prevQueue = queueRef.current;\n\n    var _b = __read(prevQueue, 1),\n        prevMessage = _b[0];\n\n    if (message.messagePriority !== \"immediate\" && nextMessage && nextMessage.messagePriority === \"immediate\") {\n      stopTimer();\n\n      if (!visible) {\n        popMessageDispatch();\n        return;\n      }\n\n      hideMessage();\n      return;\n    }\n\n    if (!visible) {\n      showMessage();\n    }\n\n    if (queue.length === prevQueue.length && message === prevMessage) {\n      restartTimer();\n    } // only want to run this on queue changes\n    // eslint-disable-next-line react-hooks/exhaustive-deps\n\n  }, [queue]);\n  useWindowBlurPause({\n    startTimer: startTimer,\n    stopTimer: stopTimer,\n    visible: visible,\n    message: queue[0]\n  });\n  useEffect(function () {\n    queueRef.current = queue;\n  });\n  return {\n    queue: queue,\n    resetQueue: resetQueueDispatch,\n    visible: visible,\n    hideMessage: hideMessage,\n    addMessage: addMessageDispatch,\n    popMessage: popMessageDispatch,\n    startTimer: startTimer,\n    stopTimer: stopTimer,\n    restartTimer: restartTimer\n  };\n}","map":{"version":3,"mappings":";;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AACA,SAASA,WAAT,EAAsBC,SAAtB,EAAiCC,UAAjC,EAA6CC,MAA7C,QAA2D,OAA3D;AACA,SAASC,UAAT,EAAqBC,SAArB,QAAsC,iBAAtC;AAWA,SAASC,6BAAT,QAA8C,uBAA9C;AACA,SAASC,kBAAT,QAAmC,sBAAnC;AAEA,OAAO,IAAMC,WAAW,GAAG,aAApB;AACP,OAAO,IAAMC,WAAW,GAAG,aAApB;AACP,OAAO,IAAMC,WAAW,GAAG,aAApB;AAWP;;;;AAGA,OAAM,SAAUC,UAAV,CACJC,OADI,EAEJC,UAFI,EAEyB;EAE7B,OAAO;IAAEC,IAAI,EAAEN,WAAR;IAAqBI,OAAO,SAA5B;IAA8BC,UAAU;EAAxC,CAAP;AACD;AASD;;;;AAGA,OAAO,IAAME,UAAU,GAAG;EAAwB,OAAC;IAAED,IAAI,EAAEL;EAAR,CAAD;AAAuB,CAAlE;AASP;;;;AAGA,OAAO,IAAMO,UAAU,GAAG;EAAwB,OAAC;IAAEF,IAAI,EAAEJ;EAAR,CAAD;AAAuB,CAAlE;AAUP;;;;;;;AAMA,OAAM,SAAUO,gBAAV,CACJC,KADI,EAEJN,OAFI,EAGJC,UAHI,EAGyB;EAE7B,IAAIK,KAAK,CAACC,MAAN,KAAiB,CAArB,EAAwB;IACtB,OAAO,CAACP,OAAD,CAAP;EACD;;EAEO,aAAS,GAAiCA,OAAO,UAAjD;EAAA,IAAWQ,KAA+BR,OAAO,gBAAjD;EAAA,IAAWS,eAAe,mBAAG,QAAH,GAAWD,EAArC;EACR,IAAME,CAAC,GAAGJ,KAAK,CAACK,SAAN,CAAgB,UAACC,GAAD,EAAI;IAAK,UAAG,CAACC,SAAJ,KAAkBA,SAAlB;EAA2B,CAApD,CAAV;EACA,IAAMC,MAAM,GAAGL,eAAe,KAAK,MAAnC;EACA,IAAMM,QAAQ,GAAGN,eAAe,KAAK,QAArC;EACA,IAAMO,SAAS,GAAGP,eAAe,KAAK,SAAtC;EACA,IAAMQ,WAAW,GAAGR,eAAe,KAAK,WAAxC;EACA,IAAMS,YAAY,GAAGjB,UAAU,KAAK,OAApC;EACA,IAAMkB,SAAS,GAAGlB,UAAU,KAAK,SAAjC;;EACA,IAAIa,MAAM,IAAIG,WAAd,EAA2B;IACzB,IAAMG,SAAS,GAAGd,KAAK,CAACe,KAAN,EAAlB,CADyB,CAGzB;IACA;;IACA,IAAI,CAACH,YAAD,IAAiBR,CAAC,GAAG,CAAzB,EAA4B;MAC1BU,SAAS,CAACE,MAAV,CAAiBZ,CAAjB,EAAoB,CAApB;IACD;;IAEK,gBAA0BU,SAA1B;IAAA,IAACG,OAAO,QAAR;IAAA,IAAaC,SAAS,cAAtB;;IACN,IAAIP,WAAW,IAAIM,OAAO,CAACd,eAAR,KAA4B,WAA/C,EAA4D;MAC1D,sBAAQc,OAAR,EAAiBvB,OAAjB,EAA0BuB,OAA1B,GAAiCE,OAAKD,SAAL,CAAjC,EAA+C,KAA/C;IACD;;IAED,sBAAQD,OAAR,EAAiBvB,OAAjB,GAAwByB,OAAKD,SAAL,CAAxB,EAAsC,KAAtC;EACD;;EAED,IAAId,CAAC,KAAK,CAAC,CAAP,IAAaQ,YAAY,IAAIH,QAAjC,EAA4C;IAC1C,8CAAWT,KAAX,GAAgB,KAAhB,GAAgB,CAAEN,OAAF,CAAhB,EAAyB,KAAzB;EACD;;EAED,IAAIe,QAAJ,EAAc;IACZ,IAAII,SAAJ,EAAe;MACb;MACA;MACA,OAAOb,KAAK,CAACe,KAAN,EAAP;IACD;;IAED,OAAOf,KAAP;EACD;;EAED,IAAIU,SAAJ,EAAe;IACb,IAAMI,SAAS,GAAGd,KAAK,CAACe,KAAN,EAAlB;IACAD,SAAS,CAACV,CAAD,CAAT,GAAeV,OAAf;IACA,OAAOoB,SAAP;EACD;;EAED,8CAAWd,KAAX,GAAgB,KAAhB,GAAgB,CAAEN,OAAF,CAAhB,EAAyB,KAAzB;AACD;AAOD;;;;AAGA,OAAM,SAAU0B,OAAV,CACJpB,KADI,EAEJqB,MAFI,EAEqB;EAEzB,QAAQA,MAAM,CAACzB,IAAf;IACE,KAAKN,WAAL;MACE,OAAOS,gBAAgB,CAACC,KAAD,EAAQqB,MAAM,CAAC3B,OAAf,EAAwB2B,MAAM,CAAC1B,UAA/B,CAAvB;;IACF,KAAKJ,WAAL;MACE,OAAOS,KAAK,CAACC,MAAN,GAAeD,KAAK,CAACe,KAAN,CAAY,CAAZ,CAAf,GAAgCf,KAAvC;;IACF,KAAKR,WAAL;MACE,OAAOQ,KAAK,CAACC,MAAN,GAAe,EAAf,GAAoBD,KAA3B;;IACF;MACE,OAAOA,KAAP;EARJ;AAUD;AAeD;;;;;;;;;;AASA,OAAM,SAAUsB,eAAV,CAA4DpB,EAA5D,EAImB;MAHvBqB;MAAAC,OAAO,mBAAGpC,6BAAH,GAAgCmC;MACvCE;MAAA9B,UAAU,mBAAG,OAAH,GAAU8B;MACpBC;MAAAC,YAAY,mBAAG,EAAH,GAAKD;;EAEX,gBAAoB1C,UAAU,CAClC,UAACgB,KAAD,EAAQqB,MAAR,EAAc;IAAK,cAAO,CAAIrB,KAAJ,EAAWqB,MAAX,CAAP;EAAyB,CADV,EAElCM,YAFkC,CAA9B,EAGL,CAHK;EAAA,IAACC,KAAK,QAAN;EAAA,IAAQC,QAAQ,QAAhB;;EAIN,IAAMC,QAAQ,GAAG7C,MAAM,CAAC2C,KAAD,CAAvB;EAEA,IAAMG,kBAAkB,GAAGjD,WAAW,CACpC,UAACY,OAAD,EAAQ;IACN,IAAIC,UAAU,KAAK,OAAf,IAA0B,CAACD,OAAO,CAACa,SAAvC,EAAkD;MAChD,MAAM,IAAIyB,KAAJ,CACJ,6CAAqCrC,UAArC,EAA+C,kFAA/C,CADI,CAAN;IAGD;;IAEDkC,QAAQ,CAAC;MAAEjC,IAAI,EAAEN,WAAR;MAAqBI,OAAO,SAA5B;MAA8BC,UAAU;IAAxC,CAAD,CAAR;EACD,CATmC,EAUpC,CAACA,UAAD,CAVoC,CAAtC;EAaA,IAAMsC,kBAAkB,GAAGnD,WAAW,CAAa;IACjD+C,QAAQ,CAAChC,UAAU,EAAX,CAAR;EACD,CAFqC,EAEnC,EAFmC,CAAtC;EAIA,IAAMqC,kBAAkB,GAAGpD,WAAW,CAAgB;IACpD+C,QAAQ,CAAC/B,UAAU,EAAX,CAAR;IACA,OAAOgC,QAAQ,CAACb,OAAhB;EACD,CAHqC,EAGnC,EAHmC,CAAtC;;EAIM,gBAAsC9B,SAAS,CACnDwC,YAAY,CAAC1B,MAAb,GAAsB,CAD6B,CAA/C,EAEL,CAFK;EAAA,IAACkC,OAAO,QAAR;EAAA,IAAUC,WAAW,QAArB;EAAA,IAAuBC,WAAW,QAAlC;;EAGA,gBAAwCnD,UAAU,CACtDmD,WADsD,EAEtDb,OAFsD,CAAlD,EAGL,CAHK;EAAA,IAACc,UAAU,QAAX;EAAA,IAAaC,SAAS,QAAtB;EAAA,IAAwBC,YAAY,QAApC;;EAKNzD,SAAS,CAAC;IACR;IACA;IACM,gBAAyB6C,KAAzB,EAA8B,CAA9B;IAAA,IAAClC,OAAO,QAAR;IAAA,IAAU+C,WAAW,QAArB;;IACN,IAAI,CAAC/C,OAAL,EAAc;MACZ;IACD;;IAED,IAAMgD,SAAS,GAAGZ,QAAQ,CAACb,OAA3B;;IACM,gBAAgByB,SAAhB,EAAyB,CAAzB;IAAA,IAACC,WAAW,QAAZ;;IACN,IACEjD,OAAO,CAACS,eAAR,KAA4B,WAA5B,IACAsC,WADA,IAEAA,WAAW,CAACtC,eAAZ,KAAgC,WAHlC,EAIE;MACAoC,SAAS;;MACT,IAAI,CAACJ,OAAL,EAAc;QACZF,kBAAkB;QAClB;MACD;;MAEDI,WAAW;MACX;IACD;;IAED,IAAI,CAACF,OAAL,EAAc;MACZC,WAAW;IACZ;;IAED,IAAIR,KAAK,CAAC3B,MAAN,KAAiByC,SAAS,CAACzC,MAA3B,IAAqCP,OAAO,KAAKiD,WAArD,EAAkE;MAChEH,YAAY;IACb,CA/BO,CAiCR;IACA;;EACD,CAnCQ,EAmCN,CAACZ,KAAD,CAnCM,CAAT;EAqCAvC,kBAAkB,CAAC;IACjBiD,UAAU,YADO;IAEjBC,SAAS,WAFQ;IAGjBJ,OAAO,SAHU;IAIjBzC,OAAO,EAAEkC,KAAK,CAAC,CAAD;EAJG,CAAD,CAAlB;EAMA7C,SAAS,CAAC;IACR+C,QAAQ,CAACb,OAAT,GAAmBW,KAAnB;EACD,CAFQ,CAAT;EAIA,OAAO;IACLA,KAAK,OADA;IAEL9B,UAAU,EAAEoC,kBAFP;IAGLC,OAAO,SAHF;IAILE,WAAW,aAJN;IAKL5C,UAAU,EAAEsC,kBALP;IAMLlC,UAAU,EAAEoC,kBANP;IAOLK,UAAU,YAPL;IAQLC,SAAS,WARJ;IASLC,YAAY;EATP,CAAP;AAWD","names":["useCallback","useEffect","useReducer","useRef","useTimeout","useToggle","DEFAULT_MESSAGE_QUEUE_TIMEOUT","useWindowBlurPause","ADD_MESSAGE","POP_MESSAGE","RESET_QUEUE","addMessage","message","duplicates","type","popMessage","resetQueue","handleAddMessage","state","length","_a","messagePriority","i","findIndex","mes","messageId","isNext","isNormal","isReplace","isImmediate","isDuplicable","isRestart","nextState","slice","splice","current","remaining","__read","reducer","action","useMessageQueue","_b","timeout","_c","_d","defaultQueue","queue","dispatch","queueRef","addMessageDispatch","Error","popMessageDispatch","resetQueueDispatch","visible","showMessage","hideMessage","startTimer","stopTimer","restartTimer","nextMessage","prevQueue","prevMessage"],"sources":["C:\\Users\\hungr\\Documents\\VS-CODE\\notes-react\\node_modules\\@react-md\\alert\\src\\useMessageQueue.ts"],"sourcesContent":["import type { Reducer } from \"react\";\nimport { useCallback, useEffect, useReducer, useRef } from \"react\";\nimport { useTimeout, useToggle } from \"@react-md/utils\";\n\nimport type {\n  AddMessage,\n  DuplicateBehavior,\n  Message,\n  MessageQueueActions,\n  PopMessage,\n  ResetQueue,\n  ToastMessage,\n} from \"./MessageQueueContext\";\nimport { DEFAULT_MESSAGE_QUEUE_TIMEOUT } from \"./MessageQueueContext\";\nimport { useWindowBlurPause } from \"./useWindowBlurPause\";\n\nexport const ADD_MESSAGE = \"ADD_MESSAGE\";\nexport const POP_MESSAGE = \"POP_MESSAGE\";\nexport const RESET_QUEUE = \"RESET_QUEUE\";\n\n/**\n * @internal\n */\nexport interface AddMessageAction<M extends Message = ToastMessage> {\n  type: typeof ADD_MESSAGE;\n  message: M;\n  duplicates: DuplicateBehavior;\n}\n\n/**\n * @internal\n */\nexport function addMessage<M extends Message = ToastMessage>(\n  message: M,\n  duplicates: DuplicateBehavior\n): AddMessageAction {\n  return { type: ADD_MESSAGE, message, duplicates };\n}\n\n/**\n * @internal\n */\nexport interface PopMessageAction {\n  type: typeof POP_MESSAGE;\n}\n\n/**\n * @internal\n */\nexport const popMessage = (): PopMessageAction => ({ type: POP_MESSAGE });\n\n/**\n * @internal\n */\nexport interface ResetQueueAction {\n  type: typeof RESET_QUEUE;\n}\n\n/**\n * @internal\n */\nexport const resetQueue = (): ResetQueueAction => ({ type: RESET_QUEUE });\n\n/**\n * @internal\n */\nexport type MessageActions<M extends Message = ToastMessage> =\n  | AddMessageAction<M>\n  | PopMessageAction\n  | ResetQueueAction;\n\n/**\n * This function is used to update the message queue state by adding a new\n * message when needed.\n *\n * @internal\n */\nexport function handleAddMessage<M extends Message = ToastMessage>(\n  state: readonly M[],\n  message: M,\n  duplicates: DuplicateBehavior\n): readonly M[] {\n  if (state.length === 0) {\n    return [message];\n  }\n\n  const { messageId, messagePriority = \"normal\" } = message;\n  const i = state.findIndex((mes) => mes.messageId === messageId);\n  const isNext = messagePriority === \"next\";\n  const isNormal = messagePriority === \"normal\";\n  const isReplace = messagePriority === \"replace\";\n  const isImmediate = messagePriority === \"immediate\";\n  const isDuplicable = duplicates === \"allow\";\n  const isRestart = duplicates === \"restart\";\n  if (isNext || isImmediate) {\n    const nextState = state.slice();\n\n    // remove the existing message if duplicated messages aren't allowed. This\n    // will kind of act like a replace + next behavior\n    if (!isDuplicable && i > 0) {\n      nextState.splice(i, 1);\n    }\n\n    const [current, ...remaining] = nextState;\n    if (isImmediate && current.messagePriority !== \"immediate\") {\n      return [current, message, current, ...remaining];\n    }\n\n    return [current, message, ...remaining];\n  }\n\n  if (i === -1 || (isDuplicable && isNormal)) {\n    return [...state, message];\n  }\n\n  if (isNormal) {\n    if (isRestart) {\n      // creating a new state so that the queue visibility hook can still be\n      // triggered which will restart the timer\n      return state.slice();\n    }\n\n    return state;\n  }\n\n  if (isReplace) {\n    const nextState = state.slice();\n    nextState[i] = message;\n    return nextState;\n  }\n\n  return [...state, message];\n}\n\ntype MessageQueueReducer<M extends Message = ToastMessage> = Reducer<\n  readonly M[],\n  MessageActions<M>\n>;\n\n/**\n * @internal\n */\nexport function reducer<M extends Message = ToastMessage>(\n  state: readonly M[],\n  action: MessageActions<M>\n): readonly M[] {\n  switch (action.type) {\n    case ADD_MESSAGE:\n      return handleAddMessage(state, action.message, action.duplicates);\n    case POP_MESSAGE:\n      return state.length ? state.slice(1) : state;\n    case RESET_QUEUE:\n      return state.length ? [] : state;\n    default:\n      return state;\n  }\n}\n\nexport interface MessageQueueOptions<M extends Message = ToastMessage> {\n  timeout?: number;\n  duplicates?: DuplicateBehavior;\n  defaultQueue?: readonly M[];\n}\n\nexport interface MessageQueueResult<M extends Message = ToastMessage>\n  extends MessageQueueActions<M> {\n  queue: readonly M[];\n  visible: boolean;\n  addMessage: AddMessage<M>;\n}\n\n/**\n * This is the main logic for the message queue behavior that will handle:\n *\n * - creating timeouts as needed to show/hide toasts within the `SnackbarQueue`\n *   component\n * - create a way to push messages with optional priority onto the queue\n *\n * @internal\n */\nexport function useMessageQueue<M extends Message = ToastMessage>({\n  timeout = DEFAULT_MESSAGE_QUEUE_TIMEOUT,\n  duplicates = \"allow\",\n  defaultQueue = [],\n}: MessageQueueOptions<M>): MessageQueueResult<M> {\n  const [queue, dispatch] = useReducer<MessageQueueReducer<M>>(\n    (state, action) => reducer<M>(state, action),\n    defaultQueue\n  );\n  const queueRef = useRef(queue);\n\n  const addMessageDispatch = useCallback<AddMessage<M>>(\n    (message) => {\n      if (duplicates !== \"allow\" && !message.messageId) {\n        throw new Error(\n          `A messageId is required when the \"${duplicates}\" duplicate behavior is enabled but it was not provided in the current message.`\n        );\n      }\n\n      dispatch({ type: ADD_MESSAGE, message, duplicates });\n    },\n    [duplicates]\n  );\n\n  const popMessageDispatch = useCallback<PopMessage>(() => {\n    dispatch(popMessage());\n  }, []);\n\n  const resetQueueDispatch = useCallback<ResetQueue<M>>(() => {\n    dispatch(resetQueue());\n    return queueRef.current;\n  }, []);\n  const [visible, showMessage, hideMessage] = useToggle(\n    defaultQueue.length > 0\n  );\n  const [startTimer, stopTimer, restartTimer] = useTimeout(\n    hideMessage,\n    timeout\n  );\n\n  useEffect(() => {\n    // this effect will handle all the \"logic\" for transitioning between each\n    // message along with the message priority updates.\n    const [message, nextMessage] = queue;\n    if (!message) {\n      return;\n    }\n\n    const prevQueue = queueRef.current;\n    const [prevMessage] = prevQueue;\n    if (\n      message.messagePriority !== \"immediate\" &&\n      nextMessage &&\n      nextMessage.messagePriority === \"immediate\"\n    ) {\n      stopTimer();\n      if (!visible) {\n        popMessageDispatch();\n        return;\n      }\n\n      hideMessage();\n      return;\n    }\n\n    if (!visible) {\n      showMessage();\n    }\n\n    if (queue.length === prevQueue.length && message === prevMessage) {\n      restartTimer();\n    }\n\n    // only want to run this on queue changes\n    // eslint-disable-next-line react-hooks/exhaustive-deps\n  }, [queue]);\n\n  useWindowBlurPause({\n    startTimer,\n    stopTimer,\n    visible,\n    message: queue[0],\n  });\n  useEffect(() => {\n    queueRef.current = queue;\n  });\n\n  return {\n    queue,\n    resetQueue: resetQueueDispatch,\n    visible,\n    hideMessage,\n    addMessage: addMessageDispatch,\n    popMessage: popMessageDispatch,\n    startTimer,\n    stopTimer,\n    restartTimer,\n  };\n}\n"]},"metadata":{},"sourceType":"module"}