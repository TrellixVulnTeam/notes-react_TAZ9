{"ast":null,"code":"var __assign = this && this.__assign || function () {\n  __assign = Object.assign || function (t) {\n    for (var s, i = 1, n = arguments.length; i < n; i++) {\n      s = arguments[i];\n\n      for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p)) t[p] = s[p];\n    }\n\n    return t;\n  };\n\n  return __assign.apply(this, arguments);\n};\n\nvar __read = this && this.__read || function (o, n) {\n  var m = typeof Symbol === \"function\" && o[Symbol.iterator];\n  if (!m) return o;\n  var i = m.call(o),\n      r,\n      ar = [],\n      e;\n\n  try {\n    while ((n === void 0 || n-- > 0) && !(r = i.next()).done) ar.push(r.value);\n  } catch (error) {\n    e = {\n      error: error\n    };\n  } finally {\n    try {\n      if (r && !r.done && (m = i[\"return\"])) m.call(i);\n    } finally {\n      if (e) throw e.error;\n    }\n  }\n\n  return ar;\n};\n\nimport { useMemo } from \"react\";\n/**\n * This util performantly builds a nested list of tree items from a giant flat\n * list of items by linking items together with the provided `parentId`. This\n * will also recursively build the tree and _hopefully_ all items will be added.\n *\n * If there are no children for a specific item\n *\n * TODO: Add a dev-only warning/error if the tree is built, but there are some\n * items that never referenced another `itemId`\n *\n * @internal\n */\n\nexport function buildTree(parentId, items, sort) {\n  var childItems = []; // doing a \"reverse\" order filter/move so that the items array shrinks while\n  // looping. This makes it so that the entire items array doesn't need to\n  // continually be looped through as more items are added to the tree, only the\n  // remaining items will have to be looped\n\n  var i = items.length;\n\n  while (i > 0) {\n    i -= 1;\n\n    if (items[i] && items[i].parentId === parentId) {\n      var _a = __read(items.splice(i, 1), 1),\n          item = _a[0]; // shallow cloning so childItems doesn't get applied to the original data\n      // set\n\n\n      childItems.unshift(__assign({}, item));\n    }\n  }\n\n  if (!childItems.length) {\n    return undefined;\n  }\n\n  childItems.forEach(function (childItem) {\n    childItem.childItems = buildTree(childItem.itemId, items, sort);\n  });\n  return sort ? sort(childItems) : childItems;\n}\n/**\n * This is an internal hook that will create a renderable nested list view of\n * the tree data.\n *\n * @internal\n * @param tree - The full tree to convert to a nested list representation\n * @param sort - An optional function that sorts the items at each level\n * @param rootId - The starting `parentId` to use while building the tree. This\n * defaults to `null` since this is most likely the general use case, but if\n * there's a different unique identifier for the \"root level\" items, that can be\n * used instead.\n */\n\nexport function useNestedTreeList(tree, sort, rootId) {\n  if (rootId === void 0) {\n    rootId = null;\n  }\n\n  return useMemo(function () {\n    return buildTree(rootId, Object.values(tree), sort) || [];\n  }, [rootId, sort, tree]);\n}","map":{"version":3,"mappings":";;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AAAA,SAASA,OAAT,QAAwB,OAAxB;AAgBA;;;;;;;;;;;;;AAYA,OAAM,SAAUC,SAAV,CACJC,QADI,EAEJC,KAFI,EAGJC,IAHI,EAGoB;EAExB,IAAMC,UAAU,GAAwB,EAAxC,CAFwB,CAIxB;EACA;EACA;EACA;;EACA,IAAIC,CAAC,GAAGH,KAAK,CAACI,MAAd;;EACA,OAAOD,CAAC,GAAG,CAAX,EAAc;IACZA,CAAC,IAAI,CAAL;;IACA,IAAIH,KAAK,CAACG,CAAD,CAAL,IAAYH,KAAK,CAACG,CAAD,CAAL,CAASJ,QAAT,KAAsBA,QAAtC,EAAgD;MACxC,gBAASC,KAAK,CAACK,MAAN,CAAaF,CAAb,EAAgB,CAAhB,CAAT,EAA2B,CAA3B;MAAA,IAACG,IAAI,QAAL,CADwC,CAE9C;MACA;;;MACAJ,UAAU,CAACK,OAAX,CAAkBC,aAAMF,IAAN,CAAlB;IACD;EACF;;EAED,IAAI,CAACJ,UAAU,CAACE,MAAhB,EAAwB;IACtB,OAAOK,SAAP;EACD;;EAEDP,UAAU,CAACQ,OAAX,CAAmB,UAACC,SAAD,EAAU;IAC3BA,SAAS,CAACT,UAAV,GAAuBJ,SAAS,CAACa,SAAS,CAACC,MAAX,EAAmBZ,KAAnB,EAA0BC,IAA1B,CAAhC;EACD,CAFD;EAIA,OAAOA,IAAI,GAAGA,IAAI,CAACC,UAAD,CAAP,GAAsBA,UAAjC;AACD;AAED;;;;;;;;;;;;;AAYA,OAAM,SAAUW,iBAAV,CACJC,IADI,EAEJb,IAFI,EAGJc,MAHI,EAG4B;EAAhC;IAAAA;EAAgC;;EAEhC,OAAOlB,OAAO,CACZ;IAAM,gBAAS,CAACkB,MAAD,EAASC,MAAM,CAACC,MAAP,CAAcH,IAAd,CAAT,EAA8Bb,IAA9B,CAAT,IAAgD,EAAhD;EAAkD,CAD5C,EAEZ,CAACc,MAAD,EAASd,IAAT,EAAea,IAAf,CAFY,CAAd;AAID","names":["useMemo","buildTree","parentId","items","sort","childItems","i","length","splice","item","unshift","__assign","undefined","forEach","childItem","itemId","useNestedTreeList","tree","rootId","Object","values"],"sources":["C:\\Users\\hungr\\Documents\\VS-CODE\\notes-react\\node_modules\\@react-md\\tree\\src\\useNestedTreeList.ts"],"sourcesContent":["import { useMemo } from \"react\";\n\nimport type {\n  BaseTreeItem,\n  TreeData,\n  TreeItemId,\n  TreeItemSorter,\n} from \"./types\";\n\n/**\n * @internal\n */\nexport type NestedTreeItem<T extends BaseTreeItem> = T & {\n  childItems?: readonly NestedTreeItem<T>[];\n};\n\n/**\n * This util performantly builds a nested list of tree items from a giant flat\n * list of items by linking items together with the provided `parentId`. This\n * will also recursively build the tree and _hopefully_ all items will be added.\n *\n * If there are no children for a specific item\n *\n * TODO: Add a dev-only warning/error if the tree is built, but there are some\n * items that never referenced another `itemId`\n *\n * @internal\n */\nexport function buildTree<T extends BaseTreeItem>(\n  parentId: null | TreeItemId,\n  items: T[],\n  sort?: TreeItemSorter<T>\n): readonly NestedTreeItem<T>[] | undefined {\n  const childItems: NestedTreeItem<T>[] = [];\n\n  // doing a \"reverse\" order filter/move so that the items array shrinks while\n  // looping. This makes it so that the entire items array doesn't need to\n  // continually be looped through as more items are added to the tree, only the\n  // remaining items will have to be looped\n  let i = items.length;\n  while (i > 0) {\n    i -= 1;\n    if (items[i] && items[i].parentId === parentId) {\n      const [item] = items.splice(i, 1);\n      // shallow cloning so childItems doesn't get applied to the original data\n      // set\n      childItems.unshift({ ...item });\n    }\n  }\n\n  if (!childItems.length) {\n    return undefined;\n  }\n\n  childItems.forEach((childItem) => {\n    childItem.childItems = buildTree(childItem.itemId, items, sort);\n  });\n\n  return sort ? sort(childItems) : childItems;\n}\n\n/**\n * This is an internal hook that will create a renderable nested list view of\n * the tree data.\n *\n * @internal\n * @param tree - The full tree to convert to a nested list representation\n * @param sort - An optional function that sorts the items at each level\n * @param rootId - The starting `parentId` to use while building the tree. This\n * defaults to `null` since this is most likely the general use case, but if\n * there's a different unique identifier for the \"root level\" items, that can be\n * used instead.\n */\nexport function useNestedTreeList<T extends BaseTreeItem>(\n  tree: TreeData<T>,\n  sort?: TreeItemSorter<T>,\n  rootId: null | TreeItemId = null\n): readonly NestedTreeItem<T>[] {\n  return useMemo(\n    () => buildTree(rootId, Object.values(tree), sort) || [],\n    [rootId, sort, tree]\n  );\n}\n"]},"metadata":{},"sourceType":"module"}