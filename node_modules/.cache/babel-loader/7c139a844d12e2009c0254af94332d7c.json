{"ast":null,"code":"var __read = this && this.__read || function (o, n) {\n  var m = typeof Symbol === \"function\" && o[Symbol.iterator];\n  if (!m) return o;\n  var i = m.call(o),\n      r,\n      ar = [],\n      e;\n\n  try {\n    while ((n === void 0 || n-- > 0) && !(r = i.next()).done) ar.push(r.value);\n  } catch (error) {\n    e = {\n      error: error\n    };\n  } finally {\n    try {\n      if (r && !r.done && (m = i[\"return\"])) m.call(i);\n    } finally {\n      if (e) throw e.error;\n    }\n  }\n\n  return ar;\n};\n\nvar __spreadArray = this && this.__spreadArray || function (to, from, pack) {\n  if (pack || arguments.length === 2) for (var i = 0, l = from.length, ar; i < l; i++) {\n    if (ar || !(i in from)) {\n      if (!ar) ar = Array.prototype.slice.call(from, 0, i);\n      ar[i] = from[i];\n    }\n  }\n  return to.concat(ar || Array.prototype.slice.call(from));\n};\n\nimport { useMemo } from \"react\";\nimport { getTreeItemId } from \"./getTreeItemId\";\n\nfunction flatten(_a) {\n  var list = _a.list,\n      item = _a.item,\n      index = _a.index,\n      baseId = _a.baseId,\n      parentIndexes = _a.parentIndexes,\n      valueKey = _a.valueKey,\n      getItemValue = _a.getItemValue;\n\n  if (item.isCustom) {\n    return list;\n  }\n\n  var id = getTreeItemId(baseId, index, parentIndexes);\n  var value = getItemValue(item, valueKey);\n  var itemId = item.itemId,\n      parentId = item.parentId,\n      childItems = item.childItems;\n  list.push({\n    id: id,\n    itemId: itemId,\n    parentId: parentId,\n    isParent: !!childItems,\n    value: value\n  });\n\n  if (!childItems) {\n    return list;\n  }\n\n  var nextIndexes = __spreadArray(__spreadArray([], __read(parentIndexes), false), [index + 1], false);\n\n  childItems.forEach(function (child, childIndex) {\n    flatten({\n      list: list,\n      item: child,\n      index: childIndex,\n      valueKey: valueKey,\n      getItemValue: getItemValue,\n      baseId: baseId,\n      parentIndexes: nextIndexes\n    });\n  });\n  return list;\n}\n/**\n * Creates a flattened and ordered list of all the tree items that are current visible\n * in the DOM based on the expanded ids. This is only required for handling keyboard\n * navigation with `aria-activedescendant` movement so the items can be \"focused\" with\n * typeahead and keyboard movement since the keyboard movement API requires DOM refs\n * to be passed to each element.\n *\n * This flattened list will remove the `childItems` (if it existed) on each item for\n * simplicity and the child items aren't needed for this flattened list.\n *\n * @internal\n */\n\n\nexport function useFlattenedTreeList(_a) {\n  var id = _a.id,\n      items = _a.items,\n      rootId = _a.rootId,\n      expandedIds = _a.expandedIds,\n      valueKey = _a.valueKey,\n      getItemValue = _a.getItemValue;\n  var flattenedItems = useMemo(function () {\n    return items.reduce(function (list, item, index) {\n      return flatten({\n        list: list,\n        item: item,\n        index: index,\n        valueKey: valueKey,\n        getItemValue: getItemValue,\n        baseId: id,\n        parentIndexes: []\n      });\n    }, []);\n  }, [getItemValue, id, items, valueKey]);\n\n  var _b = useMemo(function () {\n    var index = 0;\n    return flattenedItems.reduce(function (collection, item) {\n      var _a, _b;\n\n      var parentId = item.parentId,\n          itemId = item.itemId;\n      var isVisible = parentId === rootId;\n\n      if (parentId !== null && expandedIds.includes(parentId)) {\n        // need to also make sure that the parent is visible\n        isVisible = ((_b = (_a = collection.itemRefs[parentId]) === null || _a === void 0 ? void 0 : _a.visibleIndex) !== null && _b !== void 0 ? _b : -1) !== -1;\n      }\n\n      collection.itemRefs[itemId] = {\n        id: item.id,\n        ref: {\n          current: null\n        },\n        visibleIndex: isVisible ? index : -1\n      };\n\n      if (isVisible) {\n        index += 1;\n        collection.visibleItems.push(item);\n      }\n\n      return collection;\n    }, {\n      visibleItems: [],\n      itemRefs: {}\n    });\n  }, [expandedIds, flattenedItems, rootId]),\n      visibleItems = _b.visibleItems,\n      itemRefs = _b.itemRefs;\n\n  return [visibleItems, itemRefs, flattenedItems];\n}","map":{"version":3,"mappings":"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","names":["useMemo","getTreeItemId","flatten","_a","list","item","index","baseId","parentIndexes","valueKey","getItemValue","isCustom","id","value","parentId","childItems","push","itemId","isParent","nextIndexes","forEach","child","childIndex","useFlattenedTreeList","items","rootId","expandedIds","flattenedItems","reduce","collection","isVisible","includes","itemRefs","visibleIndex","_b","ref","current","visibleItems"],"sources":["C:\\Users\\hungr\\Documents\\VS-CODE\\notes-react\\node_modules\\@react-md\\tree\\src\\useFlattenedTreeList.ts"],"sourcesContent":["import type { MutableRefObject } from \"react\";\nimport { useMemo } from \"react\";\n\nimport { getTreeItemId } from \"./getTreeItemId\";\nimport type {\n  ExpandedIds,\n  TreeItemId,\n  TreeProps,\n  UnknownTreeItem,\n} from \"./types\";\nimport type { NestedTreeItem } from \"./useNestedTreeList\";\n\nexport interface SearchableTreeItem {\n  /**\n   * A DOM Node `id` to use.\n   */\n  id: string;\n\n  /**\n   * A searchable value for the tree item.\n   */\n  value: string;\n\n  isParent: boolean;\n  itemId: TreeItemId;\n  parentId: TreeItemId | null;\n}\n\ntype TreeConfig = Required<\n  Pick<TreeProps<UnknownTreeItem>, \"valueKey\" | \"getItemValue\">\n>;\n\ninterface FlattenOptions extends TreeConfig {\n  list: SearchableTreeItem[];\n  item: NestedTreeItem<UnknownTreeItem>;\n  index: number;\n  baseId: string;\n  parentIndexes: number[];\n}\n\nfunction flatten({\n  list,\n  item,\n  index,\n  baseId,\n  parentIndexes,\n  valueKey,\n  getItemValue,\n}: FlattenOptions): SearchableTreeItem[] {\n  if (item.isCustom) {\n    return list;\n  }\n\n  const id = getTreeItemId(baseId, index, parentIndexes);\n  const value = getItemValue(item, valueKey);\n  const { itemId, parentId, childItems } = item;\n  list.push({\n    id,\n    itemId,\n    parentId,\n    isParent: !!childItems,\n    value,\n  });\n\n  if (!childItems) {\n    return list;\n  }\n\n  const nextIndexes = [...parentIndexes, index + 1];\n  childItems.forEach((child, childIndex) => {\n    flatten({\n      list,\n      item: child,\n      index: childIndex,\n      valueKey,\n      getItemValue,\n      baseId,\n      parentIndexes: nextIndexes,\n    });\n  });\n\n  return list;\n}\n\ninterface Options extends TreeConfig {\n  id: string;\n  items: readonly NestedTreeItem<UnknownTreeItem>[];\n  expandedIds: ExpandedIds;\n  rootId: TreeItemId | null;\n}\n\nexport type TreeItemRef = MutableRefObject<HTMLLIElement | null>;\nexport interface ItemMetadata {\n  id: string;\n  ref: TreeItemRef;\n  visibleIndex: number;\n}\n\nexport type MetadataRecord = Record<TreeItemId, ItemMetadata>;\n\ninterface ItemCollection {\n  itemRefs: MetadataRecord;\n  visibleItems: SearchableTreeItem[];\n}\n\ntype ReturnValue = [SearchableTreeItem[], MetadataRecord, SearchableTreeItem[]];\n\n/**\n * Creates a flattened and ordered list of all the tree items that are current visible\n * in the DOM based on the expanded ids. This is only required for handling keyboard\n * navigation with `aria-activedescendant` movement so the items can be \"focused\" with\n * typeahead and keyboard movement since the keyboard movement API requires DOM refs\n * to be passed to each element.\n *\n * This flattened list will remove the `childItems` (if it existed) on each item for\n * simplicity and the child items aren't needed for this flattened list.\n *\n * @internal\n */\nexport function useFlattenedTreeList({\n  id,\n  items,\n  rootId,\n  expandedIds,\n  valueKey,\n  getItemValue,\n}: Options): ReturnValue {\n  const flattenedItems = useMemo(\n    () =>\n      items.reduce<SearchableTreeItem[]>(\n        (list, item, index) =>\n          flatten({\n            list,\n            item,\n            index,\n            valueKey,\n            getItemValue,\n            baseId: id,\n            parentIndexes: [],\n          }),\n        []\n      ),\n    [getItemValue, id, items, valueKey]\n  );\n\n  const { visibleItems, itemRefs } = useMemo(() => {\n    let index = 0;\n    return flattenedItems.reduce<ItemCollection>(\n      (collection, item) => {\n        const { parentId, itemId } = item;\n        let isVisible = parentId === rootId;\n        if (parentId !== null && expandedIds.includes(parentId)) {\n          // need to also make sure that the parent is visible\n          isVisible =\n            (collection.itemRefs[parentId]?.visibleIndex ?? -1) !== -1;\n        }\n\n        collection.itemRefs[itemId] = {\n          id: item.id,\n          ref: { current: null },\n          visibleIndex: isVisible ? index : -1,\n        };\n        if (isVisible) {\n          index += 1;\n          collection.visibleItems.push(item);\n        }\n        return collection;\n      },\n      { visibleItems: [], itemRefs: {} }\n    );\n  }, [expandedIds, flattenedItems, rootId]);\n\n  return [visibleItems, itemRefs, flattenedItems];\n}\n"]},"metadata":{},"sourceType":"module"}