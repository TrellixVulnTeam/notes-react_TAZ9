{"ast":null,"code":"var __read = this && this.__read || function (o, n) {\n  var m = typeof Symbol === \"function\" && o[Symbol.iterator];\n  if (!m) return o;\n  var i = m.call(o),\n      r,\n      ar = [],\n      e;\n\n  try {\n    while ((n === void 0 || n-- > 0) && !(r = i.next()).done) ar.push(r.value);\n  } catch (error) {\n    e = {\n      error: error\n    };\n  } finally {\n    try {\n      if (r && !r.done && (m = i[\"return\"])) m.call(i);\n    } finally {\n      if (e) throw e.error;\n    }\n  }\n\n  return ar;\n};\n\nvar __spreadArray = this && this.__spreadArray || function (to, from, pack) {\n  if (pack || arguments.length === 2) for (var i = 0, l = from.length, ar; i < l; i++) {\n    if (ar || !(i in from)) {\n      if (!ar) ar = Array.prototype.slice.call(from, 0, i);\n      ar[i] = from[i];\n    }\n  }\n  return to.concat(ar || Array.prototype.slice.call(from));\n};\n/**\n * Creates a throttled version of a function so that it'll be called with\n * trailing and leading calls. Since I always get this confused with `debounce`,\n * here's a quick summary of the differences:\n *\n * - debounce will wait to call the function until it hasn't been called again\n *   for the wait duration without trailing or leading calls. If it has the\n *   trailing and leading calls, I can't figure out how it's different than\n *   throttle.\n * - throttle will be called each time it is available to be called.\n *\n * So debounce is great for things like auto-save features if you want to save\n * whenever the user stops typing for a few seconds while throttle is good for\n * things like sending an API request when the user is typing so that it isn't\n * sent every keystroke, but every few letters. You _could_ also do debounce\n * here, but it'll feel more \"responsive\" to the user when throttled.\n *\n * @param fn - The function that should be throttled\n * @param wait - The number of milliseconds to wait before calling the function\n * again\n * @returns a throttled version of the function that'll return the last computed\n * value if it was called again during the \"wait\" period.\n */\n\n\nexport function throttle(fn, wait) {\n  var lastCalledTime = 0;\n  var timeout;\n  var result;\n  var args;\n\n  function trailingCall() {\n    lastCalledTime = Date.now();\n    timeout = undefined;\n    result = fn.apply(void 0, __spreadArray([], __read(args), false));\n  }\n\n  return function throttled() {\n    var nextArgs = [];\n\n    for (var _i = 0; _i < arguments.length; _i++) {\n      nextArgs[_i] = arguments[_i];\n    }\n\n    args = nextArgs;\n    var now = Date.now();\n    var remaining = wait - (now - lastCalledTime);\n\n    if (remaining <= 0 || remaining > wait) {\n      lastCalledTime = now;\n      result = fn.apply(void 0, __spreadArray([], __read(args), false));\n    } else if (!timeout) {\n      timeout = window.setTimeout(trailingCall, remaining);\n    }\n\n    return result;\n  };\n}","map":{"version":3,"mappings":";;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AAcA;;;;;;;;;;;;;;;;;;;;;;;;;AAuBA,OAAM,SAAUA,QAAV,CACJC,EADI,EAEJC,IAFI,EAEQ;EAEZ,IAAIC,cAAc,GAAG,CAArB;EACA,IAAIC,OAAJ;EACA,IAAIC,MAAJ;EACA,IAAIC,IAAJ;;EAEA,SAASC,YAAT,GAAqB;IACnBJ,cAAc,GAAGK,IAAI,CAACC,GAAL,EAAjB;IACAL,OAAO,GAAGM,SAAV;IACAL,MAAM,GAAGJ,EAAE,MAAF,CAAE,MAAF,EAAEU,yBAAIL,IAAJ,GAAQ,KAAR,CAAF,CAAT;EACD;;EAED,OAAO,SAASM,SAAT,GAAkB;IAAC;;SAAA,yCAA0B;MAA1BC;;;IACxBP,IAAI,GAAGO,QAAP;IAEA,IAAMJ,GAAG,GAAGD,IAAI,CAACC,GAAL,EAAZ;IACA,IAAMK,SAAS,GAAGZ,IAAI,IAAIO,GAAG,GAAGN,cAAV,CAAtB;;IACA,IAAIW,SAAS,IAAI,CAAb,IAAkBA,SAAS,GAAGZ,IAAlC,EAAwC;MACtCC,cAAc,GAAGM,GAAjB;MACAJ,MAAM,GAAGJ,EAAE,MAAF,CAAE,MAAF,EAAEU,yBAAIL,IAAJ,GAAQ,KAAR,CAAF,CAAT;IACD,CAHD,MAGO,IAAI,CAACF,OAAL,EAAc;MACnBA,OAAO,GAAGW,MAAM,CAACC,UAAP,CAAkBT,YAAlB,EAAgCO,SAAhC,CAAV;IACD;;IAED,OAAOT,MAAP;EACD,CAbD;AAcD","names":["throttle","fn","wait","lastCalledTime","timeout","result","args","trailingCall","Date","now","undefined","__spreadArray","throttled","nextArgs","remaining","window","setTimeout"],"sources":["C:\\Users\\hungr\\Documents\\VS-CODE\\notes-react\\node_modules\\@react-md\\utils\\src\\throttle.ts"],"sourcesContent":["/* eslint-disable @typescript-eslint/no-explicit-any */\n/**\n * This is really the type definition for the Parameters type provided by TS,\n * but created a type alias to help with documentation.\n */\nexport type ThrottleableFunction = (...args: any[]) => any;\n\n/**\n * A strongly typed throttled version of a throttleable function.\n */\nexport type ThrottledFunction<F extends ThrottleableFunction> = (\n  ...args: Parameters<F>\n) => ReturnType<F>;\n\n/**\n * Creates a throttled version of a function so that it'll be called with\n * trailing and leading calls. Since I always get this confused with `debounce`,\n * here's a quick summary of the differences:\n *\n * - debounce will wait to call the function until it hasn't been called again\n *   for the wait duration without trailing or leading calls. If it has the\n *   trailing and leading calls, I can't figure out how it's different than\n *   throttle.\n * - throttle will be called each time it is available to be called.\n *\n * So debounce is great for things like auto-save features if you want to save\n * whenever the user stops typing for a few seconds while throttle is good for\n * things like sending an API request when the user is typing so that it isn't\n * sent every keystroke, but every few letters. You _could_ also do debounce\n * here, but it'll feel more \"responsive\" to the user when throttled.\n *\n * @param fn - The function that should be throttled\n * @param wait - The number of milliseconds to wait before calling the function\n * again\n * @returns a throttled version of the function that'll return the last computed\n * value if it was called again during the \"wait\" period.\n */\nexport function throttle<F extends ThrottleableFunction>(\n  fn: F,\n  wait: number\n): ThrottledFunction<F> {\n  let lastCalledTime = 0;\n  let timeout: number | undefined;\n  let result: ReturnType<F>;\n  let args: Parameters<F>;\n\n  function trailingCall(): void {\n    lastCalledTime = Date.now();\n    timeout = undefined;\n    result = fn(...args);\n  }\n\n  return function throttled(...nextArgs: Parameters<F>): ReturnType<F> {\n    args = nextArgs;\n\n    const now = Date.now();\n    const remaining = wait - (now - lastCalledTime);\n    if (remaining <= 0 || remaining > wait) {\n      lastCalledTime = now;\n      result = fn(...args);\n    } else if (!timeout) {\n      timeout = window.setTimeout(trailingCall, remaining);\n    }\n\n    return result;\n  };\n}\n"]},"metadata":{},"sourceType":"module"}