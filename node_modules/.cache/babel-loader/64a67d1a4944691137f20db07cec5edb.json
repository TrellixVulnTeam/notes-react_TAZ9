{"ast":null,"code":"var __assign = this && this.__assign || function () {\n  __assign = Object.assign || function (t) {\n    for (var s, i = 1, n = arguments.length; i < n; i++) {\n      s = arguments[i];\n\n      for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p)) t[p] = s[p];\n    }\n\n    return t;\n  };\n\n  return __assign.apply(this, arguments);\n};\n\nvar __read = this && this.__read || function (o, n) {\n  var m = typeof Symbol === \"function\" && o[Symbol.iterator];\n  if (!m) return o;\n  var i = m.call(o),\n      r,\n      ar = [],\n      e;\n\n  try {\n    while ((n === void 0 || n-- > 0) && !(r = i.next()).done) ar.push(r.value);\n  } catch (error) {\n    e = {\n      error: error\n    };\n  } finally {\n    try {\n      if (r && !r.done && (m = i[\"return\"])) m.call(i);\n    } finally {\n      if (e) throw e.error;\n    }\n  }\n\n  return ar;\n};\n\nvar __spreadArray = this && this.__spreadArray || function (to, from, pack) {\n  if (pack || arguments.length === 2) for (var i = 0, l = from.length, ar; i < l; i++) {\n    if (ar || !(i in from)) {\n      if (!ar) ar = Array.prototype.slice.call(from, 0, i);\n      ar[i] = from[i];\n    }\n  }\n  return to.concat(ar || Array.prototype.slice.call(from));\n};\n\nimport { useCallback, useReducer } from \"react\";\nimport { useRefCache } from \"@react-md/utils\";\nimport { createRippleState, getType, isBubbled, isRippleable } from \"./utils\";\nexport var CREATE = \"CREATE\";\nexport var CANCEL = \"CANCEL\";\nexport var RELEASE = \"RELEASE\";\nexport var ENTERED = \"ENTERED\";\nexport var REMOVE = \"REMOVE\";\n/**\n * This function will create a simplified version of the create event\n * that only includes the parts that are needed to trigger a ripple.\n * This is really only required since `event.persist()` crashed a lot\n * when spamming the trigger events and it threw warnings when not\n * persisting the event.\n */\n\nexport function createRippleAction(event, disableSpacebarClick) {\n  var _a = event,\n      type = _a.type,\n      target = _a.target,\n      currentTarget = _a.currentTarget,\n      touches = _a.touches,\n      pageX = _a.pageX,\n      pageY = _a.pageY,\n      button = _a.button,\n      key = _a.key;\n  return {\n    type: CREATE,\n    disableSpacebarClick: disableSpacebarClick,\n    event: {\n      type: type,\n      key: key,\n      target: target,\n      button: button,\n      currentTarget: currentTarget,\n      touches: touches,\n      pageX: pageX,\n      pageY: pageY\n    }\n  };\n}\n\nfunction createRipple(state, event, disableSpacebarClick) {\n  if (!isRippleable(event, disableSpacebarClick) || isBubbled(event)) {\n    return state;\n  }\n\n  if (state.find(function (r) {\n    return r.holding;\n  }) || getType(event) !== \"touch\" && state.find(function (r) {\n    return r.type === \"touch\";\n  })) {\n    // keyboard events are a bit different than the others since it is actually\n    // spammable since the space or enter key can be held down which triggers click\n    // events infinitely until they release. There's also the fun fact that mouse\n    // events are triggered after touch events, so we need to make sure duplicate\n    // ripples aren't created for these\n    return state;\n  }\n\n  var ripple = createRippleState(event);\n  return __spreadArray(__spreadArray([], __read(state), false), [ripple], false);\n}\n\nfunction enteredRipple(state, ripple) {\n  var i = state.findIndex(function (r) {\n    return r === ripple;\n  });\n\n  if (i === -1 || ripple.exiting) {\n    return state;\n  }\n\n  var nextState = state.slice();\n  var exiting = !ripple.holding || Date.now() - ripple.startTime > 300;\n  nextState[i] = __assign(__assign({}, ripple), {\n    exiting: exiting,\n    entered: true\n  });\n  return nextState;\n}\n\nfunction releaseRipple(state) {\n  var i = state.findIndex(function (r) {\n    return r.holding && !r.exiting;\n  });\n\n  if (i === -1) {\n    return state;\n  }\n\n  var ripple = state[i];\n  var exiting = ripple.entered || Date.now() - ripple.startTime > 300;\n  var nextState = state.slice();\n  nextState[i] = __assign(__assign({}, ripple), {\n    exiting: exiting,\n    holding: false\n  });\n  return nextState;\n}\n\nfunction removeRipple(state, ripple) {\n  var i = state.findIndex(function (r) {\n    return r.startTime === ripple.startTime;\n  });\n\n  if (i === -1) {\n    return state;\n  }\n\n  var nextState = state.slice();\n  nextState.splice(i, 1);\n  return nextState;\n}\n\nfunction cancelRipples(state, ease) {\n  if (ease) {\n    return state.map(function (r) {\n      return __assign(__assign({}, r), {\n        exiting: true,\n        mounted: true,\n        holding: false\n      });\n    });\n  }\n\n  return [];\n}\n\nexport function reducer(state, action) {\n  if (state === void 0) {\n    state = [];\n  }\n\n  switch (action.type) {\n    case CREATE:\n      return createRipple(state, action.event, action.disableSpacebarClick);\n\n    case RELEASE:\n      return releaseRipple(state);\n\n    case CANCEL:\n      return cancelRipples(state, action.ease);\n\n    case ENTERED:\n      return enteredRipple(state, action.ripple);\n\n    case REMOVE:\n      return removeRipple(state, action.ripple);\n\n    default:\n      return state;\n  }\n}\n/**\n * This hook creates memoized callbacks for each part of the ripple transition\n * as well as returning the current list of ripples.\n */\n\nexport function useRippleTransition(disableSpacebarClick) {\n  if (disableSpacebarClick === void 0) {\n    disableSpacebarClick = false;\n  }\n\n  var _a = __read(useReducer(reducer, []), 2),\n      state = _a[0],\n      dispatch = _a[1];\n\n  var spacebarRef = useRefCache(disableSpacebarClick);\n  var create = useCallback(function (event) {\n    var disableSpacebarClick = spacebarRef.current;\n    dispatch(createRippleAction(event, disableSpacebarClick)); // disabled since useRefCache\n    // eslint-disable-next-line react-hooks/exhaustive-deps\n  }, []);\n  var release = useCallback(function (event) {\n    dispatch({\n      type: RELEASE,\n      event: event\n    });\n  }, []);\n  var entered = useCallback(function (ripple) {\n    dispatch({\n      type: ENTERED,\n      ripple: ripple\n    });\n  }, []);\n  var cancel = useCallback(function (ease) {\n    if (ease === void 0) {\n      ease = false;\n    }\n\n    dispatch({\n      type: CANCEL,\n      ease: ease\n    });\n  }, []);\n  var remove = useCallback(function (ripple) {\n    dispatch({\n      type: REMOVE,\n      ripple: ripple\n    });\n  }, []);\n  return {\n    state: state,\n    create: create,\n    release: release,\n    entered: entered,\n    remove: remove,\n    cancel: cancel\n  };\n}","map":{"version":3,"mappings":"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","names":["useCallback","useReducer","useRefCache","createRippleState","getType","isBubbled","isRippleable","CREATE","CANCEL","RELEASE","ENTERED","REMOVE","createRippleAction","event","disableSpacebarClick","type","target","currentTarget","touches","pageX","pageY","button","key","createRipple","state","find","r","holding","ripple","enteredRipple","i","findIndex","exiting","nextState","slice","Date","now","startTime","__assign","entered","releaseRipple","removeRipple","splice","cancelRipples","ease","map","mounted","reducer","action","useRippleTransition","dispatch","spacebarRef","create","current","release","cancel","remove"],"sources":["C:\\Users\\hungr\\Documents\\VS-CODE\\notes-react\\node_modules\\@react-md\\states\\src\\ripples\\reducer.ts"],"sourcesContent":["import type { Reducer } from \"react\";\nimport { useCallback, useReducer } from \"react\";\nimport { useRefCache } from \"@react-md/utils\";\n\nimport type { RippleEvent, RipplesState, RippleState } from \"./types\";\nimport { createRippleState, getType, isBubbled, isRippleable } from \"./utils\";\n\nexport const CREATE = \"CREATE\";\nexport const CANCEL = \"CANCEL\";\nexport const RELEASE = \"RELEASE\";\nexport const ENTERED = \"ENTERED\";\nexport const REMOVE = \"REMOVE\";\n\nexport interface CreateAction<E extends HTMLElement> {\n  type: typeof CREATE;\n  event: RippleEvent<E>;\n  disableSpacebarClick: boolean;\n}\nexport interface ReleaseAction<E extends HTMLElement> {\n  type: typeof RELEASE;\n  event: RippleEvent<E>;\n}\nexport interface EnteredAction {\n  type: typeof ENTERED;\n  ripple: RippleState;\n}\nexport interface RemoveAction {\n  type: typeof REMOVE;\n  ripple: RippleState;\n}\n\nexport interface CancelAction {\n  type: typeof CANCEL;\n  ease: boolean;\n}\ntype RippleStateAction<E extends HTMLElement> =\n  | CreateAction<E>\n  | ReleaseAction<E>\n  | CancelAction\n  | EnteredAction\n  | RemoveAction;\ntype RippleStateReducer<E extends HTMLElement> = Reducer<\n  RipplesState,\n  RippleStateAction<E>\n>;\n\n/**\n * This function will create a simplified version of the create event\n * that only includes the parts that are needed to trigger a ripple.\n * This is really only required since `event.persist()` crashed a lot\n * when spamming the trigger events and it threw warnings when not\n * persisting the event.\n */\nexport function createRippleAction<E extends HTMLElement>(\n  event: RippleEvent<E>,\n  disableSpacebarClick: boolean\n): CreateAction<E> {\n  const { type, target, currentTarget, touches, pageX, pageY, button, key } =\n    event as React.MouseEvent<E> & React.TouchEvent<E> & React.KeyboardEvent<E>;\n\n  return {\n    type: CREATE,\n    disableSpacebarClick,\n    event: {\n      type,\n      key,\n      target,\n      button,\n      currentTarget,\n      touches,\n      pageX,\n      pageY,\n    },\n  };\n}\n\nfunction createRipple(\n  state: RipplesState,\n  event: RippleEvent<HTMLElement>,\n  disableSpacebarClick: boolean\n): RipplesState {\n  if (!isRippleable(event, disableSpacebarClick) || isBubbled(event)) {\n    return state;\n  }\n\n  if (\n    state.find((r) => r.holding) ||\n    (getType(event) !== \"touch\" && state.find((r) => r.type === \"touch\"))\n  ) {\n    // keyboard events are a bit different than the others since it is actually\n    // spammable since the space or enter key can be held down which triggers click\n    // events infinitely until they release. There's also the fun fact that mouse\n    // events are triggered after touch events, so we need to make sure duplicate\n    // ripples aren't created for these\n    return state;\n  }\n\n  const ripple = createRippleState(event);\n  return [...state, ripple];\n}\n\nfunction enteredRipple(state: RipplesState, ripple: RippleState): RipplesState {\n  const i = state.findIndex((r) => r === ripple);\n  if (i === -1 || ripple.exiting) {\n    return state;\n  }\n\n  const nextState = state.slice();\n  const exiting = !ripple.holding || Date.now() - ripple.startTime > 300;\n  nextState[i] = {\n    ...ripple,\n    exiting,\n    entered: true,\n  };\n  return nextState;\n}\n\nfunction releaseRipple(state: RipplesState): RipplesState {\n  const i = state.findIndex((r) => r.holding && !r.exiting);\n  if (i === -1) {\n    return state;\n  }\n\n  const ripple = state[i];\n  const exiting = ripple.entered || Date.now() - ripple.startTime > 300;\n  const nextState = state.slice();\n  nextState[i] = {\n    ...ripple,\n    exiting,\n    holding: false,\n  };\n  return nextState;\n}\n\nfunction removeRipple(state: RipplesState, ripple: RippleState): RipplesState {\n  const i = state.findIndex((r) => r.startTime === ripple.startTime);\n  if (i === -1) {\n    return state;\n  }\n\n  const nextState = state.slice();\n  nextState.splice(i, 1);\n  return nextState;\n}\n\nfunction cancelRipples(state: RipplesState, ease: boolean): RipplesState {\n  if (ease) {\n    return state.map((r) => ({\n      ...r,\n      exiting: true,\n      mounted: true,\n      holding: false,\n    }));\n  }\n\n  return [];\n}\n\nexport function reducer<E extends HTMLElement>(\n  state: RipplesState = [],\n  action: RippleStateAction<E>\n): RipplesState {\n  switch (action.type) {\n    case CREATE:\n      return createRipple(state, action.event, action.disableSpacebarClick);\n    case RELEASE:\n      return releaseRipple(state);\n    case CANCEL:\n      return cancelRipples(state, action.ease);\n    case ENTERED:\n      return enteredRipple(state, action.ripple);\n    case REMOVE:\n      return removeRipple(state, action.ripple);\n    default:\n      return state;\n  }\n}\n\ninterface ReturnValue<E extends HTMLElement> {\n  state: RipplesState;\n  create: (event: RippleEvent<E>) => void;\n  release: (event: RippleEvent<E>) => void;\n  entered: (ripple: RippleState) => void;\n  cancel: (ease?: boolean) => void;\n  remove: (ripple: RippleState) => void;\n}\n\n/**\n * This hook creates memoized callbacks for each part of the ripple transition\n * as well as returning the current list of ripples.\n */\nexport function useRippleTransition<E extends HTMLElement = HTMLElement>(\n  disableSpacebarClick = false\n): ReturnValue<E> {\n  const [state, dispatch] = useReducer<RippleStateReducer<E>>(reducer, []);\n  const spacebarRef = useRefCache(disableSpacebarClick);\n  const create = useCallback((event: RippleEvent<E>) => {\n    const disableSpacebarClick = spacebarRef.current;\n    dispatch(createRippleAction(event, disableSpacebarClick));\n    // disabled since useRefCache\n    // eslint-disable-next-line react-hooks/exhaustive-deps\n  }, []);\n  const release = useCallback((event: RippleEvent<E>) => {\n    dispatch({ type: RELEASE, event });\n  }, []);\n  const entered = useCallback((ripple: RippleState) => {\n    dispatch({ type: ENTERED, ripple });\n  }, []);\n  const cancel = useCallback((ease = false) => {\n    dispatch({ type: CANCEL, ease });\n  }, []);\n  const remove = useCallback((ripple: RippleState) => {\n    dispatch({ type: REMOVE, ripple });\n  }, []);\n\n  return { state, create, release, entered, remove, cancel };\n}\n"]},"metadata":{},"sourceType":"module"}