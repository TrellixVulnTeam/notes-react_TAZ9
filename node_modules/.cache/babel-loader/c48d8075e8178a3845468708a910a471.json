{"ast":null,"code":"import { findSizingContainer } from \"@react-md/utils\";\n/**\n * Checks if the ripple event should be ignored since it was bubbled\n * up from a child treeitem. I should find a better way to handle\n * this at some point.\n */\n\nexport function isBubbled(event) {\n  return Array.from(event.currentTarget.querySelectorAll('[role=\"treeitem\"]')).some(function (item) {\n    return item.contains(event.target);\n  });\n}\n/**\n * Gets the ripple event type based on the provided event.\n */\n\nexport function getType(event) {\n  switch (event.type) {\n    case \"mousedown\":\n    case \"mouseup\":\n    case \"mouseleave\":\n      return \"mouse\";\n\n    case \"touchstart\":\n    case \"touchmove\":\n    case \"touchend\":\n      return \"touch\";\n\n    case \"keydown\":\n    case \"keyup\":\n      return \"keyboard\";\n\n    default:\n      return \"programmatic\";\n  }\n}\n/**\n * Checks if the provided event type is actually rippleable by ensuring:\n * - it is a mousedown event while not in touch mode and the left mouse was\n *   clicked.\n * - it was a keydown event for either tab or space when spacebar clicks have not\n *   been disabled\n * - it was a touchstart event\n */\n\nexport function isRippleable(event, disableSpacebarClick) {\n  switch (event.type) {\n    case \"mousedown\":\n      return document.querySelector(\".rmd-states--touch\") === null && event.button === 0;\n\n    case \"keydown\":\n      return !disableSpacebarClick && event.key === \" \" || event.key === \"Enter\" && !/checkbox|radio/i.test(event.currentTarget.getAttribute(\"type\") || \"\");\n\n    case \"touchstart\":\n    case \"click\":\n      return true;\n\n    default:\n      return false;\n  }\n}\n\nfunction calcHypotenuse(a, b) {\n  return Math.sqrt(a * a + b * b);\n}\n/**\n * Gets the current radius for a ripple based on the x and y page dimensions\n * as well as the size of the element.\n *\n * This is really just in a separate file so I can easily mock this and write\n * tests.\n */\n\n\nfunction getRadius(x, y, offsetWidth, offsetHeight) {\n  return Math.max(calcHypotenuse(x, y), calcHypotenuse(offsetWidth - x, y), calcHypotenuse(offsetWidth - x, offsetHeight - y), calcHypotenuse(x, offsetHeight - y));\n}\n/**\n * Gets the ripple creation origin base on the provided event. When the event\n * type is for keyboards or triggered programmatically, the origin will\n * be the center of the target element. When the event is for touch or mouse,\n * the origin will be the location within the viewport where the user touched\n * or clicked the target element.\n */\n\n\nexport function getOrigin(event, element) {\n  var _a;\n\n  var type = getType(event);\n  var offsetWidth = element.offsetWidth,\n      offsetHeight = element.offsetHeight;\n  var x;\n  var y;\n\n  if (type === \"programmatic\" || type === \"keyboard\") {\n    x = offsetWidth / 2;\n    y = offsetHeight / 2;\n  } else {\n    // if the event type is not programmatic, want to figure out exactly where in\n    // the element to trigger the animation from. this can be determined by:\n    // - getting the pageX and pageY of the mouse or touch event\n    // - getting element's current position in the page\n    var pageX = void 0;\n    var pageY = void 0;\n\n    if (type === \"mouse\") {\n      _a = event, pageX = _a.pageX, pageY = _a.pageY;\n    } else {\n      var touch = event.touches.item(0);\n      pageX = touch.pageX, pageY = touch.pageY;\n    }\n\n    var rect = element.getBoundingClientRect(); // have to include the current page's scroll offset to the element's\n    // bounding rect since the pageX and pageY from Events include the scroll\n    // offset while the bounding rect is only based on viewport.\n\n    x = pageX - (rect.left + window.pageXOffset);\n    y = pageY - (rect.top + window.pageYOffset);\n  }\n\n  return {\n    x: x,\n    y: y\n  };\n}\n/**\n * Creates a new ripple state based off the provided event type.\n */\n\nexport function createRippleState(event) {\n  var element = findSizingContainer(event.currentTarget) || event.currentTarget;\n  var offsetWidth = element.offsetWidth,\n      offsetHeight = element.offsetHeight;\n  var type = getType(event);\n\n  var _a = getOrigin(event, element),\n      x = _a.x,\n      y = _a.y;\n\n  var radius = getRadius(x, y, offsetWidth, offsetHeight);\n  var size = radius * 2;\n  return {\n    startTime: Date.now(),\n    style: {\n      left: x - radius,\n      top: y - radius,\n      height: size,\n      width: size\n    },\n    type: type,\n    holding: type !== \"programmatic\",\n    exiting: false,\n    entered: false\n  };\n}","map":{"version":3,"mappings":"AAAA,SAASA,mBAAT,QAAoC,iBAApC;AAIA;;;;;;AAKA,OAAM,SAAUC,SAAV,CACJC,KADI,EACmD;EAEvD,OAAOC,KAAK,CAACC,IAAN,CACLF,KAAK,CAACG,aAAN,CAAoBC,gBAApB,CAAqC,mBAArC,CADK,EAELC,IAFK,CAEA,UAACC,IAAD,EAAK;IAAK,WAAI,CAACC,QAAL,CAAcP,KAAK,CAACQ,MAApB;EAA0C,CAFpD,CAAP;AAGD;AAED;;;;AAGA,OAAM,SAAUC,OAAV,CACJT,KADI,EACyC;EAE7C,QAAQA,KAAK,CAACU,IAAd;IACE,KAAK,WAAL;IACA,KAAK,SAAL;IACA,KAAK,YAAL;MACE,OAAO,OAAP;;IACF,KAAK,YAAL;IACA,KAAK,WAAL;IACA,KAAK,UAAL;MACE,OAAO,OAAP;;IACF,KAAK,SAAL;IACA,KAAK,OAAL;MACE,OAAO,UAAP;;IACF;MACE,OAAO,cAAP;EAbJ;AAeD;AAED;;;;;;;;;AAQA,OAAM,SAAUC,YAAV,CACJX,KADI,EAEJY,oBAFI,EAEyB;EAE7B,QAAQZ,KAAK,CAACU,IAAd;IACE,KAAK,WAAL;MACE,OACEG,QAAQ,CAACC,aAAT,CAAuB,oBAAvB,MAAiD,IAAjD,IACAd,KAAK,CAACe,MAAN,KAAiB,CAFnB;;IAIF,KAAK,SAAL;MACE,OACG,CAACH,oBAAD,IAAyBZ,KAAK,CAACgB,GAAN,KAAc,GAAxC,IACChB,KAAK,CAACgB,GAAN,KAAc,OAAd,IACC,CAAC,kBAAkBC,IAAlB,CACCjB,KAAK,CAACG,aAAN,CAAoBe,YAApB,CAAiC,MAAjC,KAA4C,EAD7C,CAHL;;IAOF,KAAK,YAAL;IACA,KAAK,OAAL;MACE,OAAO,IAAP;;IACF;MACE,OAAO,KAAP;EAlBJ;AAoBD;;AAED,SAASC,cAAT,CAAwBC,CAAxB,EAAmCC,CAAnC,EAA4C;EAC1C,OAAOC,IAAI,CAACC,IAAL,CAAUH,CAAC,GAAGA,CAAJ,GAAQC,CAAC,GAAGA,CAAtB,CAAP;AACD;AAED;;;;;;;;;AAOA,SAASG,SAAT,CACEC,CADF,EAEEC,CAFF,EAGEC,WAHF,EAIEC,YAJF,EAIsB;EAEpB,OAAON,IAAI,CAACO,GAAL,CACLV,cAAc,CAACM,CAAD,EAAIC,CAAJ,CADT,EAELP,cAAc,CAACQ,WAAW,GAAGF,CAAf,EAAkBC,CAAlB,CAFT,EAGLP,cAAc,CAACQ,WAAW,GAAGF,CAAf,EAAkBG,YAAY,GAAGF,CAAjC,CAHT,EAILP,cAAc,CAACM,CAAD,EAAIG,YAAY,GAAGF,CAAnB,CAJT,CAAP;AAMD;AAOD;;;;;;;;;AAOA,OAAM,SAAUI,SAAV,CACJ9B,KADI,EAEJ+B,OAFI,EAEgB;;;EAEpB,IAAMrB,IAAI,GAAGD,OAAO,CAACT,KAAD,CAApB;EACQ,eAAW,GAAmB+B,OAAO,YAArC;EAAA,IAAaH,YAAY,GAAKG,OAAO,aAArC;EAER,IAAIN,CAAJ;EACA,IAAIC,CAAJ;;EACA,IAAIhB,IAAI,KAAK,cAAT,IAA2BA,IAAI,KAAK,UAAxC,EAAoD;IAClDe,CAAC,GAAGE,WAAW,GAAG,CAAlB;IACAD,CAAC,GAAGE,YAAY,GAAG,CAAnB;EACD,CAHD,MAGO;IACL;IACA;IACA;IACA;IAEA,IAAII,KAAK,SAAT;IACA,IAAIC,KAAK,SAAT;;IACA,IAAIvB,IAAI,KAAK,OAAb,EAAsB;MACnBwB,KAAmBlC,KAAnB,EAAEgC,KAAK,WAAP,EAASC,KAAK,WAAf;IACD,CAFD,MAEO;MACL,IAAME,KAAK,GAAInC,KAAuC,CAACoC,OAAxC,CAAgD9B,IAAhD,CAAqD,CAArD,CAAf;MACG0B,KAAK,GAAYG,KAAK,MAAtB,EAAOF,KAAK,GAAKE,KAAK,MAAzB;IACD;;IAED,IAAME,IAAI,GAAGN,OAAO,CAACO,qBAAR,EAAb,CAfK,CAgBL;IACA;IACA;;IACAb,CAAC,GAAGO,KAAK,IAAIK,IAAI,CAACE,IAAL,GAAYC,MAAM,CAACC,WAAvB,CAAT;IACAf,CAAC,GAAGO,KAAK,IAAII,IAAI,CAACK,GAAL,GAAWF,MAAM,CAACG,WAAtB,CAAT;EACD;;EAED,OAAO;IAAElB,CAAC,GAAH;IAAKC,CAAC;EAAN,CAAP;AACD;AAED;;;;AAGA,OAAM,SAAUkB,iBAAV,CACJ5C,KADI,EAC2B;EAE/B,IAAM+B,OAAO,GACXjC,mBAAmB,CAACE,KAAK,CAACG,aAAP,CAAnB,IAA4CH,KAAK,CAACG,aADpD;EAEQ,eAAW,GAAmB4B,OAAO,YAArC;EAAA,IAAaH,YAAY,GAAKG,OAAO,aAArC;EACR,IAAMrB,IAAI,GAAGD,OAAO,CAACT,KAAD,CAApB;;EACM,SAAW8B,SAAS,CAAC9B,KAAD,EAAQ+B,OAAR,CAApB;EAAA,IAAEN,CAAC,OAAH;EAAA,IAAKC,CAAC,OAAN;;EAEN,IAAMmB,MAAM,GAAGrB,SAAS,CAACC,CAAD,EAAIC,CAAJ,EAAOC,WAAP,EAAoBC,YAApB,CAAxB;EACA,IAAMkB,IAAI,GAAGD,MAAM,GAAG,CAAtB;EACA,OAAO;IACLE,SAAS,EAAEC,IAAI,CAACC,GAAL,EADN;IAELC,KAAK,EAAE;MACLX,IAAI,EAAEd,CAAC,GAAGoB,MADL;MAELH,GAAG,EAAEhB,CAAC,GAAGmB,MAFJ;MAGLM,MAAM,EAAEL,IAHH;MAILM,KAAK,EAAEN;IAJF,CAFF;IAQLpC,IAAI,MARC;IASL2C,OAAO,EAAE3C,IAAI,KAAK,cATb;IAUL4C,OAAO,EAAE,KAVJ;IAWLC,OAAO,EAAE;EAXJ,CAAP;AAaD","names":["findSizingContainer","isBubbled","event","Array","from","currentTarget","querySelectorAll","some","item","contains","target","getType","type","isRippleable","disableSpacebarClick","document","querySelector","button","key","test","getAttribute","calcHypotenuse","a","b","Math","sqrt","getRadius","x","y","offsetWidth","offsetHeight","max","getOrigin","element","pageX","pageY","_a","touch","touches","rect","getBoundingClientRect","left","window","pageXOffset","top","pageYOffset","createRippleState","radius","size","startTime","Date","now","style","height","width","holding","exiting","entered"],"sources":["C:\\Users\\hungr\\Documents\\VS-CODE\\notes-react\\node_modules\\@react-md\\states\\src\\ripples\\utils.ts"],"sourcesContent":["import { findSizingContainer } from \"@react-md/utils\";\n\nimport type { RippleEvent, RippleState, RippleType } from \"./types\";\n\n/**\n * Checks if the ripple event should be ignored since it was bubbled\n * up from a child treeitem. I should find a better way to handle\n * this at some point.\n */\nexport function isBubbled<E extends HTMLElement>(\n  event: Pick<RippleEvent<E>, \"currentTarget\" | \"target\">\n): boolean {\n  return Array.from(\n    event.currentTarget.querySelectorAll('[role=\"treeitem\"]')\n  ).some((item) => item.contains(event.target as HTMLElement));\n}\n\n/**\n * Gets the ripple event type based on the provided event.\n */\nexport function getType(\n  event: Pick<RippleEvent<HTMLElement>, \"type\">\n): RippleType {\n  switch (event.type) {\n    case \"mousedown\":\n    case \"mouseup\":\n    case \"mouseleave\":\n      return \"mouse\";\n    case \"touchstart\":\n    case \"touchmove\":\n    case \"touchend\":\n      return \"touch\";\n    case \"keydown\":\n    case \"keyup\":\n      return \"keyboard\";\n    default:\n      return \"programmatic\";\n  }\n}\n\n/**\n * Checks if the provided event type is actually rippleable by ensuring:\n * - it is a mousedown event while not in touch mode and the left mouse was\n *   clicked.\n * - it was a keydown event for either tab or space when spacebar clicks have not\n *   been disabled\n * - it was a touchstart event\n */\nexport function isRippleable(\n  event: RippleEvent<HTMLElement>,\n  disableSpacebarClick: boolean\n): boolean {\n  switch (event.type) {\n    case \"mousedown\":\n      return (\n        document.querySelector(\".rmd-states--touch\") === null &&\n        event.button === 0\n      );\n    case \"keydown\":\n      return (\n        (!disableSpacebarClick && event.key === \" \") ||\n        (event.key === \"Enter\" &&\n          !/checkbox|radio/i.test(\n            event.currentTarget.getAttribute(\"type\") || \"\"\n          ))\n      );\n    case \"touchstart\":\n    case \"click\":\n      return true;\n    default:\n      return false;\n  }\n}\n\nfunction calcHypotenuse(a: number, b: number): number {\n  return Math.sqrt(a * a + b * b);\n}\n\n/**\n * Gets the current radius for a ripple based on the x and y page dimensions\n * as well as the size of the element.\n *\n * This is really just in a separate file so I can easily mock this and write\n * tests.\n */\nfunction getRadius(\n  x: number,\n  y: number,\n  offsetWidth: number,\n  offsetHeight: number\n): number {\n  return Math.max(\n    calcHypotenuse(x, y),\n    calcHypotenuse(offsetWidth - x, y),\n    calcHypotenuse(offsetWidth - x, offsetHeight - y),\n    calcHypotenuse(x, offsetHeight - y)\n  );\n}\n\ninterface Origin {\n  x: number;\n  y: number;\n}\n\n/**\n * Gets the ripple creation origin base on the provided event. When the event\n * type is for keyboards or triggered programmatically, the origin will\n * be the center of the target element. When the event is for touch or mouse,\n * the origin will be the location within the viewport where the user touched\n * or clicked the target element.\n */\nexport function getOrigin(\n  event: Pick<RippleEvent<HTMLElement>, \"pageX\" | \"pageY\" | \"touches\" | \"type\">,\n  element: HTMLElement\n): Origin {\n  const type = getType(event);\n  const { offsetWidth, offsetHeight } = element;\n\n  let x: number;\n  let y: number;\n  if (type === \"programmatic\" || type === \"keyboard\") {\n    x = offsetWidth / 2;\n    y = offsetHeight / 2;\n  } else {\n    // if the event type is not programmatic, want to figure out exactly where in\n    // the element to trigger the animation from. this can be determined by:\n    // - getting the pageX and pageY of the mouse or touch event\n    // - getting element's current position in the page\n\n    let pageX;\n    let pageY;\n    if (type === \"mouse\") {\n      ({ pageX, pageY } = event as React.MouseEvent<HTMLElement>);\n    } else {\n      const touch = (event as React.TouchEvent<HTMLElement>).touches.item(0);\n      ({ pageX, pageY } = touch);\n    }\n\n    const rect = element.getBoundingClientRect();\n    // have to include the current page's scroll offset to the element's\n    // bounding rect since the pageX and pageY from Events include the scroll\n    // offset while the bounding rect is only based on viewport.\n    x = pageX - (rect.left + window.pageXOffset);\n    y = pageY - (rect.top + window.pageYOffset);\n  }\n\n  return { x, y };\n}\n\n/**\n * Creates a new ripple state based off the provided event type.\n */\nexport function createRippleState(\n  event: RippleEvent<HTMLElement>\n): RippleState {\n  const element =\n    findSizingContainer(event.currentTarget) || event.currentTarget;\n  const { offsetWidth, offsetHeight } = element;\n  const type = getType(event);\n  const { x, y } = getOrigin(event, element);\n\n  const radius = getRadius(x, y, offsetWidth, offsetHeight);\n  const size = radius * 2;\n  return {\n    startTime: Date.now(),\n    style: {\n      left: x - radius,\n      top: y - radius,\n      height: size,\n      width: size,\n    },\n    type,\n    holding: type !== \"programmatic\",\n    exiting: false,\n    entered: false,\n  };\n}\n"]},"metadata":{},"sourceType":"module"}