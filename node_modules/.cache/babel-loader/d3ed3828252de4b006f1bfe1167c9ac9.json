{"ast":null,"code":"var __assign = this && this.__assign || function () {\n  __assign = Object.assign || function (t) {\n    for (var s, i = 1, n = arguments.length; i < n; i++) {\n      s = arguments[i];\n\n      for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p)) t[p] = s[p];\n    }\n\n    return t;\n  };\n\n  return __assign.apply(this, arguments);\n};\n\nvar __rest = this && this.__rest || function (s, e) {\n  var t = {};\n\n  for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0) t[p] = s[p];\n\n  if (s != null && typeof Object.getOwnPropertySymbols === \"function\") for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {\n    if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i])) t[p[i]] = s[p[i]];\n  }\n  return t;\n};\n\nvar __read = this && this.__read || function (o, n) {\n  var m = typeof Symbol === \"function\" && o[Symbol.iterator];\n  if (!m) return o;\n  var i = m.call(o),\n      r,\n      ar = [],\n      e;\n\n  try {\n    while ((n === void 0 || n-- > 0) && !(r = i.next()).done) ar.push(r.value);\n  } catch (error) {\n    e = {\n      error: error\n    };\n  } finally {\n    try {\n      if (r && !r.done && (m = i[\"return\"])) m.call(i);\n    } finally {\n      if (e) throw e.error;\n    }\n  }\n\n  return ar;\n};\n\nimport { jsx as _jsx } from \"react/jsx-runtime\";\nimport { Children, cloneElement, forwardRef, isValidElement, useCallback, useEffect, useRef, useState } from \"react\";\nimport cn from \"classnames\";\nimport { bem, useEnsuredRef } from \"@react-md/utils\";\nimport { useTabs } from \"./TabsManager\";\nvar block = bem(\"rmd-tab-panels\");\n/**\n * This component allows you to control the visibility of the `TabPanel`\n * components and animating the next and current panels as needed. This works by\n * looping over all the children and getting the current `TabPanel` by the\n * `activeIndex`. This is why the children for this component can only be\n * `TabPanel` and should not be conditional.\n */\n\nexport var TabPanels = forwardRef(function TabPanels(_a, forwardedRef) {\n  var className = _a.className,\n      children = _a.children,\n      _b = _a.disableScrollFix,\n      disableScrollFix = _b === void 0 ? false : _b,\n      _c = _a.disableTransition,\n      disableTransition = _c === void 0 ? false : _c,\n      _d = _a.persistent,\n      persistent = _d === void 0 ? false : _d,\n      props = __rest(_a, [\"className\", \"children\", \"disableScrollFix\", \"disableTransition\", \"persistent\"]);\n\n  var _e = useTabs(),\n      tabsId = _e.tabsId,\n      tabs = _e.tabs,\n      activeIndex = _e.activeIndex;\n\n  var prevIndex = useRef(activeIndex);\n\n  var _f = __read(useState({\n    previous: activeIndex,\n    incrementing: true\n  }), 2),\n      _g = _f[0],\n      previous = _g.previous,\n      incrementing = _g.incrementing,\n      setState = _f[1]; // have to set these in refs since changing these might cause mounting\n  // and unmounting in the Transition group component :/ they should only\n  // be re-evaluated when the activeIndex changes.\n\n\n  var transitionable = useRef(!persistent && !disableTransition);\n  var animatable = useRef(persistent && !disableTransition);\n\n  if (prevIndex.current !== activeIndex) {\n    prevIndex.current = activeIndex;\n    transitionable.current = !persistent && !disableTransition;\n    animatable.current = persistent && !disableTransition;\n  }\n\n  useEffect(function () {\n    setState(function (_a) {\n      var previous = _a.previous;\n      return {\n        incrementing: previous < activeIndex,\n        previous: disableTransition ? activeIndex : previous\n      };\n    }); // this is for only updating the incrementing state and should not be fired\n    // again if the disableTransition prop is changed\n    // eslint-disable-next-line react-hooks/exhaustive-deps\n  }, [activeIndex]);\n  var onEntered = useCallback(function () {\n    setState(function (_a) {\n      var incrementing = _a.incrementing;\n      return {\n        incrementing: incrementing,\n        previous: activeIndex\n      };\n    });\n  }, [activeIndex]);\n\n  var _h = __read(useEnsuredRef(forwardedRef), 2),\n      ref = _h[0],\n      refHandler = _h[1];\n\n  useEffect(function () {\n    if (!ref.current || disableScrollFix) {\n      return;\n    }\n\n    ref.current.scrollTop = 0; // don't want it to be triggered if only the disableScrollFix prop has changed\n    // since it might be independent from active indexes\n    // eslint-disable-next-line react-hooks/exhaustive-deps\n  }, [activeIndex]);\n  return _jsx(\"div\", __assign({}, props, {\n    ref: refHandler,\n    className: cn(block({\n      \"slide-left\": incrementing,\n      \"slide-right\": !incrementing\n    }), className)\n  }, {\n    children: Children.map(children, function (child, index) {\n      if (!isValidElement(child)) {\n        return child;\n      }\n\n      var panel = Children.only(child);\n      var labelledBy = panel.props[\"aria-labelledby\"];\n\n      if (!labelledBy && !panel.props[\"aria-label\"] && tabs[index]) {\n        // generally guaranteed to be defined by this point since the TabsManager\n        // will add ids if missing.\n        labelledBy = tabs[index].id;\n      }\n\n      return cloneElement(child, {\n        \"aria-labelledby\": labelledBy,\n        id: \"\".concat(tabsId, \"-panel-\").concat(index + 1),\n        hidden: persistent && index !== activeIndex && index !== previous,\n        temporary: !persistent,\n        transitionIn: index === activeIndex,\n        timeout: disableTransition ? 0 : panel.props.timeout,\n        onEntered: disableTransition ? undefined : onEntered\n      });\n    })\n  }));\n});","map":{"version":3,"mappings":"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","names":["Children","cloneElement","forwardRef","isValidElement","useCallback","useEffect","useRef","useState","cn","bem","useEnsuredRef","useTabs","block","TabPanels","_a","forwardedRef","children","_b","disableScrollFix","_c","disableTransition","_d","persistent","props","tabsId","tabs","activeIndex","prevIndex","previous","incrementing","_g","setState","transitionable","animatable","current","onEntered","ref","refHandler","scrollTop","_jsx","className","map","child","index","panel","only","labelledBy","id","concat","hidden","temporary","transitionIn","timeout","undefined"],"sources":["C:\\Users\\hungr\\Documents\\VS-CODE\\notes-react\\node_modules\\@react-md\\tabs\\src\\TabPanels.tsx"],"sourcesContent":["import type { HTMLAttributes } from \"react\";\nimport {\n  Children,\n  cloneElement,\n  forwardRef,\n  isValidElement,\n  useCallback,\n  useEffect,\n  useRef,\n  useState,\n} from \"react\";\nimport cn from \"classnames\";\nimport { bem, useEnsuredRef } from \"@react-md/utils\";\n\nimport { useTabs } from \"./TabsManager\";\nimport type { TabPanelProps } from \"./TabPanel\";\n\nexport interface TabPanelsProps extends HTMLAttributes<HTMLDivElement> {\n  /**\n   * Boolean if this component should no longer automatically reset the scrolling\n   * to the top when the panel changes.\n   *\n   * @defaultValue `false`\n   */\n  disableScrollFix?: boolean;\n\n  /**\n   * Boolean if the swiping transition should be disabled. If you want to add\n   * a custom transition, you'll need to wrap the `TabPanel`'s children in a\n   * custom component that does appear and exit animations.\n   *\n   * @defaultValue `false`\n   */\n  disableTransition?: boolean;\n\n  /**\n   * Boolean if the conditional rendering for the active tab panel only should\n   * be disabled. This means that all the children will be visible in the DOM\n   * instead of mounting and unmounting when their active state changes. The\n   * panels will also be updated to ensure that inactive panels can not be\n   * tab focusable.\n   *\n   * @defaultValue `false`\n   */\n  persistent?: boolean;\n}\n\nconst block = bem(\"rmd-tab-panels\");\n\n/**\n * This component allows you to control the visibility of the `TabPanel`\n * components and animating the next and current panels as needed. This works by\n * looping over all the children and getting the current `TabPanel` by the\n * `activeIndex`. This is why the children for this component can only be\n * `TabPanel` and should not be conditional.\n */\nexport const TabPanels = forwardRef<HTMLDivElement, TabPanelsProps>(\n  function TabPanels(\n    {\n      className,\n      children,\n      disableScrollFix = false,\n      disableTransition = false,\n      persistent = false,\n      ...props\n    },\n    forwardedRef\n  ) {\n    const { tabsId, tabs, activeIndex } = useTabs();\n    const prevIndex = useRef(activeIndex);\n    const [{ previous, incrementing }, setState] = useState({\n      previous: activeIndex,\n      incrementing: true,\n    });\n\n    // have to set these in refs since changing these might cause mounting\n    // and unmounting in the Transition group component :/ they should only\n    // be re-evaluated when the activeIndex changes.\n    const transitionable = useRef(!persistent && !disableTransition);\n    const animatable = useRef(persistent && !disableTransition);\n    if (prevIndex.current !== activeIndex) {\n      prevIndex.current = activeIndex;\n      transitionable.current = !persistent && !disableTransition;\n      animatable.current = persistent && !disableTransition;\n    }\n\n    useEffect(() => {\n      setState(({ previous }) => ({\n        incrementing: previous < activeIndex,\n        previous: disableTransition ? activeIndex : previous,\n      }));\n\n      // this is for only updating the incrementing state and should not be fired\n      // again if the disableTransition prop is changed\n      // eslint-disable-next-line react-hooks/exhaustive-deps\n    }, [activeIndex]);\n\n    const onEntered = useCallback(() => {\n      setState(({ incrementing }) => ({ incrementing, previous: activeIndex }));\n    }, [activeIndex]);\n\n    const [ref, refHandler] = useEnsuredRef(forwardedRef);\n\n    useEffect(() => {\n      if (!ref.current || disableScrollFix) {\n        return;\n      }\n\n      ref.current.scrollTop = 0;\n      // don't want it to be triggered if only the disableScrollFix prop has changed\n      // since it might be independent from active indexes\n      // eslint-disable-next-line react-hooks/exhaustive-deps\n    }, [activeIndex]);\n\n    return (\n      <div\n        {...props}\n        ref={refHandler}\n        className={cn(\n          block({\n            \"slide-left\": incrementing,\n            \"slide-right\": !incrementing,\n          }),\n          className\n        )}\n      >\n        {Children.map(children, (child, index) => {\n          if (!isValidElement<TabPanelProps>(child)) {\n            return child;\n          }\n\n          const panel = Children.only(child);\n          let labelledBy = panel.props[\"aria-labelledby\"];\n          if (!labelledBy && !panel.props[\"aria-label\"] && tabs[index]) {\n            // generally guaranteed to be defined by this point since the TabsManager\n            // will add ids if missing.\n            labelledBy = tabs[index].id;\n          }\n\n          return cloneElement(child, {\n            \"aria-labelledby\": labelledBy,\n            id: `${tabsId}-panel-${index + 1}`,\n            hidden: persistent && index !== activeIndex && index !== previous,\n            temporary: !persistent,\n            transitionIn: index === activeIndex,\n            timeout: disableTransition ? 0 : panel.props.timeout,\n            onEntered: disableTransition ? undefined : onEntered,\n          });\n        })}\n      </div>\n    );\n  }\n);\n"]},"metadata":{},"sourceType":"module"}