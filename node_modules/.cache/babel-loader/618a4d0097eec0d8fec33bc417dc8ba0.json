{"ast":null,"code":"var __assign = this && this.__assign || function () {\n  __assign = Object.assign || function (t) {\n    for (var s, i = 1, n = arguments.length; i < n; i++) {\n      s = arguments[i];\n\n      for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p)) t[p] = s[p];\n    }\n\n    return t;\n  };\n\n  return __assign.apply(this, arguments);\n};\n\nvar __read = this && this.__read || function (o, n) {\n  var m = typeof Symbol === \"function\" && o[Symbol.iterator];\n  if (!m) return o;\n  var i = m.call(o),\n      r,\n      ar = [],\n      e;\n\n  try {\n    while ((n === void 0 || n-- > 0) && !(r = i.next()).done) ar.push(r.value);\n  } catch (error) {\n    e = {\n      error: error\n    };\n  } finally {\n    try {\n      if (r && !r.done && (m = i[\"return\"])) m.call(i);\n    } finally {\n      if (e) throw e.error;\n    }\n  }\n\n  return ar;\n};\n\nimport { jsx as _jsx, Fragment as _Fragment, jsxs as _jsxs } from \"react/jsx-runtime\";\nimport { useEffect, useState } from \"react\";\nimport { SkipToMainContent } from \"@react-md/link\";\nimport { LayoutAppBar } from \"./LayoutAppBar\";\nimport { LayoutMain } from \"./LayoutMain\";\nimport { LayoutNavigation } from \"./LayoutNavigation\";\nimport { useLayoutConfig } from \"./LayoutProvider\";\nimport { MiniLayoutWrapper } from \"./MiniLayoutWrapper\";\nimport { isMiniLayout } from \"./utils\";\n/**\n * The only purpose of this component is to render the children and different\n * parts of the `Layout` depending on the current layout that is active. Since\n * the `Layout` component defines the provider itself, this has to be a child\n * component to get the resolved `layout` type.\n *\n * @remarks \\@since 2.7.0\n * @internal\n */\n\nexport function LayoutChildren(_a) {\n  var _b = _a.id,\n      id = _b === void 0 ? \"layout\" : _b,\n      propAppBar = _a.appBar,\n      appBarProps = _a.appBarProps,\n      customTitle = _a.customTitle,\n      title = _a.title,\n      titleProps = _a.titleProps,\n      navToggle = _a.navToggle,\n      navToggleProps = _a.navToggleProps,\n      _c = _a.navAfterAppBar,\n      navAfterAppBar = _c === void 0 ? false : _c,\n      propNav = _a.nav,\n      miniNav = _a.miniNav,\n      miniNavItems = _a.miniNavItems,\n      miniWrapperProps = _a.miniWrapperProps,\n      navHeader = _a.navHeader,\n      navHeaderProps = _a.navHeaderProps,\n      navHeaderTitle = _a.navHeaderTitle,\n      navHeaderTitleProps = _a.navHeaderTitleProps,\n      closeNav = _a.closeNav,\n      closeNavProps = _a.closeNavProps,\n      treeProps = _a.treeProps,\n      navProps = _a.navProps,\n      skipProps = _a.skipProps,\n      mainProps = _a.mainProps,\n      children = _a.children;\n  var mainId = (mainProps === null || mainProps === void 0 ? void 0 : mainProps.id) || \"\".concat(id, \"-main\");\n\n  var _d = useLayoutConfig(),\n      layout = _d.layout,\n      visible = _d.visible,\n      fixedAppBar = _d.fixedAppBar;\n\n  var mini = isMiniLayout(layout);\n\n  var _e = __read(useState(visible), 2),\n      miniHidden = _e[0],\n      setMiniHidden = _e[1]; // when the layout changes, the hidden state for the mini drawer must also be\n  // updated\n\n\n  useEffect(function () {\n    setMiniHidden(visible); // eslint-disable-next-line react-hooks/exhaustive-deps\n  }, [layout]);\n  var appBar = propAppBar;\n\n  if (typeof appBar === \"undefined\") {\n    appBar = _jsx(LayoutAppBar, __assign({}, appBarProps, {\n      customTitle: customTitle,\n      title: title,\n      titleProps: titleProps,\n      navToggle: navToggle,\n      navToggleProps: navToggleProps\n    }));\n  }\n\n  var nav = propNav;\n\n  if (typeof nav === \"undefined\") {\n    nav = _jsx(LayoutNavigation, __assign({\n      header: navHeader,\n      headerProps: navHeaderProps,\n      headerTitle: navHeaderTitle,\n      headerTitleProps: navHeaderTitleProps,\n      closeNav: closeNav,\n      closeNavProps: closeNavProps,\n      treeProps: treeProps\n    }, navProps, {\n      onEntered: function (appearing) {\n        var _a;\n\n        (_a = navProps === null || navProps === void 0 ? void 0 : navProps.onEntered) === null || _a === void 0 ? void 0 : _a.call(navProps, appearing);\n        setMiniHidden(true);\n      },\n      onExit: function () {\n        var _a;\n\n        (_a = navProps === null || navProps === void 0 ? void 0 : navProps.onExit) === null || _a === void 0 ? void 0 : _a.call(navProps);\n        setMiniHidden(false);\n      }\n    }));\n  }\n\n  return _jsxs(_Fragment, {\n    children: [_jsx(SkipToMainContent, __assign({}, skipProps, {\n      mainId: mainId\n    })), navAfterAppBar && appBar, nav, !navAfterAppBar && appBar, _jsx(MiniLayoutWrapper, __assign({\n      mini: mini,\n      miniNav: miniNav,\n      miniHidden: miniHidden,\n      containerProps: miniWrapperProps,\n      miniNavItems: miniNavItems,\n      treeProps: treeProps,\n      header: navHeader,\n      headerProps: navHeaderProps,\n      headerTitle: navHeaderTitle,\n      headerTitleProps: navHeaderTitleProps,\n      closeNav: closeNav,\n      closeNavProps: closeNavProps\n    }, {\n      children: _jsx(LayoutMain, __assign({\n        headerOffset: fixedAppBar,\n        mini: mini,\n        miniHidden: miniHidden\n      }, mainProps, {\n        id: mainId\n      }, {\n        children: children\n      }))\n    }))]\n  });\n}","map":{"version":3,"mappings":"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","names":["useEffect","useState","SkipToMainContent","LayoutAppBar","LayoutMain","LayoutNavigation","useLayoutConfig","MiniLayoutWrapper","isMiniLayout","LayoutChildren","_a","_b","id","propAppBar","appBarProps","customTitle","title","titleProps","navToggle","navToggleProps","_c","navAfterAppBar","propNav","miniNav","miniNavItems","miniWrapperProps","navHeader","navHeaderProps","navHeaderTitle","navHeaderTitleProps","closeNav","closeNavProps","treeProps","navProps","skipProps","mainProps","children","mainId","layout","visible","fixedAppBar","mini","miniHidden","setMiniHidden","appBar","_jsx","__assign","nav","header","headerProps","headerTitle","headerTitleProps","onEntered","appearing","onExit","_jsxs","containerProps","headerOffset"],"sources":["C:\\Users\\hungr\\Documents\\VS-CODE\\notes-react\\node_modules\\@react-md\\layout\\src\\LayoutChildren.tsx"],"sourcesContent":["import type { HTMLAttributes, ReactElement, ReactNode } from \"react\";\nimport { useEffect, useState } from \"react\";\nimport type { SkipToMainContentProps } from \"@react-md/link\";\nimport { SkipToMainContent } from \"@react-md/link\";\nimport type { BaseTreeItem, TreeData } from \"@react-md/tree\";\nimport type { PropsWithRef } from \"@react-md/utils\";\n\nimport type { FlattenedLayoutComponentConfiguration } from \"./Layout\";\nimport { LayoutAppBar } from \"./LayoutAppBar\";\nimport type { LayoutMainProps } from \"./LayoutMain\";\nimport { LayoutMain } from \"./LayoutMain\";\nimport { LayoutNavigation } from \"./LayoutNavigation\";\nimport { useLayoutConfig } from \"./LayoutProvider\";\nimport { MiniLayoutWrapper } from \"./MiniLayoutWrapper\";\nimport type { LayoutNavigationItem } from \"./types\";\nimport { isMiniLayout } from \"./utils\";\n\n/**\n * This used to just be the `LayoutProps` but was split up to help with mini\n * layouts.\n *\n * @remarks \\@since 2.7.0\n */\nexport interface LayoutChildrenProps<\n  T extends BaseTreeItem = LayoutNavigationItem\n> extends FlattenedLayoutComponentConfiguration<T> {\n  /**\n   * The base id to use for everything within the layout component. The `id`\n   * will be applied to:\n   *\n   * - the `LayoutAppBar` as `${id}-header`\n   * - the `AppBarTitle` as `${id}-title`\n   * - the `LayoutNavToggle` as `${id}-nav-toggle`\n   * - the `LayoutMain` element as `${id}-main`\n   */\n  id?: string;\n\n  /**\n   * Boolean if the main app bar should appear after the navigation component.\n   * It is generally recommended to enable this prop if the navigation component\n   * as a focusable element in the header since it will have a better tab focus\n   * order.\n   */\n  navAfterAppBar?: boolean;\n\n  /**\n   * Any optional props to provide to the `<main>` element of the page.\n   */\n  mainProps?: PropsWithRef<LayoutMainProps, HTMLDivElement>;\n\n  /**\n   * Any additional props to provide to the `<SkipToMainContent />` link that is\n   * automatically rendered in the layout.\n   */\n  skipProps?: Omit<SkipToMainContentProps, \"mainId\">;\n\n  /**\n   * An optional tree to use for the mini navigation pane since the default\n   * behavior of rendering mini tree items might hide content in an undesirable\n   * way.\n   *\n   * @remarks \\@since 2.7.0\n   * @see {@link defaultMiniNavigationItemRenderer} for more information\n   */\n  miniNavItems?: TreeData<T>;\n\n  /**\n   * This prop allows you to provide additional props to the `<div>` surrounding\n   * the `LayoutMain` and mini `LayoutNavigation` components.\n   *\n   * Note: This additional `<div>` will only be rendered if:\n   * - at least one of the provided layout types are `mini`\n   * - the layout is not using a fixed app bar\n   * - the `miniNav` prop has not been defined\n   * - `treeProps` have been provided\n   *\n   * @remarks \\@since 2.8.3\n   * @remarks \\@since 2.9.1 This will render if any provided layout type is `mini`.\n   */\n  miniWrapperProps?: PropsWithRef<\n    HTMLAttributes<HTMLDivElement>,\n    HTMLDivElement\n  >;\n\n  /**\n   * The children to display within the layout. This is pretty much required\n   * since you'll have an empty app otherwise, but it's left as optional just\n   * for prototyping purposes.\n   */\n  children?: ReactNode;\n}\n\n/**\n * The only purpose of this component is to render the children and different\n * parts of the `Layout` depending on the current layout that is active. Since\n * the `Layout` component defines the provider itself, this has to be a child\n * component to get the resolved `layout` type.\n *\n * @remarks \\@since 2.7.0\n * @internal\n */\nexport function LayoutChildren({\n  id = \"layout\",\n  appBar: propAppBar,\n  appBarProps,\n  customTitle,\n  title,\n  titleProps,\n  navToggle,\n  navToggleProps,\n  navAfterAppBar = false,\n  nav: propNav,\n  miniNav,\n  miniNavItems,\n  miniWrapperProps,\n  navHeader,\n  navHeaderProps,\n  navHeaderTitle,\n  navHeaderTitleProps,\n  closeNav,\n  closeNavProps,\n  treeProps,\n  navProps,\n  skipProps,\n  mainProps,\n  children,\n}: LayoutChildrenProps): ReactElement {\n  const mainId = mainProps?.id || `${id}-main`;\n  const { layout, visible, fixedAppBar } = useLayoutConfig();\n  const mini = isMiniLayout(layout);\n  const [miniHidden, setMiniHidden] = useState(visible);\n  // when the layout changes, the hidden state for the mini drawer must also be\n  // updated\n  useEffect(() => {\n    setMiniHidden(visible);\n    // eslint-disable-next-line react-hooks/exhaustive-deps\n  }, [layout]);\n\n  let appBar = propAppBar;\n  if (typeof appBar === \"undefined\") {\n    appBar = (\n      <LayoutAppBar\n        {...appBarProps}\n        customTitle={customTitle}\n        title={title}\n        titleProps={titleProps}\n        navToggle={navToggle}\n        navToggleProps={navToggleProps}\n      />\n    );\n  }\n\n  let nav = propNav;\n  if (typeof nav === \"undefined\") {\n    nav = (\n      <LayoutNavigation\n        header={navHeader}\n        headerProps={navHeaderProps}\n        headerTitle={navHeaderTitle}\n        headerTitleProps={navHeaderTitleProps}\n        closeNav={closeNav}\n        closeNavProps={closeNavProps}\n        treeProps={treeProps}\n        {...navProps}\n        onEntered={(appearing) => {\n          navProps?.onEntered?.(appearing);\n          setMiniHidden(true);\n        }}\n        onExit={() => {\n          navProps?.onExit?.();\n          setMiniHidden(false);\n        }}\n      />\n    );\n  }\n\n  return (\n    <>\n      <SkipToMainContent {...skipProps} mainId={mainId} />\n      {navAfterAppBar && appBar}\n      {nav}\n      {!navAfterAppBar && appBar}\n      <MiniLayoutWrapper\n        mini={mini}\n        miniNav={miniNav}\n        miniHidden={miniHidden}\n        containerProps={miniWrapperProps}\n        miniNavItems={miniNavItems}\n        treeProps={treeProps}\n        header={navHeader}\n        headerProps={navHeaderProps}\n        headerTitle={navHeaderTitle}\n        headerTitleProps={navHeaderTitleProps}\n        closeNav={closeNav}\n        closeNavProps={closeNavProps}\n      >\n        <LayoutMain\n          headerOffset={fixedAppBar}\n          mini={mini}\n          miniHidden={miniHidden}\n          {...mainProps}\n          id={mainId}\n        >\n          {children}\n        </LayoutMain>\n      </MiniLayoutWrapper>\n    </>\n  );\n}\n"]},"metadata":{},"sourceType":"module"}