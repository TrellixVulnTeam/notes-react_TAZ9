{"ast":null,"code":"var __read = this && this.__read || function (o, n) {\n  var m = typeof Symbol === \"function\" && o[Symbol.iterator];\n  if (!m) return o;\n  var i = m.call(o),\n      r,\n      ar = [],\n      e;\n\n  try {\n    while ((n === void 0 || n-- > 0) && !(r = i.next()).done) ar.push(r.value);\n  } catch (error) {\n    e = {\n      error: error\n    };\n  } finally {\n    try {\n      if (r && !r.done && (m = i[\"return\"])) m.call(i);\n    } finally {\n      if (e) throw e.error;\n    }\n  }\n\n  return ar;\n};\n\nimport { useCallback, useEffect, useRef, useState } from \"react\";\nimport { useIsUserInteractionMode } from \"@react-md/utils\";\n/**\n * @internal\n */\n\nvar noop = function () {// do nothing\n};\n/**\n * This is a completely internal hook that helps control the visibility of the\n * discrete value tooltip's visibility for the `Slider` and `RangeSlider`.\n *\n * Note: This isn't 100% there since the tooltip doesn't animate in when the\n * user holds the mouse down in the same spot for the `animationDuration`.\n *\n * @internal\n * @remarks \\@since 2.5.0\n */\n\n\nexport function useDiscreteValueVisibility(_a) {\n  var active = _a.active,\n      animate = _a.animate,\n      animationDuration = _a.animationDuration,\n      discrete = _a.discrete,\n      disabled = _a.disabled,\n      _b = _a.onBlur,\n      propOnBlur = _b === void 0 ? noop : _b,\n      _c = _a.onFocus,\n      propOnFocus = _c === void 0 ? noop : _c;\n  var ref = useRef(null);\n  var isKeyboard = useIsUserInteractionMode(\"keyboard\"); // when the user interaction mode changes from keyboard -> mouse by clicking\n  // on the track, need to make sure that the thumb value has the animation\n  // state enabled so it moves at the same speed as the thumb instead of jumping\n  // immediately\n\n  var _d = __read(useState(false), 2),\n      isModeTransition = _d[0],\n      setModeTransition = _d[1];\n\n  var _e = __read(useState(false), 2),\n      visible = _e[0],\n      setVisible = _e[1];\n\n  useEffect(function () {\n    if (!discrete) {\n      setVisible(false);\n      setModeTransition(false);\n      return;\n    }\n\n    if (discrete && visible && disabled) {\n      setVisible(false);\n      return;\n    }\n\n    if (!isKeyboard) {\n      // only considered a \"transition\" when the tooltip is already visible and\n      // switching away from keyboard mode\n      setModeTransition(visible);\n      return;\n    } // when swapping from mouse/touch -> keyboard, the tooltip's visibility will\n    // need to be enabled since default drag behavior is to hide on drag end.\n    // The drag process automatically focuses the current \"target\" thumb to help\n    // the user switch between the modes more easily so if the active element is\n    // the current thumb, we're good to go\n\n\n    setModeTransition(false);\n    setVisible(!disabled && document.activeElement === ref.current);\n  }, [isKeyboard, visible, discrete, disabled]);\n  useEffect(function () {\n    if (!discrete) {\n      return;\n    }\n\n    if (!active) {\n      setVisible(false);\n      setModeTransition(false);\n      return;\n    } // need to delay the visibility for the same `animationDuration` as the\n    // thumb's active state so that the tooltip appears at the same time the\n    // thumb stops animating with click drag events\n\n\n    var timeout = window.setTimeout(function () {\n      setVisible(true);\n      setModeTransition(false);\n    }, animationDuration);\n    return function () {\n      window.clearTimeout(timeout);\n    };\n  }, [active, animationDuration, discrete]);\n  var onBlur = useCallback(function (event) {\n    propOnBlur(event);\n    var track = event.currentTarget.parentElement; // need to hide on blur because it _usually_ means the user clicked\n    // somewhere else on the page after using the keyboard. However, it is\n    // possible the user used the keyboard to update the value and then\n    // clicked on the track to update more quickly, so verify that the next\n    // focus element isn't the track or any children of the track.\n\n    if (!track || document.activeElement || !track.contains(document.activeElement)) {\n      ref.current = null;\n      setVisible(false);\n    }\n  }, [propOnBlur]);\n  var onFocus = useCallback(function (event) {\n    ref.current = event.currentTarget;\n    propOnFocus(event);\n\n    if (discrete && isKeyboard) {\n      setVisible(true);\n    }\n  }, [discrete, propOnFocus, isKeyboard]);\n  return {\n    onBlur: onBlur,\n    onFocus: onFocus,\n    animateValue: isModeTransition || animate && isKeyboard,\n    visible: visible\n  };\n}","map":{"version":3,"mappings":"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","names":["useCallback","useEffect","useRef","useState","useIsUserInteractionMode","noop","useDiscreteValueVisibility","_a","active","animate","animationDuration","discrete","disabled","_b","propOnBlur","_c","propOnFocus","ref","isKeyboard","isModeTransition","setModeTransition","visible","setVisible","document","activeElement","current","timeout","window","setTimeout","clearTimeout","onBlur","event","track","currentTarget","parentElement","contains","onFocus","animateValue"],"sources":["C:\\Users\\hungr\\Documents\\VS-CODE\\notes-react\\node_modules\\@react-md\\form\\src\\slider\\useDiscreteValueVisibility.ts"],"sourcesContent":["import type { FocusEvent, FocusEventHandler } from \"react\";\nimport { useCallback, useEffect, useRef, useState } from \"react\";\nimport { useIsUserInteractionMode } from \"@react-md/utils\";\n\n/**\n * @internal\n */\nconst noop = (): void => {\n  // do nothing\n};\n\n/**\n * @internal\n * @remarks \\@since 2.5.0\n */\ninterface Options {\n  active: boolean;\n  animate: boolean;\n  animationDuration: number;\n  discrete: boolean;\n  disabled: boolean;\n  onBlur?: FocusEventHandler<HTMLSpanElement>;\n  onFocus?: FocusEventHandler<HTMLSpanElement>;\n}\n\n/**\n * @internal\n * @remarks \\@since 2.5.0\n */\ninterface ReturnedProps {\n  /**\n   * Boolean if the value should animate the `left`, `right`, `top`, and\n   * `bottom` values to match the speed of the thumb.\n   */\n  animateValue: boolean;\n  visible: boolean;\n  onBlur: FocusEventHandler<HTMLSpanElement>;\n  onFocus: FocusEventHandler<HTMLSpanElement>;\n}\n\n/**\n * This is a completely internal hook that helps control the visibility of the\n * discrete value tooltip's visibility for the `Slider` and `RangeSlider`.\n *\n * Note: This isn't 100% there since the tooltip doesn't animate in when the\n * user holds the mouse down in the same spot for the `animationDuration`.\n *\n * @internal\n * @remarks \\@since 2.5.0\n */\nexport function useDiscreteValueVisibility({\n  active,\n  animate,\n  animationDuration,\n  discrete,\n  disabled,\n  onBlur: propOnBlur = noop,\n  onFocus: propOnFocus = noop,\n}: Options): ReturnedProps {\n  const ref = useRef<HTMLSpanElement | null>(null);\n  const isKeyboard = useIsUserInteractionMode(\"keyboard\");\n\n  // when the user interaction mode changes from keyboard -> mouse by clicking\n  // on the track, need to make sure that the thumb value has the animation\n  // state enabled so it moves at the same speed as the thumb instead of jumping\n  // immediately\n  const [isModeTransition, setModeTransition] = useState(false);\n  const [visible, setVisible] = useState(false);\n\n  useEffect(() => {\n    if (!discrete) {\n      setVisible(false);\n      setModeTransition(false);\n      return;\n    }\n\n    if (discrete && visible && disabled) {\n      setVisible(false);\n      return;\n    }\n\n    if (!isKeyboard) {\n      // only considered a \"transition\" when the tooltip is already visible and\n      // switching away from keyboard mode\n      setModeTransition(visible);\n      return;\n    }\n\n    // when swapping from mouse/touch -> keyboard, the tooltip's visibility will\n    // need to be enabled since default drag behavior is to hide on drag end.\n    // The drag process automatically focuses the current \"target\" thumb to help\n    // the user switch between the modes more easily so if the active element is\n    // the current thumb, we're good to go\n    setModeTransition(false);\n    setVisible(!disabled && document.activeElement === ref.current);\n  }, [isKeyboard, visible, discrete, disabled]);\n\n  useEffect(() => {\n    if (!discrete) {\n      return;\n    }\n\n    if (!active) {\n      setVisible(false);\n      setModeTransition(false);\n      return;\n    }\n\n    // need to delay the visibility for the same `animationDuration` as the\n    // thumb's active state so that the tooltip appears at the same time the\n    // thumb stops animating with click drag events\n    const timeout = window.setTimeout(() => {\n      setVisible(true);\n      setModeTransition(false);\n    }, animationDuration);\n\n    return () => {\n      window.clearTimeout(timeout);\n    };\n  }, [active, animationDuration, discrete]);\n\n  const onBlur = useCallback(\n    (event: FocusEvent<HTMLSpanElement>) => {\n      propOnBlur(event);\n\n      const track = event.currentTarget.parentElement;\n      // need to hide on blur because it _usually_ means the user clicked\n      // somewhere else on the page after using the keyboard. However, it is\n      // possible the user used the keyboard to update the value and then\n      // clicked on the track to update more quickly, so verify that the next\n      // focus element isn't the track or any children of the track.\n      if (\n        !track ||\n        document.activeElement ||\n        !track.contains(document.activeElement)\n      ) {\n        ref.current = null;\n        setVisible(false);\n      }\n    },\n    [propOnBlur]\n  );\n\n  const onFocus = useCallback(\n    (event: FocusEvent<HTMLSpanElement>) => {\n      ref.current = event.currentTarget;\n      propOnFocus(event);\n      if (discrete && isKeyboard) {\n        setVisible(true);\n      }\n    },\n    [discrete, propOnFocus, isKeyboard]\n  );\n\n  return {\n    onBlur,\n    onFocus,\n    animateValue: isModeTransition || (animate && isKeyboard),\n    visible,\n  };\n}\n"]},"metadata":{},"sourceType":"module"}