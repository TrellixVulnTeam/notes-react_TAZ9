{"ast":null,"code":"var __assign = this && this.__assign || function () {\n  __assign = Object.assign || function (t) {\n    for (var s, i = 1, n = arguments.length; i < n; i++) {\n      s = arguments[i];\n\n      for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p)) t[p] = s[p];\n    }\n\n    return t;\n  };\n\n  return __assign.apply(this, arguments);\n};\n\nimport { jsx as _jsx, Fragment as _Fragment, jsxs as _jsxs } from \"react/jsx-runtime\";\nimport { ListItemAddon } from \"./ListItemAddon\";\nimport { ListItemText } from \"./ListItemText\";\n/**\n * The `ListItemChildren` component is used to create a styled list item that\n * can have optional addons to the left or right of the children in the form of\n * icons, avatars, or media. The `children` can be replaced by the `primaryText`\n * and `secondaryText` props to create stacked text spanning two or more lines\n * with the default behavior of using `line-clamp` at three lines.\n *\n * Note: This will return a `React.Fragment` of the children and does not wrap\n * in a DOM node for styling. The parent component should normally have\n * `display: flex` for the styling to work.\n */\n\nexport function ListItemChildren(_a) {\n  var textClassName = _a.textClassName,\n      secondaryTextClassName = _a.secondaryTextClassName,\n      textChildren = _a.textChildren,\n      primaryText = _a.primaryText,\n      secondaryText = _a.secondaryText,\n      leftAddon = _a.leftAddon,\n      _b = _a.leftAddonType,\n      leftAddonType = _b === void 0 ? \"icon\" : _b,\n      _c = _a.leftAddonPosition,\n      leftAddonPosition = _c === void 0 ? \"middle\" : _c,\n      rightAddon = _a.rightAddon,\n      _d = _a.rightAddonType,\n      rightAddonType = _d === void 0 ? \"icon\" : _d,\n      _e = _a.rightAddonPosition,\n      rightAddonPosition = _e === void 0 ? \"middle\" : _e,\n      forceAddonWrap = _a.forceAddonWrap,\n      propChildren = _a.children;\n  var stringifiedChildren = typeof propChildren === \"number\" ? \"\".concat(propChildren) : propChildren;\n  var children = stringifiedChildren;\n\n  if (primaryText || secondaryText || textChildren) {\n    children = _jsx(ListItemText, __assign({\n      className: textClassName,\n      secondaryText: secondaryText,\n      secondaryTextClassName: secondaryTextClassName\n    }, {\n      children: textChildren && children || primaryText\n    }));\n  }\n\n  children = _jsx(ListItemAddon, __assign({\n    addon: leftAddon,\n    type: leftAddonType,\n    position: leftAddonPosition,\n    forceAddonWrap: forceAddonWrap\n  }, {\n    children: children\n  }));\n  children = _jsx(ListItemAddon, __assign({\n    addon: rightAddon,\n    addonAfter: true,\n    type: rightAddonType,\n    position: rightAddonPosition,\n    forceAddonWrap: forceAddonWrap\n  }, {\n    children: children\n  }));\n  return _jsxs(_Fragment, {\n    children: [children, primaryText && stringifiedChildren || null]\n  });\n}","map":{"version":3,"mappings":";;;;;;;;;;;;;;;AAGA,SAASA,aAAT,QAA8B,iBAA9B;AACA,SAASC,YAAT,QAA6B,gBAA7B;AAkGA;;;;;;;;;;;;AAWA,OAAM,SAAUC,gBAAV,CAA2BC,EAA3B,EAckB;MAbtBC,aAAa;MACbC,sBAAsB;MACtBC,YAAY;MACZC,WAAW;MACXC,aAAa;MACbC,SAAS;MACTC;MAAAC,aAAa,mBAAG,MAAH,GAASD;MACtBE;MAAAC,iBAAiB,mBAAG,QAAH,GAAWD;MAC5BE,UAAU;MACVC;MAAAC,cAAc,mBAAG,MAAH,GAASD;MACvBE;MAAAC,kBAAkB,mBAAG,QAAH,GAAWD;MAC7BE,cAAc;MACJC,YAAY;EAEtB,IAAMC,mBAAmB,GACvB,OAAOD,YAAP,KAAwB,QAAxB,GAAmC,UAAGA,YAAH,CAAnC,GAAuDA,YADzD;EAGA,IAAIE,QAAQ,GAAGD,mBAAf;;EACA,IAAId,WAAW,IAAIC,aAAf,IAAgCF,YAApC,EAAkD;IAChDgB,QAAQ,GACNC,KAACtB,YAAD,EAAauB;MACXC,SAAS,EAAErB,aADA;MAEXI,aAAa,EAAEA,aAFJ;MAGXH,sBAAsB,EAAEA;IAHb,GAGmC;MAAAiB,UAE5ChB,YAAY,IAAIgB,QAAjB,IAA8Bf;IAFe,CAHnC,CAAb,CADF;EASD;;EAEDe,QAAQ,GACNC,KAACvB,aAAD,EAAcwB;IACZE,KAAK,EAAEjB,SADK;IAEZkB,IAAI,EAAEhB,aAFM;IAGZiB,QAAQ,EAAEf,iBAHE;IAIZM,cAAc,EAAEA;EAJJ,GAIkB;IAAAG,UAE7BA;EAF6B,CAJlB,CAAd,CADF;EAUAA,QAAQ,GACNC,KAACvB,aAAD,EAAcwB;IACZE,KAAK,EAAEZ,UADK;IAEZe,UAAU,MAFE;IAGZF,IAAI,EAAEX,cAHM;IAIZY,QAAQ,EAAEV,kBAJE;IAKZC,cAAc,EAAEA;EALJ,GAKkB;IAAAG,UAE7BA;EAF6B,CALlB,CAAd,CADF;EAYA,OACEQ;IAAAR,WACGA,QADH,EAEIf,WAAW,IAAIc,mBAAhB,IAAwC,IAF3C;EAAA,EADF;AAMD","names":["ListItemAddon","ListItemText","ListItemChildren","_a","textClassName","secondaryTextClassName","textChildren","primaryText","secondaryText","leftAddon","_b","leftAddonType","_c","leftAddonPosition","rightAddon","_d","rightAddonType","_e","rightAddonPosition","forceAddonWrap","propChildren","stringifiedChildren","children","_jsx","__assign","className","addon","type","position","addonAfter","_jsxs"],"sources":["C:\\Users\\hungr\\Documents\\VS-CODE\\notes-react\\node_modules\\@react-md\\list\\src\\ListItemChildren.tsx"],"sourcesContent":["import type { ReactElement, ReactNode } from \"react\";\n\nimport type { ListItemAddonPosition, ListItemAddonType } from \"./ListItemAddon\";\nimport { ListItemAddon } from \"./ListItemAddon\";\nimport { ListItemText } from \"./ListItemText\";\n\nexport interface ListItemChildrenProps {\n  /**\n   * The main content to display. When the `textChildren` prop is enabled and\n   * there is child content, it will be treated as primary text and update the\n   * styles automatically.\n   */\n  children?: ReactNode;\n\n  /**\n   * An optional className to apply to the `<span>` that surrounds the\n   * `primaryText` and optionally `secondaryText` within the list item.\n   */\n  textClassName?: string;\n\n  /**\n   * An optional className to apply to the `<span>` that surrounds the\n   * `secondaryText` within the list item.\n   */\n  secondaryTextClassName?: string;\n\n  /**\n   * Boolean if the children should be treated as the `primaryText` prop. This\n   * will wrap them in an additional class so that they have ellipsis for text\n   * overflow.\n   *\n   * If you want to have more \"freedom\" within the `ListItem`, you can disable\n   * this prop so that the height will grow depending on content.\n   *\n   * NOTE: If the `secondaryText` prop is provided, this will always be\n   * considered `true`.\n   */\n  textChildren?: boolean;\n\n  /**\n   * An optional element that should be rendered as the `primaryText` within the\n   * list item. It is most likely easier to use the `children` prop instead, but\n   * this allows you to create more complex components with the `ListItem` since\n   * you can provided `children` and have the styles for the `primaryText` still\n   * applied. By default, this will only allow one line of text and add ellipsis\n   * for any text overflow.\n   */\n  primaryText?: ReactNode;\n\n  /**\n   * An optional element that should be rendered as the `secondaryText` within\n   * the list item. By default, this will only span one line and add ellipsis\n   * for overflow.\n   */\n  secondaryText?: ReactNode;\n\n  /**\n   * An optional addon to display to the left of the `primaryText` or\n   * `children` and should be used with the `leftAddonType` prop to adjust\n   * spacing.\n   */\n  leftAddon?: ReactNode;\n\n  /**\n   * The type of the addon that appears to the left of the `primaryText` or\n   * `children`.\n   */\n  leftAddonType?: ListItemAddonType;\n\n  /**\n   * The vertical position the left icon, avatar, media, or large media\n   * should be placed.\n   */\n  leftAddonPosition?: ListItemAddonPosition;\n\n  /**\n   * An optional addon to display to the right of the `primaryText` or\n   * `children` and should be used with the `rightAddonType` prop to adjust\n   * spacing.\n   */\n  rightAddon?: ReactNode;\n\n  /**\n   * The type of the addon that appears to the right of the `primaryText` or\n   * `children`.\n   */\n  rightAddonType?: ListItemAddonType;\n\n  /**\n   * The vertical position the right icon, avatar, media, or large media\n   * should be placed.\n   */\n  rightAddonPosition?: ListItemAddonPosition;\n\n  /**\n   * Boolean if the left and/or right addons should be \"forcefully\" wrapped in a\n   * `<span>` with the spacing class names applied instead of attempting to\n   * clone it into the provided icon element.\n   */\n  forceAddonWrap?: boolean;\n}\n\n/**\n * The `ListItemChildren` component is used to create a styled list item that\n * can have optional addons to the left or right of the children in the form of\n * icons, avatars, or media. The `children` can be replaced by the `primaryText`\n * and `secondaryText` props to create stacked text spanning two or more lines\n * with the default behavior of using `line-clamp` at three lines.\n *\n * Note: This will return a `React.Fragment` of the children and does not wrap\n * in a DOM node for styling. The parent component should normally have\n * `display: flex` for the styling to work.\n */\nexport function ListItemChildren({\n  textClassName,\n  secondaryTextClassName,\n  textChildren,\n  primaryText,\n  secondaryText,\n  leftAddon,\n  leftAddonType = \"icon\",\n  leftAddonPosition = \"middle\",\n  rightAddon,\n  rightAddonType = \"icon\",\n  rightAddonPosition = \"middle\",\n  forceAddonWrap,\n  children: propChildren,\n}: ListItemChildrenProps): ReactElement {\n  const stringifiedChildren =\n    typeof propChildren === \"number\" ? `${propChildren}` : propChildren;\n\n  let children = stringifiedChildren;\n  if (primaryText || secondaryText || textChildren) {\n    children = (\n      <ListItemText\n        className={textClassName}\n        secondaryText={secondaryText}\n        secondaryTextClassName={secondaryTextClassName}\n      >\n        {(textChildren && children) || primaryText}\n      </ListItemText>\n    );\n  }\n\n  children = (\n    <ListItemAddon\n      addon={leftAddon}\n      type={leftAddonType}\n      position={leftAddonPosition}\n      forceAddonWrap={forceAddonWrap}\n    >\n      {children}\n    </ListItemAddon>\n  );\n  children = (\n    <ListItemAddon\n      addon={rightAddon}\n      addonAfter\n      type={rightAddonType}\n      position={rightAddonPosition}\n      forceAddonWrap={forceAddonWrap}\n    >\n      {children}\n    </ListItemAddon>\n  );\n\n  return (\n    <>\n      {children}\n      {(primaryText && stringifiedChildren) || null}\n    </>\n  );\n}\n"]},"metadata":{},"sourceType":"module"}