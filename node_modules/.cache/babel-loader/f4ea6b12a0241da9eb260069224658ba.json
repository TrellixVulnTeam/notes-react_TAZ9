{"ast":null,"code":"import { getAboveCoord, getBelowCoord, getBottomCoord, getCenterYCoord, getTopCoord } from \"./getCoord\";\nimport { getViewportSize } from \"./getViewportSize\";\n/**\n * Attempts to position the fixed element so that it will appear completely\n * above the container element but also within the viewport boundaries. When\n * swapping is enabled, it will attempt to swap to the below position if it\n * can't fit within the viewport above the container element. If it can't fit in\n * the viewport even after being swapped below or swapping is disabled, it will\n * be positioned to the top viewport boundary.\n *\n * @internal\n */\n\nexport function createAnchoredAbove(config) {\n  var yMargin = config.yMargin,\n      vhMargin = config.vhMargin,\n      screenBottom = config.screenBottom,\n      elHeight = config.elHeight,\n      containerRect = config.containerRect,\n      preventOverlap = config.preventOverlap,\n      disableSwapping = config.disableSwapping,\n      disableVHBounds = config.disableVHBounds;\n  var top = getAboveCoord(config);\n  var actualY = \"above\";\n\n  if (disableVHBounds) {\n    // can't actually allow a top value as a negative number since browsers\n    // won't scroll upwards pas the normal page top\n    return {\n      actualY: actualY,\n      top: Math.max(0, top)\n    };\n  }\n\n  if (top > vhMargin) {\n    // don't need to do anything else since the top is still in the viewport and\n    // since it's positioned above, we already know it can't overlap the\n    // container element\n    return {\n      actualY: actualY,\n      top: top\n    };\n  }\n\n  var swappedTop = getBelowCoord(config);\n\n  if (disableSwapping || swappedTop + elHeight > screenBottom) {\n    top = Math.min(top, vhMargin);\n  } else {\n    actualY = \"below\";\n    top = swappedTop;\n  }\n\n  var bottom;\n\n  if (preventOverlap && // can't overlap if it's positioned below\n  actualY === \"above\" && top + elHeight > containerRect.top) {\n    bottom = window.innerHeight - containerRect.top + yMargin;\n  }\n\n  return {\n    actualY: actualY,\n    top: top,\n    bottom: bottom\n  };\n}\n/**\n * Attempts to position the fixed element so that it will appear fixed to the\n * top of the container element but also within the viewport boundaries. When\n * swapping is enabled, it will attempt to swap to the bottom position if it\n * can't fit within the viewport. If it can't fit in the viewport even after\n * being swapped to the bottom position or swapping is disabled, it will be\n * positioned to the top viewport boundary.\n *\n * @internal\n */\n\nexport function createAnchoredTop(config) {\n  var vhMargin = config.vhMargin,\n      screenBottom = config.screenBottom,\n      elHeight = config.elHeight,\n      disableSwapping = config.disableSwapping,\n      disableVHBounds = config.disableVHBounds;\n  var top = getTopCoord(config);\n  var actualY = \"top\";\n\n  if (disableVHBounds || top + elHeight <= screenBottom) {\n    return {\n      actualY: actualY,\n      top: top\n    };\n  }\n\n  var swappedTop = getBottomCoord(config);\n\n  if (disableSwapping || swappedTop < vhMargin) {\n    top = Math.max(top, vhMargin);\n  } else {\n    actualY = \"bottom\";\n    top = swappedTop;\n  }\n\n  return {\n    actualY: actualY,\n    top: top\n  };\n}\n/**\n * Attempts to position the fixed element so that it will appear at the center\n * of the container element but also within the viewport boundaries. If the\n * entered element can't fit within the viewport, it'll update the top value\n * to either be the vhMargin or position to the screen bottom boundary\n *\n * @internal\n */\n\nexport function createAnchoredCenter(config) {\n  var vhMargin = config.vhMargin,\n      screenBottom = config.screenBottom,\n      elHeight = config.elHeight,\n      disableVHBounds = config.disableVHBounds;\n  var top = getCenterYCoord(config);\n  var actualY = \"center\";\n\n  if (disableVHBounds) {\n    return {\n      actualY: actualY,\n      top: Math.max(0, top)\n    };\n  }\n\n  top = Math.max(vhMargin, top);\n\n  if (top + elHeight > screenBottom) {\n    top = screenBottom - elHeight;\n  }\n\n  return {\n    actualY: actualY,\n    top: top\n  };\n}\n/**\n * Attempts to position the fixed element so that it will appear fixed to the\n * bottom of the container element but also within the viewport boundaries. When\n * swapping is enabled, it will attempt to swap to the top position if it can't\n * fit within the viewport. If it can't fit in the viewport even after being\n * swapped to the top position or swapping is disabled, it will be positioned to\n * the bottom viewport boundary.\n *\n * @internal\n */\n\nexport function createAnchoredBottom(config) {\n  var vhMargin = config.vhMargin,\n      screenBottom = config.screenBottom,\n      elHeight = config.elHeight,\n      disableSwapping = config.disableSwapping,\n      disableVHBounds = config.disableVHBounds;\n  var top = getBottomCoord(config);\n  var actualY = \"bottom\";\n\n  if (disableVHBounds || top > vhMargin) {\n    return {\n      actualY: actualY,\n      top: top\n    };\n  }\n\n  var swappedTop = getTopCoord(config);\n\n  if (disableSwapping || swappedTop + elHeight > screenBottom) {\n    top = Math.min(top, screenBottom - elHeight);\n  } else {\n    actualY = \"top\";\n    top = swappedTop;\n  }\n\n  return {\n    actualY: actualY,\n    top: top\n  };\n}\n/**\n * Attempts to position the fixed element so that it will appear completely\n * below the container element but also within the viewport boundaries. When\n * swapping is enabled, it will attempt to swap to the above position if it\n * can't fit within the viewport below the container element. If it can't fit in\n * the viewport even after being swapped above or swapping is disabled, it will\n * be positioned to the bottom viewport boundary.\n *\n * @internal\n */\n\nexport function createAnchoredBelow(config) {\n  var yMargin = config.yMargin,\n      vhMargin = config.vhMargin,\n      elHeight = config.elHeight,\n      screenBottom = config.screenBottom,\n      containerRect = config.containerRect,\n      preventOverlap = config.preventOverlap,\n      disableSwapping = config.disableSwapping,\n      disableVHBounds = config.disableVHBounds;\n  var top = getBelowCoord(config);\n  var actualY = \"below\";\n\n  if (disableVHBounds || top + elHeight <= screenBottom) {\n    return {\n      actualY: actualY,\n      top: top\n    };\n  }\n\n  if (preventOverlap) {\n    var availableTop = containerRect.top - yMargin;\n\n    if (disableSwapping || availableTop < screenBottom - top) {\n      return {\n        actualY: actualY,\n        top: top,\n        bottom: vhMargin\n      };\n    }\n\n    return {\n      actualY: \"above\",\n      top: Math.max(vhMargin, availableTop - elHeight),\n      // this makes it so that the bottom of the fixed element is the top of the container\n      // element. this ensures that it won't ever overlap the container element\n      bottom: getViewportSize(\"height\") - availableTop\n    };\n  }\n\n  var swappedTop = getAboveCoord(config);\n\n  if (disableSwapping || swappedTop < vhMargin) {\n    top = Math.max(top, screenBottom - elHeight);\n  } else {\n    actualY = \"above\";\n    top = swappedTop;\n  }\n\n  return {\n    actualY: actualY,\n    top: top\n  };\n}\n/**\n * Creates the vertical position for a fixed element with the provided options.\n *\n * @internal\n */\n\nexport function createVerticalPosition(_a) {\n  var y = _a.y,\n      vh = _a.vh,\n      vhMargin = _a.vhMargin,\n      yMargin = _a.yMargin,\n      elHeight = _a.elHeight,\n      initialY = _a.initialY,\n      containerRect = _a.containerRect,\n      disableSwapping = _a.disableSwapping,\n      preventOverlap = _a.preventOverlap,\n      disableVHBounds = _a.disableVHBounds;\n\n  if (!disableVHBounds && !preventOverlap && elHeight > vh - vhMargin * 2) {\n    // the element is too big to be displayed in the viewport, so just span the\n    // full viewport excluding margins\n    return {\n      top: vhMargin,\n      bottom: vhMargin,\n      actualY: \"center\"\n    };\n  }\n\n  var config = {\n    vhMargin: vhMargin,\n    yMargin: yMargin,\n    elHeight: elHeight,\n    initialY: initialY,\n    containerRect: containerRect,\n    screenBottom: vh - vhMargin,\n    preventOverlap: preventOverlap,\n    disableSwapping: disableSwapping,\n    disableVHBounds: disableVHBounds\n  };\n\n  switch (y) {\n    case \"above\":\n      return createAnchoredAbove(config);\n\n    case \"top\":\n      return createAnchoredTop(config);\n\n    case \"center\":\n      return createAnchoredCenter(config);\n\n    case \"bottom\":\n      return createAnchoredBottom(config);\n\n    case \"below\":\n      return createAnchoredBelow(config);\n  }\n}","map":{"version":3,"mappings":"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","names":["getAboveCoord","getBelowCoord","getBottomCoord","getCenterYCoord","getTopCoord","getViewportSize","createAnchoredAbove","config","vhMargin","screenBottom","elHeight","containerRect","preventOverlap","disableSwapping","disableVHBounds","top","actualY","Math","max","swappedTop","min","bottom","window","innerHeight","yMargin","createAnchoredTop","createAnchoredCenter","createAnchoredBottom","createAnchoredBelow","availableTop","createVerticalPosition","_a","y","vh","initialY"],"sources":["C:\\Users\\hungr\\Documents\\VS-CODE\\notes-react\\node_modules\\@react-md\\utils\\src\\positioning\\createVerticalPosition.ts"],"sourcesContent":["import type { YCoordConfig } from \"./getCoord\";\nimport {\n  getAboveCoord,\n  getBelowCoord,\n  getBottomCoord,\n  getCenterYCoord,\n  getTopCoord,\n} from \"./getCoord\";\nimport { getViewportSize } from \"./getViewportSize\";\nimport type { FixedPositionOptions, VerticalPosition } from \"./types\";\n\n/**\n * @internal\n */\ninterface YPosition {\n  top: number;\n  bottom?: number;\n  actualY: VerticalPosition;\n}\n\n/**\n * @internal\n */\nexport interface FixConfig extends YCoordConfig {\n  vhMargin: number;\n  screenBottom: number;\n  preventOverlap: boolean;\n  disableSwapping: boolean;\n  disableVHBounds: boolean;\n}\n\n/**\n * @internal\n */\ninterface Options\n  extends Required<\n    Pick<\n      FixedPositionOptions,\n      | \"yMargin\"\n      | \"vhMargin\"\n      | \"preventOverlap\"\n      | \"disableSwapping\"\n      | \"disableVHBounds\"\n    >\n  > {\n  y: VerticalPosition;\n  vh: number;\n  initialY?: number;\n  elHeight: number;\n  containerRect: DOMRect;\n}\n\n/**\n * Attempts to position the fixed element so that it will appear completely\n * above the container element but also within the viewport boundaries. When\n * swapping is enabled, it will attempt to swap to the below position if it\n * can't fit within the viewport above the container element. If it can't fit in\n * the viewport even after being swapped below or swapping is disabled, it will\n * be positioned to the top viewport boundary.\n *\n * @internal\n */\nexport function createAnchoredAbove(config: FixConfig): YPosition {\n  const {\n    yMargin,\n    vhMargin,\n    screenBottom,\n    elHeight,\n    containerRect,\n    preventOverlap,\n    disableSwapping,\n    disableVHBounds,\n  } = config;\n  let top = getAboveCoord(config);\n  let actualY: VerticalPosition = \"above\";\n\n  if (disableVHBounds) {\n    // can't actually allow a top value as a negative number since browsers\n    // won't scroll upwards pas the normal page top\n    return { actualY, top: Math.max(0, top) };\n  }\n\n  if (top > vhMargin) {\n    // don't need to do anything else since the top is still in the viewport and\n    // since it's positioned above, we already know it can't overlap the\n    // container element\n    return { actualY, top };\n  }\n\n  const swappedTop = getBelowCoord(config);\n  if (disableSwapping || swappedTop + elHeight > screenBottom) {\n    top = Math.min(top, vhMargin);\n  } else {\n    actualY = \"below\";\n    top = swappedTop;\n  }\n\n  let bottom: number | undefined;\n  if (\n    preventOverlap &&\n    // can't overlap if it's positioned below\n    actualY === \"above\" &&\n    top + elHeight > containerRect.top\n  ) {\n    bottom = window.innerHeight - containerRect.top + yMargin;\n  }\n\n  return { actualY, top, bottom };\n}\n\n/**\n * Attempts to position the fixed element so that it will appear fixed to the\n * top of the container element but also within the viewport boundaries. When\n * swapping is enabled, it will attempt to swap to the bottom position if it\n * can't fit within the viewport. If it can't fit in the viewport even after\n * being swapped to the bottom position or swapping is disabled, it will be\n * positioned to the top viewport boundary.\n *\n * @internal\n */\nexport function createAnchoredTop(config: FixConfig): YPosition {\n  const { vhMargin, screenBottom, elHeight, disableSwapping, disableVHBounds } =\n    config;\n  let top = getTopCoord(config);\n  let actualY: VerticalPosition = \"top\";\n\n  if (disableVHBounds || top + elHeight <= screenBottom) {\n    return { actualY, top };\n  }\n\n  const swappedTop = getBottomCoord(config);\n  if (disableSwapping || swappedTop < vhMargin) {\n    top = Math.max(top, vhMargin);\n  } else {\n    actualY = \"bottom\";\n    top = swappedTop;\n  }\n\n  return { actualY, top };\n}\n\n/**\n * Attempts to position the fixed element so that it will appear at the center\n * of the container element but also within the viewport boundaries. If the\n * entered element can't fit within the viewport, it'll update the top value\n * to either be the vhMargin or position to the screen bottom boundary\n *\n * @internal\n */\nexport function createAnchoredCenter(config: FixConfig): YPosition {\n  const { vhMargin, screenBottom, elHeight, disableVHBounds } = config;\n  let top = getCenterYCoord(config);\n  const actualY: VerticalPosition = \"center\";\n  if (disableVHBounds) {\n    return { actualY, top: Math.max(0, top) };\n  }\n\n  top = Math.max(vhMargin, top);\n  if (top + elHeight > screenBottom) {\n    top = screenBottom - elHeight;\n  }\n\n  return { actualY, top };\n}\n\n/**\n * Attempts to position the fixed element so that it will appear fixed to the\n * bottom of the container element but also within the viewport boundaries. When\n * swapping is enabled, it will attempt to swap to the top position if it can't\n * fit within the viewport. If it can't fit in the viewport even after being\n * swapped to the top position or swapping is disabled, it will be positioned to\n * the bottom viewport boundary.\n *\n * @internal\n */\nexport function createAnchoredBottom(config: FixConfig): YPosition {\n  const { vhMargin, screenBottom, elHeight, disableSwapping, disableVHBounds } =\n    config;\n  let top = getBottomCoord(config);\n  let actualY: VerticalPosition = \"bottom\";\n  if (disableVHBounds || top > vhMargin) {\n    return { actualY, top };\n  }\n\n  const swappedTop = getTopCoord(config);\n  if (disableSwapping || swappedTop + elHeight > screenBottom) {\n    top = Math.min(top, screenBottom - elHeight);\n  } else {\n    actualY = \"top\";\n    top = swappedTop;\n  }\n\n  return { actualY, top };\n}\n\n/**\n * Attempts to position the fixed element so that it will appear completely\n * below the container element but also within the viewport boundaries. When\n * swapping is enabled, it will attempt to swap to the above position if it\n * can't fit within the viewport below the container element. If it can't fit in\n * the viewport even after being swapped above or swapping is disabled, it will\n * be positioned to the bottom viewport boundary.\n *\n * @internal\n */\nexport function createAnchoredBelow(config: FixConfig): YPosition {\n  const {\n    yMargin,\n    vhMargin,\n    elHeight,\n    screenBottom,\n    containerRect,\n    preventOverlap,\n    disableSwapping,\n    disableVHBounds,\n  } = config;\n  let top = getBelowCoord(config);\n  let actualY: VerticalPosition = \"below\";\n  if (disableVHBounds || top + elHeight <= screenBottom) {\n    return { actualY, top };\n  }\n\n  if (preventOverlap) {\n    const availableTop = containerRect.top - yMargin;\n    if (disableSwapping || availableTop < screenBottom - top) {\n      return {\n        actualY,\n        top,\n        bottom: vhMargin,\n      };\n    }\n\n    return {\n      actualY: \"above\",\n      top: Math.max(vhMargin, availableTop - elHeight),\n      // this makes it so that the bottom of the fixed element is the top of the container\n      // element. this ensures that it won't ever overlap the container element\n      bottom: getViewportSize(\"height\") - availableTop,\n    };\n  }\n\n  const swappedTop = getAboveCoord(config);\n  if (disableSwapping || swappedTop < vhMargin) {\n    top = Math.max(top, screenBottom - elHeight);\n  } else {\n    actualY = \"above\";\n    top = swappedTop;\n  }\n\n  return { actualY, top };\n}\n\n/**\n * Creates the vertical position for a fixed element with the provided options.\n *\n * @internal\n */\nexport function createVerticalPosition({\n  y,\n  vh,\n  vhMargin,\n  yMargin,\n  elHeight,\n  initialY,\n  containerRect,\n  disableSwapping,\n  preventOverlap,\n  disableVHBounds,\n}: Options): YPosition {\n  if (!disableVHBounds && !preventOverlap && elHeight > vh - vhMargin * 2) {\n    // the element is too big to be displayed in the viewport, so just span the\n    // full viewport excluding margins\n    return {\n      top: vhMargin,\n      bottom: vhMargin,\n      actualY: \"center\",\n    };\n  }\n\n  const config: FixConfig = {\n    vhMargin,\n    yMargin,\n    elHeight,\n    initialY,\n    containerRect,\n    screenBottom: vh - vhMargin,\n    preventOverlap,\n    disableSwapping,\n    disableVHBounds,\n  };\n\n  switch (y) {\n    case \"above\":\n      return createAnchoredAbove(config);\n    case \"top\":\n      return createAnchoredTop(config);\n    case \"center\":\n      return createAnchoredCenter(config);\n    case \"bottom\":\n      return createAnchoredBottom(config);\n    case \"below\":\n      return createAnchoredBelow(config);\n  }\n}\n"]},"metadata":{},"sourceType":"module"}